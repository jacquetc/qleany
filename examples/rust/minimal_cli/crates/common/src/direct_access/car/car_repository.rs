// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use std::fmt::Display;
use std::sync::Arc;

use crate::{
    database::transactions::Transaction,
    direct_access::repository_factory,
    entities::Car,
    event::{DirectAccessEntity, EntityEvent, Event, EventHub, Origin},
    types::EntityId,
};

use redb::Error;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum CarRelationshipField {}

impl Display for CarRelationshipField {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub trait CarTable {
    fn create(&mut self, entity: &Car) -> Result<Car, Error>;
    fn create_multi(&mut self, entities: &[Car]) -> Result<Vec<Car>, Error>;
    fn get(&self, id: &EntityId) -> Result<Option<Car>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Car>>, Error>;
    fn update(&mut self, entity: &Car) -> Result<Car, Error>;
    fn update_multi(&mut self, entities: &[Car]) -> Result<Vec<Car>, Error>;
    fn delete(&mut self, id: &EntityId) -> Result<(), Error>;
    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error>;
}

pub trait CarTableRO {
    fn get(&self, id: &EntityId) -> Result<Option<Car>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Car>>, Error>;
}

pub struct CarRepository<'a> {
    redb_table: Box<dyn CarTable + 'a>,
    transaction: &'a Transaction,
}

impl<'a> CarRepository<'a> {
    pub fn new(redb_table: Box<dyn CarTable + 'a>, transaction: &'a Transaction) -> Self {
        CarRepository {
            redb_table,
            transaction,
        }
    }

    pub fn create(&mut self, event_hub: &Arc<EventHub>, entity: &Car) -> Result<Car, Error> {
        let new = self.redb_table.create(entity)?;
        event_hub.send_event(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Car(EntityEvent::Created)),
            ids: vec![new.id.clone()],
            data: None,
        });
        Ok(new)
    }

    pub fn create_multi(
        &mut self,
        event_hub: &Arc<EventHub>,
        entities: &[Car],
    ) -> Result<Vec<Car>, Error> {
        let new_entities = self.redb_table.create_multi(entities)?;
        event_hub.send_event(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Car(EntityEvent::Created)),
            ids: new_entities.iter().map(|e| e.id.clone()).collect(),
            data: None,
        });
        Ok(new_entities)
    }

    pub fn get(&self, id: &EntityId) -> Result<Option<Car>, Error> {
        self.redb_table.get(id)
    }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Car>>, Error> {
        self.redb_table.get_multi(ids)
    }

    pub fn update(&mut self, event_hub: &Arc<EventHub>, entity: &Car) -> Result<Car, Error> {
        let updated = self.redb_table.update(entity)?;
        event_hub.send_event(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Car(EntityEvent::Updated)),
            ids: vec![updated.id.clone()],
            data: None,
        });
        Ok(updated)
    }

    pub fn update_multi(
        &mut self,
        event_hub: &Arc<EventHub>,
        entities: &[Car],
    ) -> Result<Vec<Car>, Error> {
        let updated = self.redb_table.update_multi(entities)?;
        event_hub.send_event(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Car(EntityEvent::Updated)),
            ids: updated.iter().map(|e| e.id.clone()).collect(),
            data: None,
        });
        Ok(updated)
    }

    pub fn delete(&mut self, event_hub: &Arc<EventHub>, id: &EntityId) -> Result<(), Error> {
        let entity = match self.redb_table.get(id)? {
            Some(e) => e,
            None => return Ok(()),
        };
        // get all strong forward relationship fields

        // delete all strong relationships, initiating a cascade delete

        // delete entity
        self.redb_table.delete(id)?;
        event_hub.send_event(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Car(EntityEvent::Removed)),
            ids: vec![id.clone()],
            data: None,
        });
        Ok(())
    }

    pub fn delete_multi(
        &mut self,
        event_hub: &Arc<EventHub>,
        ids: &[EntityId],
    ) -> Result<(), Error> {
        let entities = self.redb_table.get_multi(ids)?;
        if entities.is_empty() || entities.iter().all(|e| e.is_none()) {
            return Ok(());
        }

        // get all strong forward relationship fields

        // delete all strong relationships, initiating a cascade delete

        self.redb_table.delete_multi(ids)?;
        event_hub.send_event(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Car(EntityEvent::Removed)),
            ids: ids.into(),
            data: None,
        });
        Ok(())
    }
}

pub struct CarRepositoryRO<'a> {
    redb_table: Box<dyn CarTableRO + 'a>,
}
impl<'a> CarRepositoryRO<'a> {
    pub fn new(redb_table: Box<dyn CarTableRO + 'a>) -> Self {
        CarRepositoryRO { redb_table }
    }
    pub fn get(&self, id: &EntityId) -> Result<Option<Car>, Error> {
        self.redb_table.get(id)
    }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Car>>, Error> {
        self.redb_table.get_multi(ids)
    }
}
