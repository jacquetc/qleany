import { VerticalBox, HorizontalBox, ScrollView, Button, CheckBox } from "std-widgets.slint";
import { StyledButton } from "misc.slint";

// Reusable checkable reorderable list component
//
// API
// - ListItem: struct describing one row (id:int, text:string, subtitle:string, checked:bool)
// - ReorderableList: embeddable component that shows a draggable list
//
// Properties:
//   • in-out property <[ListItem]> items – bind/provide your model here
//   • in-out property <bool> reorderable – enable/disable drag reordering (default: true)
//   • in-out property <bool> enable-delete – show delete option in context menu (default: false)
//   • in-out property <bool> enable-checkbox – show checkboxes on items (default: false)
//   • in-out property <int> selected-id – currently selected item id (default: -1)
//   • in-out property <int> max-text-length – maximum text length before left elide (default: 50)
//   • in-out property <[string]> elided-texts – pre-computed elided texts (parallel array to items)
//     When a text exceeds max-text-length, populate this array with "...{suffix}" versions
//
// Styling Properties:
//   • in property <length> item-height – height of each list item (default: 60px)
//   • in property <brush> item-background – background color of list items (default: white)
//   • in property <brush> accent-color – primary/highlight color (default: #2196f3)
//   • in property <brush> item-border-color – border color of list items (default: #e0e0e0)
//   • in property <brush> text-color – main text color (default: #212121)
//   • in property <brush> subtitle-color – subtitle text color (default: #21212180)
//   • in property <brush> container-background – background of the list container (default: white)
//
// Callbacks:
//   • callback request-reorder(from:int, to:int) – emitted when the user drops
//     an item at a new location. Typical usage from Rust is to update your
//     VecModel accordingly.
//   • callback request-delete(id:int) – emitted when user requests item deletion
//   • callback request-check-change(id:int, checked:bool) – emitted when checkbox toggled
//   • callback selection-changed(id:int) – emitted when user selects a row
//
// Notes
// - The component is file-local and can be compiled/used from any project by
//   pointing slint_build::compile() to this file and using include_modules!().
// - The component does not mutate external models itself; instead it emits
//   callbacks so the hosting application can update its data source.
//   This is the recommended pattern with Slint models.
// - Accessibility: supports keyboard navigation (Tab) and keyboard reordering (Alt+Up/Down)
//
// Example: Using left elide for long text (Rust side):
//   let max_len = 50;
//   let elided_texts: Vec<SharedString> = items
//       .iter()
//       .map(|item| {
//           let text = item.text.as_str();
//           if text.chars().count() > max_len {
//               SharedString::from(format!("...{}",
//                   text.chars().skip(text.chars().count() - max_len).collect::<String>()))
//           } else {
//               SharedString::default()  // Empty string means no elide
//           }
//       })
//       .collect();
//   app.set_elided_texts(VecModel::from(elided_texts).into());

export struct ListItem {
    id: int,
    text: string,
    // Optional subtitle: leave empty to hide
    subtitle: string,
    // Checkbox state (only used when enable-checkbox is true)
    checked: bool,
}

// Utility: array membership test usable in property bindings
// (No script helpers; keep component simple and bind to parallel models)

component DraggableItem inherits Rectangle {
    in property <int> index;
    in property <ListItem> item;

    // Customization properties
    in property <length> visual-height: 40px;
    in property <brush> theme-background: white;
    in property <brush> theme-border: #e0e0e0;
    in property <brush> theme-primary: #2196f3;
    in property <brush> theme-highlight: #e3f2fd; // Light background for drop targets
    in property <brush> theme-text: #212121;
    in property <brush> theme-subtitle: #21212180; // Subtitle text color
    // When true, display the portion after the last "/" in bold
    in property <bool> bold-after-slash: false;
    // Pre-computed text parts for bold display (set by parent)
    in property <string> text-prefix: "";
    in property <string> text-bold: "";
    // When true, align text to the right
    in property <bool> text-align-right: false;
    // Maximum text length before left elide
    in property <int> max-text-length: 50;
    // Pre-computed elided text (set by parent when text exceeds max-text-length)
    in property <string> elided-text: "";
    // Pre-computed elided text parts for bold display (when bold-after-slash is true)
    in property <string> elided-prefix: "";
    in property <string> elided-bold: "";

    callback move-item(int); // Request reorder by offset

    in property <bool> is-dragging;
    in property <bool> is-drop-target;
    // When true, show a drop indicator on the bottom edge (used for drop-after-last)
    in property <bool> is-bottom-drop-target: false;
    in property <bool> interactive: true;
    // Feature flags and external state
    in property <bool> reorderable: true;
    in property <bool> enable-delete: false;
    in property <bool> enable-checkbox: false;
    in property <int> selected-id: -1;
    // Menu visibility controlled by parent
    in property <bool> show-menu: false;
    // Callbacks to outer world
    callback request-delete(int);
    callback request-check-change(int, bool);
    callback selection-changed(int);
    // Control menu state from parent
    callback open-menu(int);
    // Provide geometry of the menu button so parent can position a centralized popup
    // Parameters: index, id, btn-x, btn-y, btn-w, btn-h
    callback open-menu-geo(int, int, length, length, length, length);
    callback close-menu();
    
    callback drag-started(int);
    callback drag-moved(length);
    // Horizontal drag delta (for natural wobble). Consumers may ignore.
    callback drag-moved-x(length);
    callback drag-ended();
    
    // Accessibility
    accessible-role: list-item;
    accessible-label: item.text;

    height: visual-height;
    // Note: z must be a number literal in this Slint version; keep at default level
    z: 0;

    // Logic for keyboard focus
    focus_scope := FocusScope {
        x: 0; y: 0; width: parent.width; height: parent.height;
        enabled: root.interactive;

        key-pressed(event) => {
             if (root.reorderable && event.modifiers.alt) {
                 if (event.text == Key.UpArrow) {
                     root.move-item(-1);
                     return accept;
                 }
                 if (event.text == Key.DownArrow) {
                     root.move-item(1);
                     return accept;
                 }
             }
             return reject;
        }
    }

    // Styling
    // Note: Assuming colors are solid for simple darkening
    background: is-drop-target ? theme-highlight : (touch.pressed ? theme-background.darker(0.1) : (touch.has-hover ? theme-background.darker(0.05) : theme-background));
    border-radius: 4px;
    border-width: focus_scope.has-focus ? 2px : 1px;
    border-color: focus_scope.has-focus ? theme-primary : (is-drop-target ? theme-primary : theme-border);
    // Add elevation while dragging for visual clarity
    drop-shadow-blur: is-dragging ? 8px : 0px;
    drop-shadow-color: #00000026;
    
    // Drop indicator line at top
    if is-drop-target: Rectangle {
        y: -2px;
        height: 3px;
        width: 100%;
        background: theme-primary;
        border-radius: 2px;
    }
    // Drop indicator line at bottom (for dropping after the last item)
    if is-bottom-drop-target: Rectangle {
        y: parent.height - 1px;
        height: 3px;
        width: 100%;
        background: theme-primary;
        border-radius: 2px;
    }
    
    // Content row
    HorizontalBox {
        padding: 2px;
        spacing: 2px;

        // Optional checkbox on the far left
        if enable-checkbox: CheckBox {
            checked: item.checked;
            // Forward change to the outside world
            toggled => { if (item.id >= 0) { request-check-change(item.id, self.checked); } }
        }

        // Drag handle (hidden if not reorderable)
        drag_handle := Rectangle {
            visible: reorderable;
            width: 24px;
            background: transparent;
            VerticalLayout {
                alignment: center;
                for i in 3: Rectangle {
                    height: 2px;
                    width: 16px;
                    background: theme-border.darker(0.3);
                    border-radius: 1px;
                }
            }
            // Dedicated handle-only touch area to initiate and own the drag gesture
            TouchArea {
                x: 0px; y: 0px; width: parent.width; height: parent.height;
                enabled: interactive && reorderable;
                mouse-cursor: move;
                pointer-event(event) => {
                    if (event.kind == PointerEventKind.down && event.button == PointerEventButton.left) {
                        drag-armed = true;
                        drag-started(index);
                        return true;
                    } else if (event.kind == PointerEventKind.move) {
                        // Continue dragging even if the pointer leaves the handle bounds.
                        if (drag-armed) {
                            drag-moved(self.mouse-y - self.pressed-y);
                            drag-moved-x(self.mouse-x - self.pressed-x);
                            return true;
                        }
                    } else if (event.kind == PointerEventKind.up && event.button == PointerEventButton.left) {
                        if (drag-armed) {
                            drag-ended();
                            drag-armed = false;
                            return true;
                        }
                    }
                    return false;
                }
            }
        }

        // Spacer to push text to far right
        if text-align-right: Rectangle { background: transparent; horizontal-stretch: 1; }

        // Title + optional subtitle
        VerticalLayout {
            spacing: 2px;

            // Normal text display (when bold-after-slash is false)
            if !bold-after-slash: Text {
                text: elided-text != "" ? elided-text : item.text;
                vertical-alignment: center;
                horizontal-alignment: text-align-right ? right : left;
                font-size: 14px;
                color: theme-text;
            }
            // Bold filename display (when bold-after-slash is true)
            if bold-after-slash: HorizontalLayout {
                spacing: 0px;
                alignment: text-align-right ? end : start;
                Text {
                    text: elided-prefix != "" ? elided-prefix : text-prefix;
                    vertical-alignment: center;
                    font-size: 14px;
                    color: theme-text;
                }
                Text {
                    text: elided-bold != "" ? elided-bold : text-bold;
                    vertical-alignment: center;
                    font-size: 14px;
                    font-weight: 700;
                    color: theme-text;
                }
            }
            if item.subtitle != "": Text {
                text: item.subtitle;
                font-size: 11px;
                horizontal-alignment: text-align-right ? right : left;
                color: theme-subtitle;
            }
        }

        // Spacer to push text to far left
        if !text-align-right: Rectangle { background: transparent; horizontal-stretch: 1; }

        // Spacer to push menu button to far right
        if enable-delete: Rectangle { background: transparent; horizontal-stretch: 1; }

        // Context menu button (visible when hovered or selected)
        menu_btn := StyledButton {
            width: 40px;
            flat: true;
            visible: enable-delete && (touch.has-hover || (selected-id == item.id));
            text: "⋯";
            clicked => {
                if (show-menu) { close-menu(); }
                else { open-menu-geo(index, item.id, self.x, self.y, self.width, self.height); }
            }
        }
    }

    // (Removed per-row popup; centralized popup is rendered by parent)
    
    // Place the drag-capturing touch area behind interactive children so
    // it doesn't block clicks on CheckBox or the menu Button.
    // Only allow starting a drag from the handle area
    private property <bool> drag-armed: false;

    // Row-wide touch area for selection (does not start drag)
    touch := TouchArea {
        x: 0px; y: 0px; width: parent.width; height: parent.height;
        z: -1;
        mouse-cursor: pointer;
        enabled: interactive;
        pointer-event(event) => {
            // Selection click when not dragging
            if (event.kind == PointerEventKind.up && event.button == PointerEventButton.left && !drag-armed) {
                close-menu();
                selection-changed(item.id);
                // Give focus to the FocusScope so keyboard navigation (Alt+Up/Down) works
                focus_scope.focus();
                return true;
            }
            return false;
        }
    }

    // Note: The handle-only TouchArea is embedded inside the drag_handle to ensure
    // consistent coordinate space and reliable gesture ownership.
}

export component CheckableReorderableList inherits Rectangle {
    // Reusable list container (not a Window). Intended to be embedded in any Window.
    width: 100%;
    height: 100%;
    background: transparent;
    
    // Public API
    in-out property <[ListItem]> items;
    // Optional features
    in-out property <bool> reorderable: true;
    in-out property <bool> enable-delete: false;
    in-out property <bool> enable-checkbox: false;
    // Selection state (used to show context menu button)
    in-out property <int> selected-id: -1;
    // When true, display the portion after the last "/" in bold for each item
    in-out property <bool> bold-after-slash: false;
    // Pre-computed text parts for bold display (parallel arrays, same length as items)
    // These should be set by the parent when bold-after-slash is true
    in-out property <[string]> text-prefixes: [];
    in-out property <[string]> text-bolds: [];
    // When true, align text to the right
    in-out property <bool> text-align-right: false;
    // Maximum text length before left elide (default: 50)
    in-out property <int> max-text-length: 50;
    // Pre-computed elided texts (parallel array, same length as items)
    // When text length exceeds max-text-length, this should contain "...{suffix}"
    in-out property <[string]> elided-texts: [];
    // Pre-computed elided text parts for bold display (parallel arrays, same length as items)
    // When bold-after-slash is true and text is elided, these contain the split parts
    in-out property <[string]> elided-prefixes: [];
    in-out property <[string]> elided-bolds: [];

    // Styling configuration
    in property <length> item-height: 50px;
    in property <brush> item-background: white;
    in property <brush> accent-color: #2196f3;
    in property <brush> item-border-color: #e0e0e0;
    in property <brush> text-color: #212121;
    in property <brush> subtitle-color: #21212180; // text-color with ~50% opacity
    in property <brush> container-background: white;
    // Events to the outside
    callback request-delete(int);
    callback request-check-change(int, bool);
    // Selection change emitted when user clicks a row
    callback selection-changed(int);

    // Internal state (not part of the public API)
    private property <int> dragging-index: -1;
    private property <int> drop-target-index: -1;
    // Whether the drop position for the targeted item is after (bottom edge) or before (top edge)
    private property <bool> drop-after: false;
    private property <length> drag-offset: 0px;
    // Horizontal wiggle during drag for a more natural feel
    private property <length> drag-offset-x: 0px;
    // Store the data of the currently dragged item for the floating preview
    private property <int> dragging-id: -1;
    private property <string> dragging-text: "";
    // Which item's context menu is open (-1 = none)
    private property <int> open-menu-index: -1;
    private property <int> open-menu-id: -1;
    // Centralized popup position
    private property <length> menu-x: 0px;
    private property <length> menu-y: 0px;
    private property <length> menu-width: 120px;
    private property <length> menu-height: 32px;
    // Pending selection id for deferred callback (to avoid crash during UI rebuild)
    private property <int> pending-selection-id: -1;
    // Property to control the selection timer
    private property <bool> selection-timer-running: false;
    
    // Emitted when the user requests a reorder. The hosting app should update
    // its data/model accordingly.
    callback request-reorder(int, int);
    
    // Timer to defer selection-changed callback, preventing crash when conditional UI rebuilds
    Timer {
        interval: 1ms;
        running: root.selection-timer-running;
        triggered => {
            root.selection-timer-running = false;
            if (root.pending-selection-id >= 0) {
                root.selection-changed(root.pending-selection-id);
                root.pending-selection-id = -1;
            }
        }
    }
    
    // Global background catcher: closes menu when clicking on empty areas
    TouchArea {
        x: 0px; y: 0px; width: parent.width; height: parent.height;
        z: -1;
        enabled: open-menu-index >= 0;
        // Only effective where no other controls handle the event (placed before content)
        clicked => { open-menu-index = -1; }
    }

    VerticalBox {
        padding: 5px;
        
        
        Rectangle {
            background: root.container-background;
            border-radius: 8px;
            drop-shadow-blur: 4px;
            drop-shadow-color: #0000001a;
            clip: true;
            
            // Main list container
            ScrollView {
                viewport-height: items.length * root.item-height;
                // Disable ScrollView interaction only while dragging to ensure the
                // gesture is not stolen when the drag starts. This fixes the
                // immediate-drag freeze on some platforms.
                enabled: root.dragging-index < 0;
                // Catch clicks on list background (areas with no rows)
                TouchArea {
                    x: 0px; y: 0px; width: parent.width; height: parent.height;
                    enabled: root.open-menu-index >= 0;
                    clicked => { root.open-menu-index = -1; }
                }
                
                for item[idx] in items: DraggableItem {
                    // Keep original items at fixed positions; only the floating preview moves.
                    // This avoids feedback loops where changing the component's y would change
                    // local mouse coordinates and cause the dragged item to jitter between positions.
                    y: idx * root.item-height + 2px;
                    x: 4px;
                    width: parent.width - 30px;
                    index: idx;

                    // Bind styling
                    visual-height: root.item-height - 4px;
                    theme-background: root.item-background;
                    theme-primary: root.accent-color;
                    theme-border: root.item-border-color;
                    theme-text: root.text-color;
                    theme-subtitle: root.subtitle-color;
                    // Bold filename display
                    bold-after-slash: root.bold-after-slash;
                    text-prefix: root.bold-after-slash && idx < root.text-prefixes.length ? root.text-prefixes[idx] : "";
                    text-bold: root.bold-after-slash && idx < root.text-bolds.length ? root.text-bolds[idx] : "";
                    // Text alignment
                    text-align-right: root.text-align-right;
                    // Text elide
                    max-text-length: root.max-text-length;
                    elided-text: idx < root.elided-texts.length ? root.elided-texts[idx] : "";
                    elided-prefix: idx < root.elided-prefixes.length ? root.elided-prefixes[idx] : "";
                    elided-bold: idx < root.elided-bolds.length ? root.elided-bolds[idx] : "";

                    // Handle keyboard reorder
                    move-item(offset) => {
                         let to = idx + offset;
                         // Clamp or check bounds
                         if (to >= 0 && to < items.length && idx >= 0 && idx < items.length) {
                             root.request-reorder(idx, to);
                         }
                    }
                    item: item;
                    is-dragging: idx == dragging-index;
                    reorderable: root.reorderable;
                    enable-delete: root.enable-delete;
                    enable-checkbox: root.enable-checkbox;
                    selected-id: root.selected-id;
                    show-menu: idx == open-menu-index;
                    // Show top indicator when dropping before this item
                    is-drop-target: idx == drop-target-index && !drop-after && idx != dragging-index;
                    // Show bottom indicator when dropping after this item (including the last one)
                    is-bottom-drop-target: idx == drop-target-index && drop-after && idx != dragging-index;
                    // Hide the original item only after the drag actually moves.
                    // Keeping it visible on press ensures the handle keeps the gesture
                    // and avoids early freeze on scrollable lists.
                    opacity: (idx == dragging-index && root.drag-offset != 0px) ? 0.0 : 1.0;
                    interactive: true;
                    // Wire callbacks
                    request-delete(id) => { if (id >= 0) { root.request-delete(id); } }
                    request-check-change(id, state) => { if (id >= 0) { root.request-check-change(id, state); } }
                    // Use deferred selection to avoid crash when conditional UI rebuilds during event processing
                    selection-changed(id) => {
                        if (id >= 0) {
                            root.selected-id = id;
                            root.pending-selection-id = id;
                            root.selection-timer-running = true;
                        }
                    }
                    open-menu(i) => { if (i >= 0) { root.open-menu-index = i; } }
                    open-menu-geo(i, id_val, bx, by, bw, bh) => {
                        if (i < 0 || id_val < 0) { }
                        else {
                            // Base position of this row within the Flickable
                            let row_x = 4px;
                            let row_y = idx * root.item-height + 2px;

                            // Position the popup below the button, right-aligned to it, but elsewhere if it would overflow
                            if (row_x + bx + bw + root.menu-width > parent.width && row_y + by + bh + root.menu-height > parent.height) {
                                // Overflowing right edge and bottom edge: align left edge to button left edge, above button
                                root.menu-x = row_x + bx;
                                root.menu-y = row_y + by - root.menu-height - 4px;
                            }

                            else if (row_x + bx + bw + root.menu-width > parent.width) {
                                // Overflowing right edge: align left edge to button left edge
                                root.menu-x = row_x + bx;
                                root.menu-y = row_y + by + bh + 4px;
                            }
                            else if (row_y + by + bh + root.menu-height > parent.height) {
                                // Overflowing bottom edge: align above the button
                                root.menu-x = row_x + bx + bw - root.menu-width;
                                root.menu-y = row_y + by - root.menu-height - 4px;
                            }
                            else {
                                // Normal case: align right edge to button right edge
                                root.menu-x = row_x + bx + bw - root.menu-width;
                                root.menu-y = row_y + by + bh + 4px;
                            }
                            root.open-menu-index = i;
                            root.open-menu-id = id_val;
                        }
                    }
                    close-menu() => { root.open-menu-index = -1; root.open-menu-id = -1; }
                    
                    drag-started(i) => {
                        root.dragging-index = i;
                        root.drag-offset = 0px;
                        root.drag-offset-x = 0px;
                        root.dragging-id = item.id;
                        root.dragging-text = item.text;
                    }
                    
                    drag-moved(delta) => {
                        root.drag-offset = delta;
                        // Compute the dragged item's center in "index space"
                        // Each row step is item-height
                        let drag_center_index = root.dragging-index + (root.drag-offset / root.item-height);
                        // Find nearest fixed item index and clamp to valid items
                        let nearest_idx = max(0, min(items.length - 1, round(drag_center_index)));
                        root.drop-target-index = nearest_idx;
                        // Decide whether to drop before (top) or after (bottom) the nearest item
                        // If the dragged center is below the nearest item's center (>=), choose after
                        root.drop-after = drag_center_index >= nearest_idx;
                    }
                    // Horizontal movement handler: allow a limited horizontal wobble
                    drag-moved-x(dx) => {
                        // Clamp to ±32px for subtle horizontal motion
                        let limit = 32px;
                        root.drag-offset-x = max(-limit, min(limit, dx));
                    }
                    
                    drag-ended() => {
                        if (root.dragging-index >= 0 && root.drop-target-index >= 0 && root.dragging-index < items.length && root.drop-target-index < items.length) {
                            let to_slot = root.drop-target-index + (root.drop-after ? 1 : 0);
                            if (root.dragging-index != to_slot && to_slot >= 0 && to_slot <= items.length) {
                                request-reorder(root.dragging-index, to_slot);
                            }
                        }
                        root.dragging-index = -1;
                        root.drop-target-index = -1;
                        root.drag-offset = 0px;
                        root.drop-after = false;
                        root.drag-offset-x = 0px;
                        root.dragging-id = -1;
                        root.dragging-text = "";
                    }
                }
                // Note: Do NOT place a full-screen overlay TouchArea during drag.
                // The handle touch area already accepts the gesture, preventing Flickable
                // from stealing it. An overlay here would intercept move events and can
                // freeze the drag on scrollable lists.

                // Floating preview of the dragged item, rendered after the list so it's on top
                if dragging-index >= 0: DraggableItem {
                    y: dragging-index * root.item-height + 2px + drag-offset;
                    x: 4px + drag-offset-x;
                    width: parent.width - 8px;
                    index: dragging-index;
                    item: { id: dragging-id, text: dragging-text, subtitle: "" };
                    
                    // Bind styling
                    visual-height: root.item-height - 4px;
                    theme-background: root.item-background;
                    theme-primary: root.accent-color;
                    theme-border: root.item-border-color;
                    theme-text: root.text-color;
                    theme-subtitle: root.subtitle-color;

                    is-dragging: true;
                    is-drop-target: false;
                    reorderable: root.reorderable;
                    interactive: false;
                    // Half-transparent while dragging
                    opacity: 0.5;
                }
                // Centralized context menu popup, rendered above rows
                Rectangle {
                    visible: root.open-menu-index >= 0 && root.enable-delete;
                    z: 1;
                    x: root.menu-x;
                    y: root.menu-y;
                    width: root.menu-width;
                    height: root.enable-delete ? root.menu-height : 0px;
                    background: white;
                    border-radius: 6px;
                    border-width: 1px;
                    border-color: #e0e0e0;
                    drop-shadow-blur: 6px;
                    drop-shadow-color: #00000033;
                    if root.enable-delete: Button {
                        width: parent.width;
                        height: 28px;
                        text: "Delete";
                        clicked => {
                            // Invoke delete for the currently open item id
                            if (root.open-menu-id >= 0 && root.open-menu-index >= 0) { root.request-delete(root.open-menu-id); }
                            root.open-menu-index = -1;
                            root.open-menu-id = -1;
                        }
                    }
                }
            }
        }
        
    }
}
