// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use crate::types::EntityId;
use flume::{Receiver, Sender, unbounded};
use serde::Serialize;
use std::{
    sync::{Arc, Mutex, atomic::AtomicBool},
    thread,
};

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum EntityEvent {
    Created,
    Updated,
    Removed,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum AllEvent {
    Reset,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum UndoRedoEvent {
    Undone,
    Redone,
    BeginComposite,
    EndComposite,
    CancelComposite,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum LongOperationEvent {
    Started,
    Progress,
    Cancelled,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum DirectAccessEntity {
    All(AllEvent),

    Dto(EntityEvent),
    DtoField(EntityEvent),
    Global(EntityEvent),
    Relationship(EntityEvent),
    UserInterface(EntityEvent),
    Root(EntityEvent),
    Workspace(EntityEvent),
    System(EntityEvent),
    Entity(EntityEvent),
    Field(EntityEvent),
    Feature(EntityEvent),
    File(EntityEvent),
    UseCase(EntityEvent),
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum HandlingAppLifecycleEvent {
    InitializeApp,
    CleanUpBeforeExit,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum HandlingManifestEvent {
    Load,
    Save,
    New,
    Close,
    ExportToMermaid,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum RustFileGenerationEvent {
    FillRustFiles,
    GenerateRustCode,
    GenerateRustFiles,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum CppQtFileGenerationEvent {
    FillCppQtFiles,
    GenerateCppQtCode,
    GenerateCppQtFiles,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum Origin {
    DirectAccess(DirectAccessEntity),
    UndoRedo(UndoRedoEvent),
    LongOperation(LongOperationEvent),

    HandlingAppLifecycle(HandlingAppLifecycleEvent),
    HandlingManifest(HandlingManifestEvent),
    RustFileGeneration(RustFileGenerationEvent),
    CppQtFileGeneration(CppQtFileGenerationEvent),
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub struct Event {
    pub origin: Origin,
    pub ids: Vec<EntityId>,
    pub data: Option<String>,
}

impl Event {
    pub fn origin_string(&self) -> String {
        match &self.origin {
            Origin::DirectAccess(entity) => match entity {
                DirectAccessEntity::All(event) => format!("direct_access_all_{:?}", event),
                // entities
                DirectAccessEntity::Dto(event) => format!("direct_access_dto_{:?}", event),
                DirectAccessEntity::DtoField(event) => {
                    format!("direct_access_dto_field_{:?}", event)
                }
                DirectAccessEntity::Global(event) => format!("direct_access_global_{:?}", event),
                DirectAccessEntity::Relationship(event) => {
                    format!("direct_access_relationship_{:?}", event)
                }
                DirectAccessEntity::UserInterface(event) => {
                    format!("direct_access_user_interface_{:?}", event)
                }
                DirectAccessEntity::Root(event) => format!("direct_access_root_{:?}", event),
                DirectAccessEntity::Workspace(event) => {
                    format!("direct_access_workspace_{:?}", event)
                }
                DirectAccessEntity::System(event) => format!("direct_access_system_{:?}", event),
                DirectAccessEntity::Entity(event) => format!("direct_access_entity_{:?}", event),
                DirectAccessEntity::Field(event) => format!("direct_access_field_{:?}", event),
                DirectAccessEntity::Feature(event) => format!("direct_access_feature_{:?}", event),
                DirectAccessEntity::File(event) => format!("direct_access_file_{:?}", event),
                DirectAccessEntity::UseCase(event) => format!("direct_access_use_case_{:?}", event),
            },
            Origin::UndoRedo(event) => format!("undo_redo_{:?}", event),
            Origin::LongOperation(event) => format!("long_operation_{:?}", event),
            // features
            Origin::HandlingAppLifecycle(event) => format!("handling_app_lifecycle_{:?}", event),
            Origin::HandlingManifest(event) => format!("handling_manifest_{:?}", event),
            Origin::RustFileGeneration(event) => format!("rust_file_generation_{:?}", event),
            Origin::CppQtFileGeneration(event) => {
                format!("cpp_qt_file_generation_{:?}", event)
            }
        }
        .to_lowercase()
    }
}
pub type Queue = Arc<Mutex<Vec<Event>>>;

/// Central event hub for managing subscriptions and dispatching events
pub struct EventHub {
    sender: Sender<Event>,
    receiver: Receiver<Event>,
    queue: Queue,
}

impl Default for EventHub {
    fn default() -> Self {
        Self::new()
    }
}

impl EventHub {
    /// Create a new event hub
    pub fn new() -> Self {
        let (sender, receiver) = unbounded();
        EventHub {
            sender,
            receiver,
            queue: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Start the event processing loop
    pub fn start_event_loop(&self, stop_signal: Arc<AtomicBool>) {
        let receiver = self.receiver.clone();
        let queue = self.queue.clone();
        thread::spawn(move || {
            loop {
                if stop_signal.load(std::sync::atomic::Ordering::Relaxed) {
                    break;
                }

                match receiver.recv() {
                    Ok(event) => {
                        let mut queue = queue.lock().unwrap();
                        queue.push(event.clone());
                    }
                    Err(_) => {
                        //println!("EventHub receiver dropped");
                        break;
                    }
                };
            }
        });
    }

    /// Send an event to the queue
    pub fn send_event(&self, event: Event) {
        self.sender.send(event).unwrap();
    }

    pub fn get_queue(&self) -> Queue {
        self.queue.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_hub_send_and_receive() {
        let event_hub = EventHub::new();
        let stop_signal = Arc::new(AtomicBool::new(false));
        event_hub.start_event_loop(stop_signal.clone());

        let event = Event {
            origin: Origin::DirectAccess(DirectAccessEntity::All(AllEvent::Reset)),
            ids: vec![EntityId::default()],
            data: Some("test_data".to_string()),
        };

        event_hub.send_event(event.clone());

        thread::sleep(std::time::Duration::from_millis(100));

        let queue = event_hub.get_queue();
        let queue = queue.lock().unwrap();
        assert_eq!(queue.len(), 1);
        assert_eq!(queue[0], event);

        stop_signal.store(true, std::sync::atomic::Ordering::Relaxed);
    }
}
