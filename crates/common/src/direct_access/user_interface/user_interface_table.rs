// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use super::user_interface_repository::UserInterfaceRelationshipField;
use super::user_interface_repository::UserInterfaceTable;
use super::user_interface_repository::UserInterfaceTableRO;
use crate::database::Bincode;
use crate::database::db_helpers;
use crate::entities::UserInterface;
use crate::types::EntityId;
use redb::{Error, ReadTransaction, ReadableTable, TableDefinition, WriteTransaction};

const USER_INTERFACE_TABLE: TableDefinition<EntityId, Bincode<UserInterface>> =
    TableDefinition::new("user_interface");
const COUNTER_TABLE: TableDefinition<String, EntityId> = TableDefinition::new("__counter");
// forward relationships

// backward relationships

const USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE: TableDefinition<
    EntityId,
    Vec<EntityId>,
> = TableDefinition::new("user_interface_from_workspace_user_interface_junction");

pub struct UserInterfaceRedbTable<'a> {
    transaction: &'a WriteTransaction,
}
impl<'a> UserInterfaceRedbTable<'a> {
    pub fn new(transaction: &'a WriteTransaction) -> Self {
        UserInterfaceRedbTable { transaction }
    }

    pub fn init_tables(transaction: &WriteTransaction) -> Result<(), Error> {
        transaction.open_table(USER_INTERFACE_TABLE)?;
        transaction.open_table(COUNTER_TABLE)?;

        transaction.open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;
        Ok(())
    }
}

impl<'a> UserInterfaceTable for UserInterfaceRedbTable<'a> {
    fn create(&mut self, entity: &UserInterface) -> Result<UserInterface, Error> {
        let v = self.create_multi(std::slice::from_ref(entity))?;
        Ok(v.into_iter().next().unwrap())
    }
    fn get(&self, id: &EntityId) -> Result<Option<UserInterface>, Error> {
        let v = self.get_multi(std::slice::from_ref(id))?;
        Ok(v.into_iter().next().unwrap())
    }
    fn update(&mut self, entity: &UserInterface) -> Result<UserInterface, Error> {
        let v = self.update_multi(std::slice::from_ref(entity))?;
        Ok(v.into_iter().next().unwrap())
    }
    fn delete(&mut self, id: &EntityId) -> Result<(), Error> {
        self.delete_multi(std::slice::from_ref(id))
    }

    fn create_multi(&mut self, entities: &[UserInterface]) -> Result<Vec<UserInterface>, Error> {
        let mut created = Vec::new();
        let mut counter_table = self.transaction.open_table(COUNTER_TABLE)?;
        let mut counter = if let Some(counter) = counter_table.get(&"user_interface".to_string())? {
            counter.value()
        } else {
            1
        };
        let mut user_interface_table = self.transaction.open_table(USER_INTERFACE_TABLE)?;

        for entity in entities {
            let new_entity = if entity.id == EntityId::default() {
                UserInterface {
                    id: counter,
                    ..entity.clone()
                }
            } else {
                if user_interface_table.get(&entity.id)?.is_some() {
                    return Err(Error::TableDoesNotExist(
                        format!("UseCase id {} already in use", &entity.id).to_string(),
                    ));
                }
                entity.clone()
            };

            user_interface_table.insert(new_entity.id, new_entity.clone())?;

            created.push(new_entity);
            if entity.id == EntityId::default() {
                counter += 1;
            }
        }
        counter_table.insert("user_interface".to_string(), counter)?;
        Ok(created)
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<UserInterface>>, Error> {
        let mut list = Vec::new();
        let user_interface_table = self.transaction.open_table(USER_INTERFACE_TABLE)?;

        if ids.is_empty() {
            let mut iter = user_interface_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = user_interface_table.get(id)? {
                    let mut entity = guard.value().clone();

                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }

    fn update_multi(&mut self, entities: &[UserInterface]) -> Result<Vec<UserInterface>, Error> {
        let mut updated = Vec::new();
        let mut user_interface_table = self.transaction.open_table(USER_INTERFACE_TABLE)?;

        for entity in entities {
            user_interface_table.insert(entity.id, entity)?;

            updated.push(entity.clone());
        }
        Ok(updated)
    }

    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error> {
        let mut user_interface_table = self.transaction.open_table(USER_INTERFACE_TABLE)?;

        // forward relationships

        // backward relationships

        let mut backward_workspace_user_interface_junction_table = self
            .transaction
            .open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        for id in ids {
            user_interface_table.remove(id)?;

            db_helpers::delete_from_backward_junction_table(
                &mut backward_workspace_user_interface_junction_table,
                id,
            )?;
        }
        Ok(())
    }
}

pub struct UserInterfaceRedbTableRO<'a> {
    transaction: &'a ReadTransaction,
}
impl<'a> UserInterfaceRedbTableRO<'a> {
    pub fn new(transaction: &'a ReadTransaction) -> Self {
        UserInterfaceRedbTableRO { transaction }
    }
}

impl<'a> UserInterfaceTableRO for UserInterfaceRedbTableRO<'a> {
    fn get(&self, id: &EntityId) -> Result<Option<UserInterface>, Error> {
        let v = self.get_multi(std::slice::from_ref(id))?;
        Ok(v.into_iter().next().unwrap())
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<UserInterface>>, Error> {
        let mut list = Vec::new();
        let user_interface_table = self.transaction.open_table(USER_INTERFACE_TABLE)?;

        if ids.is_empty() {
            let mut iter = user_interface_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = user_interface_table.get(id)? {
                    let mut entity = guard.value().clone();

                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }
}
