// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use super::workspace_repository::WorkspaceRelationshipField;
use super::workspace_repository::WorkspaceTable;
use super::workspace_repository::WorkspaceTableRO;
use crate::database::db_helpers;
use crate::database::Bincode;
use crate::entities::Workspace;
use crate::types::EntityId;
use redb::{Error, ReadTransaction, ReadableTable, TableDefinition, WriteTransaction};

const WORKSPACE_TABLE: TableDefinition<EntityId, Bincode<Workspace>> =
    TableDefinition::new("workspace");
const COUNTER_TABLE: TableDefinition<String, EntityId> = TableDefinition::new("__counter");
// forward relationships

const GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("global_from_workspace_global_junction");
const ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("entity_from_workspace_entities_junction");
const FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("feature_from_workspace_features_junction");
const USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE: TableDefinition<
    EntityId,
    Vec<EntityId>,
> = TableDefinition::new("user_interface_from_workspace_user_interface_junction");
// backward relationships

const WORKSPACE_FROM_ROOT_WORKSPACE_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("workspace_from_root_workspace_junction");

fn get_junction_table_definition(
    field: &WorkspaceRelationshipField,
) -> TableDefinition<EntityId, Vec<EntityId>> {
    match field {
        WorkspaceRelationshipField::Global => GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE,
        WorkspaceRelationshipField::Entities => ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE,
        WorkspaceRelationshipField::Features => FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE,
        WorkspaceRelationshipField::UserInterface => {
            USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE
        }
    }
}

pub struct WorkspaceRedbTable<'a> {
    transaction: &'a WriteTransaction,
}
impl<'a> WorkspaceRedbTable<'a> {
    pub fn new(transaction: &'a WriteTransaction) -> Self {
        WorkspaceRedbTable { transaction }
    }

    pub fn init_tables(transaction: &WriteTransaction) -> Result<(), Error> {
        transaction.open_table(WORKSPACE_TABLE)?;
        transaction.open_table(COUNTER_TABLE)?;

        transaction.open_table(GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE)?;
        transaction.open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        transaction.open_table(FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE)?;
        transaction.open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        transaction.open_table(WORKSPACE_FROM_ROOT_WORKSPACE_JUNCTION_TABLE)?;
        Ok(())
    }
}

impl<'a> WorkspaceTable for WorkspaceRedbTable<'a> {
    fn create(&mut self, entity: &Workspace) -> Result<Workspace, Error> {
        let v = self.create_multi(&[entity.clone()])?;
        Ok(v.into_iter().next().unwrap())
    }
    fn get(&self, id: &EntityId) -> Result<Option<Workspace>, Error> {
        let v = self.get_multi(&[id.clone()])?;
        Ok(v.into_iter().next().unwrap())
    }
    fn update(&mut self, entity: &Workspace) -> Result<Workspace, Error> {
        let v = self.update_multi(&[entity.clone()])?;
        Ok(v.into_iter().next().unwrap())
    }
    fn delete(&mut self, id: &EntityId) -> Result<(), Error> {
        self.delete_multi(&[id.clone()])
    }

    fn create_multi(&mut self, entities: &[Workspace]) -> Result<Vec<Workspace>, Error> {
        let mut created = Vec::new();
        let mut counter_table = self.transaction.open_table(COUNTER_TABLE)?;
        let mut counter = if let Some(counter) = counter_table.get(&"workspace".to_string())? {
            counter.value()
        } else {
            1
        };
        let mut workspace_table = self.transaction.open_table(WORKSPACE_TABLE)?;

        let mut global_junction_table = self
            .transaction
            .open_table(GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE)?;
        let mut entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        let mut features_junction_table = self
            .transaction
            .open_table(FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE)?;
        let mut user_interface_junction_table = self
            .transaction
            .open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        for entity in entities {
            let new_entity = if entity.id == EntityId::default() {
                Workspace {
                    id: counter,
                    ..entity.clone()
                }
            } else {
                if workspace_table.get(&entity.id)?.is_some() {
                    return Err(Error::TableDoesNotExist(
                        format!("UseCase id {} already in use", &entity.id).to_string(),
                    ));
                }
                entity.clone()
            };

            // one-to-one constraint check: ensure global is not already referenced by another workspace
            {
                let mut iter = global_junction_table.iter()?;
                while let Some(Ok((existing_id, right_ids))) = iter.next() {
                    let existing_id = existing_id.value();

                    if existing_id != new_entity.id
                        && right_ids.value().contains(&new_entity.global)
                    {
                        panic!("One-to-one constraint violation: Global {} is already referenced by Workspace {}", new_entity.global, existing_id);
                    }
                }
            }

            // one-to-one constraint check: ensure user_interface is not already referenced by another workspace
            {
                let mut iter = user_interface_junction_table.iter()?;
                while let Some(Ok((existing_id, right_ids))) = iter.next() {
                    let existing_id = existing_id.value();

                    if existing_id != new_entity.id
                        && right_ids.value().contains(&new_entity.user_interface)
                    {
                        panic!("One-to-one constraint violation: UserInterface {} is already referenced by Workspace {}", new_entity.user_interface, existing_id);
                    }
                }
            }

            workspace_table.insert(new_entity.id, new_entity.clone())?;

            global_junction_table
                .insert(new_entity.id, vec![new_entity.global] as Vec<EntityId>)?;
            entities_junction_table.insert(new_entity.id, new_entity.entities.clone())?;
            features_junction_table.insert(new_entity.id, new_entity.features.clone())?;
            user_interface_junction_table.insert(
                new_entity.id,
                vec![new_entity.user_interface] as Vec<EntityId>,
            )?;
            created.push(new_entity);
            if entity.id == EntityId::default() {
                counter += 1;
            }
        }
        counter_table.insert("workspace".to_string(), counter)?;
        Ok(created)
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Workspace>>, Error> {
        let mut list = Vec::new();
        let workspace_table = self.transaction.open_table(WORKSPACE_TABLE)?;

        let global_junction_table = self
            .transaction
            .open_table(GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE)?;
        let entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        let features_junction_table = self
            .transaction
            .open_table(FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE)?;
        let user_interface_junction_table = self
            .transaction
            .open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        if ids.is_empty() {
            let mut iter = workspace_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                // get global from junction table

                let fetched_global: EntityId = global_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default()
                    .pop()
                    .expect("Workspace has no global");

                entity.global = fetched_global;

                // get entities from junction table

                let fetched_entities = entities_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();

                entity.entities = fetched_entities;

                // get features from junction table

                let fetched_features = features_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();

                entity.features = fetched_features;

                // get user_interface from junction table

                let fetched_user_interface: EntityId = user_interface_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default()
                    .pop()
                    .expect("Workspace has no user_interface");

                entity.user_interface = fetched_user_interface;

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = workspace_table.get(id)? {
                    let mut entity = guard.value().clone();

                    // get global from junction table

                    let fetched_global: EntityId = global_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default()
                        .pop()
                        .expect("Workspace has no global");

                    entity.global = fetched_global;

                    // get entities from junction table

                    let fetched_entities = entities_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();

                    entity.entities = fetched_entities;

                    // get features from junction table

                    let fetched_features = features_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();

                    entity.features = fetched_features;

                    // get user_interface from junction table

                    let fetched_user_interface: EntityId = user_interface_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default()
                        .pop()
                        .expect("Workspace has no user_interface");

                    entity.user_interface = fetched_user_interface;

                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }

    fn update_multi(&mut self, entities: &[Workspace]) -> Result<Vec<Workspace>, Error> {
        let mut updated = Vec::new();
        let mut workspace_table = self.transaction.open_table(WORKSPACE_TABLE)?;

        let mut global_junction_table = self
            .transaction
            .open_table(GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE)?;
        let mut entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        let mut features_junction_table = self
            .transaction
            .open_table(FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE)?;
        let mut user_interface_junction_table = self
            .transaction
            .open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        for entity in entities {
            // one-to-one constraint check: ensure global is not already referenced by another workspace
            {
                let mut iter = global_junction_table.iter()?;
                while let Some(Ok((existing_id, right_ids))) = iter.next() {
                    let existing_id = existing_id.value();

                    if existing_id != entity.id && right_ids.value().contains(&entity.global) {
                        panic!("One-to-one constraint violation: Global {} is already referenced by Workspace {}", entity.global, existing_id);
                    }
                }
            }

            // one-to-one constraint check: ensure user_interface is not already referenced by another workspace
            {
                let mut iter = user_interface_junction_table.iter()?;
                while let Some(Ok((existing_id, right_ids))) = iter.next() {
                    let existing_id = existing_id.value();

                    if existing_id != entity.id
                        && right_ids.value().contains(&entity.user_interface)
                    {
                        panic!("One-to-one constraint violation: UserInterface {} is already referenced by Workspace {}", entity.user_interface, existing_id);
                    }
                }
            }

            workspace_table.insert(entity.id, entity)?;

            global_junction_table.insert(entity.id, vec![entity.global] as Vec<EntityId>)?;

            entities_junction_table.insert(entity.id, entity.entities.clone())?;

            features_junction_table.insert(entity.id, entity.features.clone())?;

            user_interface_junction_table
                .insert(entity.id, vec![entity.user_interface] as Vec<EntityId>)?;

            updated.push(entity.clone());
        }
        Ok(updated)
    }

    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error> {
        let mut workspace_table = self.transaction.open_table(WORKSPACE_TABLE)?;

        // forward relationships

        let mut global_junction_table = self
            .transaction
            .open_table(GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE)?;

        let mut entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;

        let mut features_junction_table = self
            .transaction
            .open_table(FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE)?;

        let mut user_interface_junction_table = self
            .transaction
            .open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        // backward relationships

        let mut backward_root_workspace_junction_table = self
            .transaction
            .open_table(WORKSPACE_FROM_ROOT_WORKSPACE_JUNCTION_TABLE)?;

        for id in ids {
            workspace_table.remove(id)?;

            global_junction_table.remove(id)?;
            entities_junction_table.remove(id)?;
            features_junction_table.remove(id)?;
            user_interface_junction_table.remove(id)?;

            db_helpers::delete_from_backward_junction_table(
                &mut backward_root_workspace_junction_table,
                id,
            )?;
        }
        Ok(())
    }

    fn get_relationship(
        &self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
    ) -> Result<Vec<EntityId>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let guard = table.get(id)?;
        Ok(guard.map(|g| g.value().clone()).unwrap_or_default())
    }

    fn get_relationships_from_right_ids(
        &self,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let mut iter = table.iter()?;
        let mut rels = vec![];
        while let Some(Ok((left_id, right_entities))) = iter.next() {
            let left_id = left_id.value();
            let right_entities = right_entities.value();
            if right_ids.iter().any(|eid| right_entities.contains(eid)) {
                rels.push((left_id, right_entities));
            }
        }
        Ok(rels)
    }

    fn set_relationship_multi(
        &mut self,
        field: &WorkspaceRelationshipField,
        relationships: Vec<(EntityId, Vec<EntityId>)>,
    ) -> Result<(), Error> {
        let mut table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        for (left_id, entities) in relationships {
            table.insert(left_id, entities)?;
        }
        Ok(())
    }

    fn set_relationship(
        &mut self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<(), Error> {
        let mut table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        table.insert(id.clone(), right_ids.to_vec())?;
        Ok(())
    }
}

pub struct WorkspaceRedbTableRO<'a> {
    transaction: &'a ReadTransaction,
}
impl<'a> WorkspaceRedbTableRO<'a> {
    pub fn new(transaction: &'a ReadTransaction) -> Self {
        WorkspaceRedbTableRO { transaction }
    }
}

impl<'a> WorkspaceTableRO for WorkspaceRedbTableRO<'a> {
    fn get(&self, id: &EntityId) -> Result<Option<Workspace>, Error> {
        let v = self.get_multi(&[id.clone()])?;
        Ok(v.into_iter().next().unwrap())
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Workspace>>, Error> {
        let mut list = Vec::new();
        let workspace_table = self.transaction.open_table(WORKSPACE_TABLE)?;

        let global_junction_table = self
            .transaction
            .open_table(GLOBAL_FROM_WORKSPACE_GLOBAL_JUNCTION_TABLE)?;
        let entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        let features_junction_table = self
            .transaction
            .open_table(FEATURE_FROM_WORKSPACE_FEATURES_JUNCTION_TABLE)?;
        let user_interface_junction_table = self
            .transaction
            .open_table(USER_INTERFACE_FROM_WORKSPACE_USER_INTERFACE_JUNCTION_TABLE)?;

        if ids.is_empty() {
            let mut iter = workspace_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                // get global from junction table

                let fetched_global: EntityId = global_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default()
                    .pop()
                    .expect("Workspace has no global");

                entity.global = fetched_global;

                // get entities from junction table

                let fetched_entities = entities_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();

                entity.entities = fetched_entities;

                // get features from junction table

                let fetched_features = features_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();

                entity.features = fetched_features;

                // get user_interface from junction table

                let fetched_user_interface: EntityId = user_interface_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default()
                    .pop()
                    .expect("Workspace has no user_interface");

                entity.user_interface = fetched_user_interface;

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = workspace_table.get(id)? {
                    let mut entity = guard.value().clone();

                    // get global from junction table

                    let fetched_global: EntityId = global_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default()
                        .pop()
                        .expect("Workspace has no global");

                    entity.global = fetched_global;

                    // get entities from junction table

                    let fetched_entities = entities_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();

                    entity.entities = fetched_entities;

                    // get features from junction table

                    let fetched_features = features_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();

                    entity.features = fetched_features;

                    // get user_interface from junction table

                    let fetched_user_interface: EntityId = user_interface_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default()
                        .pop()
                        .expect("Workspace has no user_interface");

                    entity.user_interface = fetched_user_interface;

                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }

    fn get_relationship(
        &self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
    ) -> Result<Vec<EntityId>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let guard = table.get(id)?;
        Ok(guard.map(|g| g.value().clone()).unwrap_or_default())
    }

    fn get_relationships_from_right_ids(
        &self,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let mut iter = table.iter()?;
        let mut rels = vec![];
        while let Some(Ok((left_id, right_entities))) = iter.next() {
            let left_id = left_id.value();
            let right_entities = right_entities.value();
            if right_ids.iter().any(|eid| right_entities.contains(eid)) {
                rels.push((left_id, right_entities));
            }
        }
        Ok(rels)
    }
}
