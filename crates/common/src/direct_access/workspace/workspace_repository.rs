// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use std::fmt::Display;

use crate::{
    database::transactions::Transaction,
    direct_access::repository_factory,
    entities::Workspace,
    event::{DirectAccessEntity, EntityEvent, Event, EventBuffer, Origin},
    snapshot::{EntityTreeSnapshot, TableLevelSnapshot},
    types::EntityId,
};

use crate::direct_access::root::RootRelationshipField;
use redb::Error;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum WorkspaceRelationshipField {
    Global,
    Entities,
    Features,
    UserInterface,
}

impl Display for WorkspaceRelationshipField {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub trait WorkspaceTable {
    fn create(&mut self, entity: &Workspace) -> Result<Workspace, Error>;
    fn create_multi(&mut self, entities: &[Workspace]) -> Result<Vec<Workspace>, Error>;
    fn get(&self, id: &EntityId) -> Result<Option<Workspace>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Workspace>>, Error>;
    fn update(&mut self, entity: &Workspace) -> Result<Workspace, Error>;
    fn update_multi(&mut self, entities: &[Workspace]) -> Result<Vec<Workspace>, Error>;
    fn delete(&mut self, id: &EntityId) -> Result<(), Error>;
    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error>;
    fn get_relationship(
        &self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
    ) -> Result<Vec<EntityId>, Error>;
    fn get_relationships_from_right_ids(
        &self,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error>;
    fn set_relationship_multi(
        &mut self,
        field: &WorkspaceRelationshipField,
        relationships: Vec<(EntityId, Vec<EntityId>)>,
    ) -> Result<(), Error>;
    fn set_relationship(
        &mut self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<(), Error>;
    fn snapshot_rows(&self, ids: &[EntityId]) -> Result<TableLevelSnapshot, Error>;
    fn restore_rows(&mut self, snap: &TableLevelSnapshot) -> Result<(), Error>;
}

pub trait WorkspaceTableRO {
    fn get(&self, id: &EntityId) -> Result<Option<Workspace>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Workspace>>, Error>;
    fn get_relationship(
        &self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
    ) -> Result<Vec<EntityId>, Error>;
    fn get_relationships_from_right_ids(
        &self,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error>;
}

pub struct WorkspaceRepository<'a> {
    redb_table: Box<dyn WorkspaceTable + 'a>,
    transaction: &'a Transaction,
}

impl<'a> WorkspaceRepository<'a> {
    pub fn new(redb_table: Box<dyn WorkspaceTable + 'a>, transaction: &'a Transaction) -> Self {
        WorkspaceRepository {
            redb_table,
            transaction,
        }
    }

    pub fn create(
        &mut self,
        event_buffer: &mut EventBuffer,
        entity: &Workspace,
    ) -> Result<Workspace, Error> {
        let new = self.redb_table.create(entity)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Created)),
            ids: vec![new.id],
            data: None,
        });
        Ok(new)
    }

    pub fn create_multi(
        &mut self,
        event_buffer: &mut EventBuffer,
        entities: &[Workspace],
    ) -> Result<Vec<Workspace>, Error> {
        let new_entities = self.redb_table.create_multi(entities)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Created)),
            ids: new_entities.iter().map(|e| e.id).collect(),
            data: None,
        });
        Ok(new_entities)
    }
    pub fn create_with_owner(
        &mut self,
        event_buffer: &mut EventBuffer,
        entity: &Workspace,
        owner_id: EntityId,
        index: i32,
    ) -> Result<Workspace, Error> {
        let new = self.redb_table.create(entity)?;
        let created_id = new.id;

        let mut relationship_ids = self.get_relationships_from_owner(&owner_id)?;
        if relationship_ids.is_empty() {
            relationship_ids = vec![created_id];
        } else {
            // Replace existing relationship: cascade-remove old entities first
            self.delete_multi(event_buffer, &relationship_ids)?;
            relationship_ids = vec![created_id];
        }

        self.set_relationships_in_owner(event_buffer, &owner_id, &relationship_ids)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Created)),
            ids: vec![created_id],
            data: None,
        });
        Ok(new)
    }

    pub fn create_multi_with_owner(
        &mut self,
        event_buffer: &mut EventBuffer,
        entities: &[Workspace],
        owner_id: EntityId,
        index: i32,
    ) -> Result<Vec<Workspace>, Error> {
        let new_entities = self.redb_table.create_multi(entities)?;
        let created_ids: Vec<EntityId> = new_entities.iter().map(|e| e.id).collect();

        let mut relationship_ids = self.get_relationships_from_owner(&owner_id)?;
        if relationship_ids.is_empty() {
            relationship_ids = created_ids.clone();
        } else {
            self.delete_multi(event_buffer, &relationship_ids)?;
            relationship_ids = created_ids.clone();
        }

        self.set_relationships_in_owner(event_buffer, &owner_id, &relationship_ids)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Created)),
            ids: created_ids,
            data: None,
        });
        Ok(new_entities)
    }

    pub fn get(&self, id: &EntityId) -> Result<Option<Workspace>, Error> {
        self.redb_table.get(id)
    }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Workspace>>, Error> {
        self.redb_table.get_multi(ids)
    }

    pub fn update(
        &mut self,
        event_buffer: &mut EventBuffer,
        entity: &Workspace,
    ) -> Result<Workspace, Error> {
        let updated = self.redb_table.update(entity)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Updated)),
            ids: vec![updated.id],
            data: None,
        });
        Ok(updated)
    }

    pub fn update_multi(
        &mut self,
        event_buffer: &mut EventBuffer,
        entities: &[Workspace],
    ) -> Result<Vec<Workspace>, Error> {
        let updated = self.redb_table.update_multi(entities)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Updated)),
            ids: updated.iter().map(|e| e.id).collect(),
            data: None,
        });
        Ok(updated)
    }

    pub fn delete(&mut self, event_buffer: &mut EventBuffer, id: &EntityId) -> Result<(), Error> {
        let entity = match self.redb_table.get(id)? {
            Some(e) => e,
            None => return Ok(()),
        };
        // get all strong forward relationship fields

        let global = entity.global.clone();
        let entities = entity.entities.clone();
        let features = entity.features.clone();
        let user_interface = entity.user_interface.clone();

        // delete all strong relationships, initiating a cascade delete

        repository_factory::write::create_global_repository(self.transaction)
            .delete(event_buffer, &global)?;
        repository_factory::write::create_entity_repository(self.transaction)
            .delete_multi(event_buffer, &entities)?;
        repository_factory::write::create_feature_repository(self.transaction)
            .delete_multi(event_buffer, &features)?;
        repository_factory::write::create_user_interface_repository(self.transaction)
            .delete(event_buffer, &user_interface)?;

        // delete entity
        self.redb_table.delete(id)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Removed)),
            ids: vec![*id],
            data: None,
        });
        Ok(())
    }

    pub fn delete_multi(
        &mut self,
        event_buffer: &mut EventBuffer,
        ids: &[EntityId],
    ) -> Result<(), Error> {
        let entities = self.redb_table.get_multi(ids)?;
        if entities.is_empty() || entities.iter().all(|e| e.is_none()) {
            return Ok(());
        }

        // get all strong forward relationship fields

        let global_ids: Vec<EntityId> = entities
            .iter()
            .filter_map(|entity| entity.as_ref().map(|entity| entity.global))
            .collect();
        let mut entities_ids: Vec<EntityId> = entities
            .iter()
            .flat_map(|entity| entity.as_ref().map(|entity| entity.entities.clone()))
            .flatten()
            .collect();
        // remove duplicates
        entities_ids.sort();
        entities_ids.dedup();
        let mut features_ids: Vec<EntityId> = entities
            .iter()
            .flat_map(|entity| entity.as_ref().map(|entity| entity.features.clone()))
            .flatten()
            .collect();
        // remove duplicates
        features_ids.sort();
        features_ids.dedup();
        let user_interface_ids: Vec<EntityId> = entities
            .iter()
            .filter_map(|entity| entity.as_ref().map(|entity| entity.user_interface))
            .collect();

        // delete all strong relationships, initiating a cascade delete

        repository_factory::write::create_global_repository(self.transaction)
            .delete_multi(event_buffer, &global_ids)?;
        repository_factory::write::create_entity_repository(self.transaction)
            .delete_multi(event_buffer, &entities_ids)?;
        repository_factory::write::create_feature_repository(self.transaction)
            .delete_multi(event_buffer, &features_ids)?;
        repository_factory::write::create_user_interface_repository(self.transaction)
            .delete_multi(event_buffer, &user_interface_ids)?;

        self.redb_table.delete_multi(ids)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Removed)),
            ids: ids.into(),
            data: None,
        });
        Ok(())
    }
    pub fn get_relationship(
        &self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
    ) -> Result<Vec<EntityId>, Error> {
        self.redb_table.get_relationship(id, field)
    }
    pub fn get_relationships_from_right_ids(
        &self,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        self.redb_table
            .get_relationships_from_right_ids(field, right_ids)
    }

    pub fn set_relationship_multi(
        &mut self,
        event_buffer: &mut EventBuffer,
        field: &WorkspaceRelationshipField,
        relationships: Vec<(EntityId, Vec<EntityId>)>,
    ) -> Result<(), Error> {
        // Validate that all right_ids exist
        let all_right_ids: Vec<EntityId> = relationships
            .iter()
            .flat_map(|(_, ids)| ids.iter().copied())
            .collect();
        if !all_right_ids.is_empty() {
            match field {
                WorkspaceRelationshipField::Global => {
                    let child_repo =
                        repository_factory::write::create_global_repository(self.transaction);
                    let found = child_repo.get_multi(&all_right_ids)?;
                    let missing: Vec<_> = all_right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship_multi: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
                WorkspaceRelationshipField::Entities => {
                    let child_repo =
                        repository_factory::write::create_entity_repository(self.transaction);
                    let found = child_repo.get_multi(&all_right_ids)?;
                    let missing: Vec<_> = all_right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship_multi: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
                WorkspaceRelationshipField::Features => {
                    let child_repo =
                        repository_factory::write::create_feature_repository(self.transaction);
                    let found = child_repo.get_multi(&all_right_ids)?;
                    let missing: Vec<_> = all_right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship_multi: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
                WorkspaceRelationshipField::UserInterface => {
                    let child_repo = repository_factory::write::create_user_interface_repository(
                        self.transaction,
                    );
                    let found = child_repo.get_multi(&all_right_ids)?;
                    let missing: Vec<_> = all_right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship_multi: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
            }
        }
        self.redb_table
            .set_relationship_multi(field, relationships.clone())?;
        for (left_id, right_ids) in relationships {
            event_buffer.push(Event {
                origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Updated)),
                ids: vec![left_id],
                data: Some(format!(
                    "{}:{}",
                    field,
                    right_ids
                        .iter()
                        .map(|id| id.to_string())
                        .collect::<Vec<_>>()
                        .join(",")
                )),
            });
        }
        Ok(())
    }

    pub fn set_relationship(
        &mut self,
        event_buffer: &mut EventBuffer,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<(), Error> {
        // Validate that all right_ids exist
        if !right_ids.is_empty() {
            match field {
                WorkspaceRelationshipField::Global => {
                    let child_repo =
                        repository_factory::write::create_global_repository(self.transaction);
                    let found = child_repo.get_multi(right_ids)?;
                    let missing: Vec<_> = right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
                WorkspaceRelationshipField::Entities => {
                    let child_repo =
                        repository_factory::write::create_entity_repository(self.transaction);
                    let found = child_repo.get_multi(right_ids)?;
                    let missing: Vec<_> = right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
                WorkspaceRelationshipField::Features => {
                    let child_repo =
                        repository_factory::write::create_feature_repository(self.transaction);
                    let found = child_repo.get_multi(right_ids)?;
                    let missing: Vec<_> = right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
                WorkspaceRelationshipField::UserInterface => {
                    let child_repo = repository_factory::write::create_user_interface_repository(
                        self.transaction,
                    );
                    let found = child_repo.get_multi(right_ids)?;
                    let missing: Vec<_> = right_ids
                        .iter()
                        .zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(format!(
                            "set_relationship: child entities do not exist: {:?}",
                            missing
                        )));
                    }
                }
            }
        }
        self.redb_table.set_relationship(id, field, right_ids)?;
        event_buffer.push(Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Updated)),
            ids: vec![*id],
            data: Some(format!(
                "{}:{}",
                field,
                right_ids
                    .iter()
                    .map(|id| id.to_string())
                    .collect::<Vec<_>>()
                    .join(",")
            )),
        });
        Ok(())
    }
    pub fn get_relationships_from_owner(
        &self,
        owner_id: &EntityId,
    ) -> Result<Vec<EntityId>, Error> {
        let repo = repository_factory::write::create_root_repository(self.transaction);
        repo.get_relationship(owner_id, &RootRelationshipField::Workspace)
    }

    pub fn set_relationships_in_owner(
        &mut self,
        event_buffer: &mut EventBuffer,
        owner_id: &EntityId,
        ids: &[EntityId],
    ) -> Result<(), Error> {
        let mut repo = repository_factory::write::create_root_repository(self.transaction);
        repo.set_relationship(
            event_buffer,
            owner_id,
            &RootRelationshipField::Workspace,
            ids,
        )
    }

    pub fn snapshot(&self, ids: &[EntityId]) -> Result<EntityTreeSnapshot, Error> {
        let table_data = self.redb_table.snapshot_rows(ids)?;

        // Recursively snapshot strong children
        #[allow(unused_mut)]
        let mut children = Vec::new();

        {
            // Extract child IDs from the forward junction snapshot for global
            let junction_name = "global_from_workspace_global_junction";
            let child_ids: Vec<EntityId> = table_data
                .forward_junctions
                .iter()
                .filter(|j| j.table_name == junction_name)
                .flat_map(|j| {
                    j.entries
                        .iter()
                        .flat_map(|(_, right_ids)| right_ids.iter().copied())
                })
                .collect();
            if !child_ids.is_empty() {
                let child_repo =
                    repository_factory::write::create_global_repository(self.transaction);
                children.push(child_repo.snapshot(&child_ids)?);
            }
        }
        {
            // Extract child IDs from the forward junction snapshot for entities
            let junction_name = "entity_from_workspace_entities_junction";
            let child_ids: Vec<EntityId> = table_data
                .forward_junctions
                .iter()
                .filter(|j| j.table_name == junction_name)
                .flat_map(|j| {
                    j.entries
                        .iter()
                        .flat_map(|(_, right_ids)| right_ids.iter().copied())
                })
                .collect();
            if !child_ids.is_empty() {
                let child_repo =
                    repository_factory::write::create_entity_repository(self.transaction);
                children.push(child_repo.snapshot(&child_ids)?);
            }
        }
        {
            // Extract child IDs from the forward junction snapshot for features
            let junction_name = "feature_from_workspace_features_junction";
            let child_ids: Vec<EntityId> = table_data
                .forward_junctions
                .iter()
                .filter(|j| j.table_name == junction_name)
                .flat_map(|j| {
                    j.entries
                        .iter()
                        .flat_map(|(_, right_ids)| right_ids.iter().copied())
                })
                .collect();
            if !child_ids.is_empty() {
                let child_repo =
                    repository_factory::write::create_feature_repository(self.transaction);
                children.push(child_repo.snapshot(&child_ids)?);
            }
        }
        {
            // Extract child IDs from the forward junction snapshot for user_interface
            let junction_name = "user_interface_from_workspace_user_interface_junction";
            let child_ids: Vec<EntityId> = table_data
                .forward_junctions
                .iter()
                .filter(|j| j.table_name == junction_name)
                .flat_map(|j| {
                    j.entries
                        .iter()
                        .flat_map(|(_, right_ids)| right_ids.iter().copied())
                })
                .collect();
            if !child_ids.is_empty() {
                let child_repo =
                    repository_factory::write::create_user_interface_repository(self.transaction);
                children.push(child_repo.snapshot(&child_ids)?);
            }
        }

        Ok(EntityTreeSnapshot {
            table_data,
            children,
        })
    }

    pub fn restore(
        &mut self,
        event_buffer: &mut EventBuffer,
        snap: &EntityTreeSnapshot,
    ) -> Result<(), Error> {
        // Restore children first (bottom-up)

        for child_snap in &snap.children {
            if child_snap.table_data.entity_rows.table_name == "global" {
                repository_factory::write::create_global_repository(self.transaction)
                    .restore(event_buffer, child_snap)?;
            }
        }
        for child_snap in &snap.children {
            if child_snap.table_data.entity_rows.table_name == "entity" {
                repository_factory::write::create_entity_repository(self.transaction)
                    .restore(event_buffer, child_snap)?;
            }
        }
        for child_snap in &snap.children {
            if child_snap.table_data.entity_rows.table_name == "feature" {
                repository_factory::write::create_feature_repository(self.transaction)
                    .restore(event_buffer, child_snap)?;
            }
        }
        for child_snap in &snap.children {
            if child_snap.table_data.entity_rows.table_name == "user_interface" {
                repository_factory::write::create_user_interface_repository(self.transaction)
                    .restore(event_buffer, child_snap)?;
            }
        }

        // Restore this entity's rows
        self.redb_table.restore_rows(&snap.table_data)?;

        // Emit Created events for restored entity IDs
        let restored_ids: Vec<EntityId> = snap
            .table_data
            .entity_rows
            .rows
            .iter()
            .map(|(id, _)| *id)
            .collect();
        if !restored_ids.is_empty() {
            event_buffer.push(Event {
                origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Created)),
                ids: restored_ids.clone(),
                data: None,
            });
        }
        // Emit Updated events for restored relationships
        if !restored_ids.is_empty() {
            event_buffer.push(Event {
                origin: Origin::DirectAccess(DirectAccessEntity::Workspace(EntityEvent::Updated)),
                ids: restored_ids,
                data: None,
            });
        }
        Ok(())
    }
}

pub struct WorkspaceRepositoryRO<'a> {
    redb_table: Box<dyn WorkspaceTableRO + 'a>,
}
impl<'a> WorkspaceRepositoryRO<'a> {
    pub fn new(redb_table: Box<dyn WorkspaceTableRO + 'a>) -> Self {
        WorkspaceRepositoryRO { redb_table }
    }
    pub fn get(&self, id: &EntityId) -> Result<Option<Workspace>, Error> {
        self.redb_table.get(id)
    }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Workspace>>, Error> {
        self.redb_table.get_multi(ids)
    }
    pub fn get_relationship(
        &self,
        id: &EntityId,
        field: &WorkspaceRelationshipField,
    ) -> Result<Vec<EntityId>, Error> {
        self.redb_table.get_relationship(id, field)
    }
    pub fn get_relationships_from_right_ids(
        &self,
        field: &WorkspaceRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        self.redb_table
            .get_relationships_from_right_ids(field, right_ids)
    }
}
