// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use super::entity_repository::EntityRelationshipField;
use super::entity_repository::EntityTable;
use super::entity_repository::EntityTableRO;
use crate::database::Bincode;
use crate::database::db_helpers;
use crate::entities::Entity;
use crate::snapshot::{JunctionSnapshot, TableLevelSnapshot, TableSnapshot};
use crate::types::EntityId;
use redb::{Error, ReadTransaction, ReadableTable, TableDefinition, WriteTransaction};

const ENTITY_TABLE: TableDefinition<EntityId, Bincode<Entity>> = TableDefinition::new("entity");
const COUNTER_TABLE: TableDefinition<String, EntityId> = TableDefinition::new("__counter");
// forward relationships

const ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("entity_from_entity_inherits_from_junction");
const FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("field_from_entity_fields_junction");
const RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE: TableDefinition<
    EntityId,
    Vec<EntityId>,
> = TableDefinition::new("relationship_from_entity_relationships_junction");
// backward relationships

const ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE_BACKWARD: TableDefinition<
    EntityId,
    Vec<EntityId>,
> = TableDefinition::new("entity_from_entity_inherits_from_junction");
const ENTITY_FROM_USE_CASE_ENTITIES_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("entity_from_use_case_entities_junction");
const ENTITY_FROM_FIELD_ENTITY_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("entity_from_field_entity_junction");
const ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("entity_from_workspace_entities_junction");
const ENTITY_FROM_FILE_ENTITY_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> =
    TableDefinition::new("entity_from_file_entity_junction");
const ENTITY_FROM_RELATIONSHIP_LEFT_ENTITY_JUNCTION_TABLE: TableDefinition<
    EntityId,
    Vec<EntityId>,
> = TableDefinition::new("entity_from_relationship_left_entity_junction");
const ENTITY_FROM_RELATIONSHIP_RIGHT_ENTITY_JUNCTION_TABLE: TableDefinition<
    EntityId,
    Vec<EntityId>,
> = TableDefinition::new("entity_from_relationship_right_entity_junction");
fn get_junction_table_definition(
    field: &'_ EntityRelationshipField,
) -> TableDefinition<'_, EntityId, Vec<EntityId>> {
    match field {
        EntityRelationshipField::InheritsFrom => ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE,
        EntityRelationshipField::Fields => FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE,
        EntityRelationshipField::Relationships => {
            RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE
        }
    }
}

pub struct EntityRedbTable<'a> {
    transaction: &'a WriteTransaction,
}
impl<'a> EntityRedbTable<'a> {
    pub fn new(transaction: &'a WriteTransaction) -> Self {
        EntityRedbTable { transaction }
    }

    pub fn init_tables(transaction: &WriteTransaction) -> Result<(), Error> {
        transaction.open_table(ENTITY_TABLE)?;
        transaction.open_table(COUNTER_TABLE)?;

        transaction.open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
        transaction.open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
        transaction.open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;

        transaction.open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE_BACKWARD)?;
        transaction.open_table(ENTITY_FROM_USE_CASE_ENTITIES_JUNCTION_TABLE)?;
        transaction.open_table(ENTITY_FROM_FIELD_ENTITY_JUNCTION_TABLE)?;
        transaction.open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        transaction.open_table(ENTITY_FROM_FILE_ENTITY_JUNCTION_TABLE)?;
        transaction.open_table(ENTITY_FROM_RELATIONSHIP_LEFT_ENTITY_JUNCTION_TABLE)?;
        transaction.open_table(ENTITY_FROM_RELATIONSHIP_RIGHT_ENTITY_JUNCTION_TABLE)?;
        Ok(())
    }
}

impl<'a> EntityTable for EntityRedbTable<'a> {
    fn create(&mut self, entity: &Entity) -> Result<Entity, Error> {
        let v = self.create_multi(std::slice::from_ref(entity))?;
        Ok(v.into_iter().next().unwrap())
    }
    fn get(&self, id: &EntityId) -> Result<Option<Entity>, Error> {
        let v = self.get_multi(std::slice::from_ref(id))?;
        Ok(v.into_iter().next().unwrap())
    }
    fn update(&mut self, entity: &Entity) -> Result<Entity, Error> {
        let v = self.update_multi(std::slice::from_ref(entity))?;
        Ok(v.into_iter().next().unwrap())
    }
    fn delete(&mut self, id: &EntityId) -> Result<(), Error> {
        self.delete_multi(std::slice::from_ref(id))
    }

    fn create_multi(&mut self, entities: &[Entity]) -> Result<Vec<Entity>, Error> {
        let mut created = Vec::new();
        let mut counter_table = self.transaction.open_table(COUNTER_TABLE)?;
        let mut counter = if let Some(counter) = counter_table.get(&"entity".to_string())? {
            counter.value()
        } else {
            1
        };
        let mut entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        let mut inherits_from_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
        let mut fields_junction_table = self
            .transaction
            .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
        let mut relationships_junction_table = self
            .transaction
            .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;

        for entity in entities {
            let new_entity = if entity.id == EntityId::default() {
                Entity {
                    id: counter,
                    ..entity.clone()
                }
            } else {
                if entity_table.get(&entity.id)?.is_some() {
                    return Err(Error::TableDoesNotExist(
                        format!("UseCase id {} already in use", &entity.id).to_string(),
                    ));
                }
                entity.clone()
            };

            entity_table.insert(new_entity.id, new_entity.clone())?;

            inherits_from_junction_table.insert(
                new_entity.id,
                new_entity
                    .inherits_from
                    .into_iter()
                    .collect::<Vec<EntityId>>(),
            )?;
            fields_junction_table.insert(new_entity.id, new_entity.fields.clone())?;
            relationships_junction_table.insert(new_entity.id, new_entity.relationships.clone())?;
            created.push(new_entity);
            if entity.id == EntityId::default() {
                counter += 1;
            }
        }
        counter_table.insert("entity".to_string(), counter)?;
        Ok(created)
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Entity>>, Error> {
        let mut list = Vec::new();
        let entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        let inherits_from_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
        let fields_junction_table = self
            .transaction
            .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
        let relationships_junction_table = self
            .transaction
            .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;

        if ids.is_empty() {
            let mut iter = entity_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                // get inherits_from from junction table
                let fetched_inherits_from: Option<EntityId> = inherits_from_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default()
                    .pop();
                entity.inherits_from = fetched_inherits_from;
                // get fields from junction table
                let fetched_fields = fields_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();
                entity.fields = fetched_fields;
                // get relationships from junction table
                let fetched_relationships = relationships_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();
                entity.relationships = fetched_relationships;

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = entity_table.get(id)? {
                    let mut entity = guard.value().clone();

                    // get inherits_from from junction table
                    let fetched_inherits_from: Option<EntityId> = inherits_from_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default()
                        .pop();
                    entity.inherits_from = fetched_inherits_from;
                    // get fields from junction table
                    let fetched_fields = fields_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();
                    entity.fields = fetched_fields;
                    // get relationships from junction table
                    let fetched_relationships = relationships_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();
                    entity.relationships = fetched_relationships;
                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }

    fn update_multi(&mut self, entities: &[Entity]) -> Result<Vec<Entity>, Error> {
        let mut updated = Vec::new();
        let mut entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        let mut inherits_from_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
        let mut fields_junction_table = self
            .transaction
            .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
        let mut relationships_junction_table = self
            .transaction
            .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;

        for entity in entities {
            entity_table.insert(entity.id, entity)?;

            inherits_from_junction_table.insert(
                entity.id,
                entity.inherits_from.into_iter().collect::<Vec<EntityId>>(),
            )?;
            fields_junction_table.insert(entity.id, entity.fields.clone())?;
            relationships_junction_table.insert(entity.id, entity.relationships.clone())?;
            updated.push(entity.clone());
        }
        Ok(updated)
    }

    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error> {
        let mut entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        // forward relationships

        let mut inherits_from_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
        let mut fields_junction_table = self
            .transaction
            .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
        let mut relationships_junction_table = self
            .transaction
            .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;

        // backward relationships

        let mut backward_use_case_entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_USE_CASE_ENTITIES_JUNCTION_TABLE)?;
        let mut backward_field_entity_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_FIELD_ENTITY_JUNCTION_TABLE)?;
        let mut backward_workspace_entities_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
        let mut backward_file_entity_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_FILE_ENTITY_JUNCTION_TABLE)?;
        let mut backward_relationship_left_entity_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_RELATIONSHIP_LEFT_ENTITY_JUNCTION_TABLE)?;
        let mut backward_relationship_right_entity_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_RELATIONSHIP_RIGHT_ENTITY_JUNCTION_TABLE)?;

        for id in ids {
            entity_table.remove(id)?;

            inherits_from_junction_table.remove(id)?;
            fields_junction_table.remove(id)?;
            relationships_junction_table.remove(id)?;

            // special case: backward relationship to self
            db_helpers::delete_from_backward_junction_table(&mut inherits_from_junction_table, id)?;
            db_helpers::delete_from_backward_junction_table(
                &mut backward_use_case_entities_junction_table,
                id,
            )?;
            db_helpers::delete_from_backward_junction_table(
                &mut backward_field_entity_junction_table,
                id,
            )?;
            db_helpers::delete_from_backward_junction_table(
                &mut backward_workspace_entities_junction_table,
                id,
            )?;
            db_helpers::delete_from_backward_junction_table(
                &mut backward_file_entity_junction_table,
                id,
            )?;
            db_helpers::delete_from_backward_junction_table(
                &mut backward_relationship_left_entity_junction_table,
                id,
            )?;
            db_helpers::delete_from_backward_junction_table(
                &mut backward_relationship_right_entity_junction_table,
                id,
            )?;
        }
        Ok(())
    }
    fn get_relationship(
        &self,
        id: &EntityId,
        field: &EntityRelationshipField,
    ) -> Result<Vec<EntityId>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let guard = table.get(id)?;
        Ok(guard.map(|g| g.value().clone()).unwrap_or_default())
    }

    fn get_relationships_from_right_ids(
        &self,
        field: &EntityRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let mut iter = table.iter()?;
        let mut rels = vec![];
        while let Some(Ok((left_id, right_entities))) = iter.next() {
            let left_id = left_id.value();
            let right_entities = right_entities.value();
            if right_ids.iter().any(|eid| right_entities.contains(eid)) {
                rels.push((left_id, right_entities));
            }
        }
        Ok(rels)
    }

    fn set_relationship_multi(
        &mut self,
        field: &EntityRelationshipField,
        relationships: Vec<(EntityId, Vec<EntityId>)>,
    ) -> Result<(), Error> {
        let mut table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        for (left_id, entities) in relationships {
            table.insert(left_id, entities)?;
        }
        Ok(())
    }

    fn set_relationship(
        &mut self,
        id: &EntityId,
        field: &EntityRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<(), Error> {
        let mut table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        table.insert(*id, right_ids.to_vec())?;
        Ok(())
    }

    fn snapshot_rows(&self, ids: &[EntityId]) -> Result<TableLevelSnapshot, Error> {
        let entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        // Snapshot entity rows as bincode bytes
        let mut rows = Vec::new();
        for id in ids {
            if let Some(guard) = entity_table.get(id)? {
                let entity = guard.value();
                let bytes = bincode::serialize(&entity).map_err(|e| {
                    Error::TableDoesNotExist(format!("bincode serialize error: {}", e))
                })?;
                rows.push((*id, bytes));
            }
        }

        // Snapshot forward junction tables
let mut forward_junctions = Vec::new();

        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            for id in ids {
                if let Some(guard) = junction_table.get(id)? {
                    entries.push((*id, guard.value().clone()));
                }
            }
            forward_junctions.push(JunctionSnapshot {
                table_name: "entity_from_entity_inherits_from_junction".to_string(),
                entries,
            });
        }
        {
            let junction_table = self
                .transaction
                .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            for id in ids {
                if let Some(guard) = junction_table.get(id)? {
                    entries.push((*id, guard.value().clone()));
                }
            }
            forward_junctions.push(JunctionSnapshot {
                table_name: "field_from_entity_fields_junction".to_string(),
                entries,
            });
        }
        {
            let junction_table = self
                .transaction
                .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            for id in ids {
                if let Some(guard) = junction_table.get(id)? {
                    entries.push((*id, guard.value().clone()));
                }
            }
            forward_junctions.push(JunctionSnapshot {
                table_name: "relationship_from_entity_relationships_junction".to_string(),
                entries,
            });
        }

        // Snapshot backward junction tables (entries that reference any of the given ids)
let mut backward_junctions = Vec::new();

        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE_BACKWARD)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_entity_inherits_from_junction".to_string(),
                    entries,
                });
            }
        }
        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_USE_CASE_ENTITIES_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_use_case_entities_junction".to_string(),
                    entries,
                });
            }
        }
        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_FIELD_ENTITY_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_field_entity_junction".to_string(),
                    entries,
                });
            }
        }
        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_workspace_entities_junction".to_string(),
                    entries,
                });
            }
        }
        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_FILE_ENTITY_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_file_entity_junction".to_string(),
                    entries,
                });
            }
        }
        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_RELATIONSHIP_LEFT_ENTITY_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_relationship_left_entity_junction".to_string(),
                    entries,
                });
            }
        }
        {
            let junction_table = self
                .transaction
                .open_table(ENTITY_FROM_RELATIONSHIP_RIGHT_ENTITY_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "entity_from_relationship_right_entity_junction".to_string(),
                    entries,
                });
            }
        }

        Ok(TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "entity".to_string(),
                rows,
            },
            forward_junctions,
            backward_junctions,
        })
    }

    fn restore_rows(&mut self, snap: &TableLevelSnapshot) -> Result<(), Error> {
        let mut entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        // Restore entity rows from bincode bytes (redb insert is upsert)
        for (id, bytes) in &snap.entity_rows.rows {
            let entity: Entity = bincode::deserialize(bytes).map_err(|e| {
                Error::TableDoesNotExist(format!("bincode deserialize error: {}", e))
            })?;
            entity_table.insert(*id, entity)?;
        }

        // Restore forward junction entries

        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
            for junction_snap in &snap.forward_junctions {
                if junction_snap.table_name == "entity_from_entity_inherits_from_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
            for junction_snap in &snap.forward_junctions {
                if junction_snap.table_name == "field_from_entity_fields_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;
            for junction_snap in &snap.forward_junctions {
                if junction_snap.table_name == "relationship_from_entity_relationships_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }

        // Restore backward junction entries

        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE_BACKWARD)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_entity_inherits_from_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_USE_CASE_ENTITIES_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_use_case_entities_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_FIELD_ENTITY_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_field_entity_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_WORKSPACE_ENTITIES_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_workspace_entities_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_FILE_ENTITY_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_file_entity_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_RELATIONSHIP_LEFT_ENTITY_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_relationship_left_entity_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {
            let mut junction_table = self
                .transaction
                .open_table(ENTITY_FROM_RELATIONSHIP_RIGHT_ENTITY_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "entity_from_relationship_right_entity_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }

        Ok(())
    }
}

pub struct EntityRedbTableRO<'a> {
    transaction: &'a ReadTransaction,
}
impl<'a> EntityRedbTableRO<'a> {
    pub fn new(transaction: &'a ReadTransaction) -> Self {
        EntityRedbTableRO { transaction }
    }
}

impl<'a> EntityTableRO for EntityRedbTableRO<'a> {
    fn get(&self, id: &EntityId) -> Result<Option<Entity>, Error> {
        let v = self.get_multi(std::slice::from_ref(id))?;
        Ok(v.into_iter().next().unwrap())
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<Entity>>, Error> {
        let mut list = Vec::new();
        let entity_table = self.transaction.open_table(ENTITY_TABLE)?;

        let inherits_from_junction_table = self
            .transaction
            .open_table(ENTITY_FROM_ENTITY_INHERITS_FROM_JUNCTION_TABLE)?;
        let fields_junction_table = self
            .transaction
            .open_table(FIELD_FROM_ENTITY_FIELDS_JUNCTION_TABLE)?;
        let relationships_junction_table = self
            .transaction
            .open_table(RELATIONSHIP_FROM_ENTITY_RELATIONSHIPS_JUNCTION_TABLE)?;

        if ids.is_empty() {
            let mut iter = entity_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                // get inherits_from from junction table
                let fetched_inherits_from: Option<EntityId> = inherits_from_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default()
                    .pop();
                entity.inherits_from = fetched_inherits_from;
                // get fields from junction table
                let fetched_fields = fields_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();
                entity.fields = fetched_fields;
                // get relationships from junction table
                let fetched_relationships = relationships_junction_table
                    .get(&id)?
                    .map(|g| g.value().clone())
                    .unwrap_or_default();
                entity.relationships = fetched_relationships;

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = entity_table.get(id)? {
                    let mut entity = guard.value().clone();

                    // get inherits_from from junction table
                    let fetched_inherits_from: Option<EntityId> = inherits_from_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default()
                        .pop();
                    entity.inherits_from = fetched_inherits_from;
                    // get fields from junction table
                    let fetched_fields = fields_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();
                    entity.fields = fetched_fields;
                    // get relationships from junction table
                    let fetched_relationships = relationships_junction_table
                        .get(id)?
                        .map(|g| g.value().clone())
                        .unwrap_or_default();
                    entity.relationships = fetched_relationships;
                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }
    fn get_relationship(
        &self,
        id: &EntityId,
        field: &EntityRelationshipField,
    ) -> Result<Vec<EntityId>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let guard = table.get(id)?;
        Ok(guard.map(|g| g.value().clone()).unwrap_or_default())
    }

    fn get_relationships_from_right_ids(
        &self,
        field: &EntityRelationshipField,
        right_ids: &[EntityId],
    ) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        let table = self
            .transaction
            .open_table(get_junction_table_definition(field))?;
        let mut iter = table.iter()?;
        let mut rels = vec![];
        while let Some(Ok((left_id, right_entities))) = iter.next() {
            let left_id = left_id.value();
            let right_entities = right_entities.value();
            if right_ids.iter().any(|eid| right_entities.contains(eid)) {
                rels.push((left_id, right_entities));
            }
        }
        Ok(rels)
    }
}
