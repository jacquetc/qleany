// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use crate::database::db_context::DbContext;
use anyhow::{Ok, Result};
use redb::{ReadTransaction, ReadableDatabase, WriteTransaction};

use crate::types;

enum TransactionType {
    Read(Option<Box<ReadTransaction>>),
    Write(Option<Box<WriteTransaction>>),
}

pub struct Transaction {
    transaction: TransactionType,
}

impl Transaction {
    pub fn begin_write_transaction(db_context: &DbContext) -> Result<Transaction> {
        let transaction = db_context.get_database().begin_write()?;
        Ok(Transaction {
            transaction: TransactionType::Write(Some(Box::from(transaction))),
        })
    }

    pub fn begin_read_transaction(db_context: &DbContext) -> Result<Transaction> {
        let transaction = db_context.get_database().begin_read()?;
        Ok(Transaction {
            transaction: TransactionType::Read(Some(Box::from(transaction))),
        })
    }
    pub fn commit(&mut self) -> Result<()> {
        match &mut self.transaction {
            TransactionType::Read(_) => panic!("Transaction is not a write transaction"),
            TransactionType::Write(transaction_option) => {
                transaction_option.take().unwrap().commit()
            }
        }?;
        Ok(())
    }

    pub fn rollback(&mut self) -> Result<()> {
        match &mut self.transaction {
            TransactionType::Read(_) => panic!("Transaction is not a write transaction"),
            TransactionType::Write(transaction_option) => {
                transaction_option.take().unwrap().abort()
            }
        }?;
        Ok(())
    }

    pub fn end_read_transaction(&mut self) -> Result<()> {
        match &mut self.transaction {
            TransactionType::Read(transaction_option) => {
                transaction_option.take().unwrap().close()?;
                Ok(())
            }
            TransactionType::Write(_) => panic!("Transaction is not a read transaction"),
        }
    }

    pub(crate) fn get_read_transaction(&self) -> &ReadTransaction {
        match &self.transaction {
            TransactionType::Read(Some(transaction)) => transaction,
            _ => panic!("Transaction is not a read transaction"),
        }
    }

    pub(crate) fn get_write_transaction(&self) -> &WriteTransaction {
        match &self.transaction {
            TransactionType::Write(Some(transaction)) => &transaction,
            _ => panic!("Transaction is not a write transaction"),
        }
    }

    pub fn create_savepoint(&self) -> Result<types::Savepoint> {
        let savepoint = match &self.transaction {
            TransactionType::Read(_) => panic!("Transaction is not a write transaction"),
            TransactionType::Write(transaction_option) => {
                transaction_option.as_ref().unwrap().persistent_savepoint()
            }
        };
        Ok(savepoint?)
    }
    pub fn restore_to_savepoint(&mut self, savepoint: types::Savepoint) -> Result<()> {
        match &mut self.transaction {
            TransactionType::Read(_) => panic!("Transaction is not a write transaction"),
            TransactionType::Write(transaction_option) => {
                if let Some(mut transaction) = transaction_option.take() {
                    let redb_savepoint = transaction.get_persistent_savepoint(savepoint)?;
                    transaction.restore_savepoint(&redb_savepoint)?;
                    *transaction_option = Some(transaction);
                    Ok(())
                } else {
                    panic!("Transaction is not available")
                }
            }
        }
    }
}
