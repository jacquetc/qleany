// Auto-generated by qleany. Do not edit by hand.

use serde::Serialize;
use crate::types::EntityId;
use flume::{Receiver, Sender, unbounded};
use std::{
    sync::{Arc, Mutex, atomic::AtomicBool},
    thread,
};

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum EntityEvent {
    Created,
    Updated,
    Removed,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum AllEvent {
    Reset,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum UndoRedoEvent {
    Undone,
    Redone,
    BeginComposite,
    EndComposite,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum LongOperationEvent {
    Started,
    Progress,
    Cancelled,
    Completed,
    Failed,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum DirectAccessEntity {
    All(AllEvent),
    {% for eid, ent in s.entities %}
    {{ ent.pascal_name }}(EntityEvent),
    {% endfor %}
}


{% for fid, feat in s.features %}
#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum {{ feat.pascal_name }}Event {
    {% for uid, use_case in feat.use_cases %}
    {{ use_case.pascal_name }},
    {% endfor %}
}
{% endfor %}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub enum Origin {
    DirectAccess(DirectAccessEntity),
    UndoRedo(UndoRedoEvent),
    LongOperation(LongOperationEvent),
    {% for fid, feat in s.features %}
    {{ feat.pascal_name }}({{ feat.pascal_name }}Event),
    {% endfor %}
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize)]
pub struct Event {
    pub origin: Origin,
    pub ids: Vec<EntityId>,
    pub data: Option<String>,
}

impl Event {
    pub fn origin_string(&self) -> String {
        match &self.origin {
            Origin::DirectAccess(entity) => match entity {
                DirectAccessEntity::All(event) => format!("direct_access_all_{:?}", event),
                // entities
                {% for eid, ent in s.entities %}
                DirectAccessEntity::{{ ent.pascal_name }}(event) => format!("direct_access_{{ ent.snake_name }}_{:?}", event),
                {% endfor %}
            },
            Origin::UndoRedo(event) => format!("undo_redo_{:?}", event),
            Origin::LongOperation(event) => format!("long_operation_{:?}", event),
            // features
            {% for fid, feat in s.features %}
            Origin::{{ feat.pascal_name }}(event) => format!("{{ feat.snake_name }}_{:?}", event),
            {% endfor %}
        }
        .to_lowercase()
    }
}
pub type Queue = Arc<Mutex<Vec<Event>>>;

/// Central event hub for managing subscriptions and dispatching events
pub struct EventHub {
    sender: Sender<Event>,
    receiver: Receiver<Event>,
    queue: Queue,
}

impl EventHub {
    /// Create a new event hub
    pub fn new() -> Self {
        let (sender, receiver) = unbounded();
        EventHub {
            sender,
            receiver,
            queue: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// Start the event processing loop
    pub fn start_event_loop(&self, stop_signal: Arc<AtomicBool>) {
        let receiver = self.receiver.clone();
        let queue = self.queue.clone();
        thread::spawn(move || {
            loop {
                if stop_signal.load(std::sync::atomic::Ordering::Relaxed) {
                    break;
                }

                let event = receiver.recv().unwrap();
                let mut queue = queue.lock().unwrap();
                queue.push(event.clone());
            }
        });
    }

    /// Send an event to the queue
    pub fn send_event(&self, event: Event) {
        self.sender.send(event).unwrap();
    }

    pub fn get_queue(&self) -> Queue {
        self.queue.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_origin_string_direct_access_all() {
        let event = Event {
            origin: Origin::DirectAccess(DirectAccessEntity::All(AllEvent::Reset)),
            ids: vec![EntityId::default()],
            data: None,
        };
        assert_eq!(event.origin_string(), "direct_access_all_reset");
    }

    #[test]
    fn test_origin_string_direct_access_root() {
        let event = Event {
            origin: Origin::DirectAccess(DirectAccessEntity::Root(EntityEvent::Created)),
            ids: vec![EntityId::default()],
            data: None,
        };
        assert_eq!(event.origin_string(), "direct_access_root_created");
    }

    #[test]
    fn test_origin_string_handling_manifest() {
        let event = Event {
            origin: Origin::HandlingManifest(HandlingManifestEvent::Loaded),
            ids: vec![EntityId::default()],
            data: None,
        };
        assert_eq!(event.origin_string(), "handling_manifest_loaded");
    }

    #[test]
    fn test_event_hub_send_and_receive() {
        let event_hub = EventHub::new();
        let stop_signal = Arc::new(AtomicBool::new(false));
        event_hub.start_event_loop(stop_signal.clone());

        let event = Event {
            origin: Origin::HandlingManifest(HandlingManifestEvent::Loaded),
            ids: vec![EntityId::default()],
            data: Some("test_data".to_string()),
        };

        event_hub.send_event(event.clone());

        thread::sleep(std::time::Duration::from_millis(100));

        let queue = event_hub.get_queue();
        let queue = queue.lock().unwrap();
        assert_eq!(queue.len(), 1);
        assert_eq!(queue[0], event);

        stop_signal.store(true, std::sync::atomic::Ordering::Relaxed);
    }
}
