// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

{% set e = s.file.inner.entity %}
{% if e %}
use std::fmt::Display;

use crate::{
    database::transactions::Transaction,
    direct_access::repository_factory,
    entities::{{ s.entities[e].pascal_name }},
    event::{DirectAccessEntity, EntityEvent, Event, EventBuffer, Origin},
    snapshot::{EntityTreeSnapshot, TableLevelSnapshot},
    types::EntityId,
};

use redb::Error;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum {{ s.entities[e].pascal_name }}RelationshipField {
    {% for rid, r in s.entities[e].forward_relationships %}
    {{ r.field_pascal_name }},
    {%- endfor %}
}

impl Display for {{ s.entities[e].pascal_name }}RelationshipField {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub trait {{ s.entities[e].pascal_name }}Table {
    fn create(&mut self, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error>;
    fn create_multi(&mut self, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error>;
    fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error>;
    fn update(&mut self, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error>;
    fn update_multi(&mut self, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error>;
    fn delete(&mut self, id: &EntityId) -> Result<(), Error>;
    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error>;
{% if s.entities[e].forward_relationships %}
    fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error>;
    fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error>;
    fn set_relationship_multi(&mut self, field: &{{ s.entities[e].pascal_name }}RelationshipField, relationships: Vec<(EntityId, Vec<EntityId>)>) -> Result<(), Error>;
    fn set_relationship(&mut self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<(), Error>;
{% endif %}
    fn snapshot_rows(&self, ids: &[EntityId]) -> Result<TableLevelSnapshot, Error>;
    fn restore_rows(&mut self, snap: &TableLevelSnapshot) -> Result<(), Error>;
}

pub trait {{ s.entities[e].pascal_name }}TableRO {
    fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error>;
{% if s.entities[e].forward_relationships %}
    fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error>;
    fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error>;
{%- endif %}
}

pub struct {{ s.entities[e].pascal_name }}Repository<'a> {
    redb_table: Box<dyn {{ s.entities[e].pascal_name }}Table + 'a>,
    transaction: &'a Transaction,
}

impl<'a> {{ s.entities[e].pascal_name }}Repository<'a> {
    pub fn new(redb_table: Box<dyn {{ s.entities[e].pascal_name }}Table + 'a>, transaction: &'a Transaction) -> Self {
        {{ s.entities[e].pascal_name }}Repository { redb_table, transaction }
    }

    pub fn create(&mut self, event_buffer: &mut EventBuffer, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error> {
        let new = self.redb_table.create(entity)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Created)), ids: vec![new.id], data: None });
        Ok(new)
    }

    pub fn create_multi(&mut self, event_buffer: &mut EventBuffer, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error> {
        let new_entities = self.redb_table.create_multi(entities)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Created)), ids: new_entities.iter().map(|e| e.id).collect(), data: None });
        Ok(new_entities)
    }

    pub fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error> { self.redb_table.get(id) }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error> { self.redb_table.get_multi(ids) }

    pub fn update(&mut self, event_buffer: &mut EventBuffer, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error> {
        let updated = self.redb_table.update(entity)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: vec![updated.id], data: None });
        Ok(updated)
    }

    pub fn update_multi(&mut self, event_buffer: &mut EventBuffer, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error> {
        let updated = self.redb_table.update_multi(entities)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: updated.iter().map(|e| e.id).collect(), data: None });
        Ok(updated)
    }

    pub fn delete(&mut self, event_buffer: &mut EventBuffer, id: &EntityId) -> Result<(), Error> {
        let entity = match self.redb_table.get(id)? { Some(e) => e, None => return Ok(()), };
        // get all strong forward relationship fields
        {% for f in s.entities[e].fields %}
        {%- if f.inner.field_type == "Entity" and f.inner.strong %}
        let {{ f.snake_name }} = entity.{{ f.snake_name }}.clone();
        {%- endif %}
        {%- endfor %}

        // delete all strong relationships, initiating a cascade delete
        {% for f in s.entities[e].fields %}
        {%- if f.inner.field_type == "Entity" and f.inner.strong %}
        {%- if f.inner.relationship == "OneToOne" %}
            {% if f.optional %}
        if let Some({{ f.snake_name }}_id) = {{ f.snake_name }} {
            repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
                .delete(event_buffer, &{{ f.snake_name }}_id)?;
            }
            {%- else %}
        repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
            .delete(event_buffer, &{{ f.snake_name }})?;
            {%- endif %}
        {%- else %}
        repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
            .delete_multi(event_buffer, &{{ f.snake_name }})?;
        {%- endif %}
        {%- endif %}
        {%- endfor %}

        // delete entity
        self.redb_table.delete(id)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Removed)), ids: vec![*id], data: None });
        Ok(())
    }

    pub fn delete_multi(&mut self, event_buffer: &mut EventBuffer, ids: &[EntityId]) -> Result<(), Error> {
        let entities = self.redb_table.get_multi(ids)?;
        if entities.is_empty() || entities.iter().all(|e| e.is_none()) { return Ok(()); }

        // get all strong forward relationship fields
        {% for f in s.entities[e].fields %}
        {% if f.inner.field_type == "Entity" and f.inner.strong %}
        {% if f.inner.relationship == "OneToOne" %}
            {% if f.optional %}
        let {{ f.snake_name }}_ids: Vec<EntityId> = entities
            .iter()
            .filter_map(|entity| entity.as_ref().and_then(|entity| entity.{{ f.snake_name }}.clone()))
            .collect();
            {% else %}
        let {{ f.snake_name }}_ids: Vec<EntityId> = entities
            .iter()
            .filter_map(|entity| entity.as_ref().map(|entity| entity.{{ f.snake_name }}))
            .collect();
            {%- endif %}
        {% else %}
        let mut {{ f.snake_name }}_ids: Vec<EntityId> = entities
            .iter()
            .flat_map(|entity| entity.as_ref().map(|entity| entity.{{ f.snake_name }}.clone()))
            .flatten()
            .collect();
        // remove duplicates
        {{ f.snake_name }}_ids.sort();
        {{ f.snake_name }}_ids.dedup();
        {%- endif %}
        {%- endif %}
        {%- endfor %}

        // delete all strong relationships, initiating a cascade delete
        {% for f in s.entities[e].fields %}
        {% if f.inner.field_type == "Entity" and f.inner.strong %}
        repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
            .delete_multi(event_buffer, &{{ f.snake_name }}_ids)?;
        {%- endif %}
        {%- endfor %}

        self.redb_table.delete_multi(ids)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Removed)), ids: ids.into(), data: None });
        Ok(())
    }

{% if s.entities[e].forward_relationships %}
    pub fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error> { self.redb_table.get_relationship(id, field) }
    pub fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> { self.redb_table.get_relationships_from_right_ids(field, right_ids) }

    pub fn set_relationship_multi(&mut self, event_buffer: &mut EventBuffer, field: &{{ s.entities[e].pascal_name }}RelationshipField, relationships: Vec<(EntityId, Vec<EntityId>)>) -> Result<(), Error> {
        // Validate that all right_ids exist
        let all_right_ids: Vec<EntityId> = relationships.iter().flat_map(|(_, ids)| ids.iter().copied()).collect();
        if !all_right_ids.is_empty() {
            match field {
                {% for rid, r in s.entities[e].forward_relationships %}
                {{ s.entities[e].pascal_name }}RelationshipField::{{ r.field_pascal_name }} => {
                    let child_repo = repository_factory::write::create_{{ s.entities[r.inner.right_entity].snake_name }}_repository(self.transaction);
                    let found = child_repo.get_multi(&all_right_ids)?;
                    let missing: Vec<_> = all_right_ids.iter().zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(
                            format!("set_relationship_multi: child entities do not exist: {:?}", missing)
                        ));
                    }
                }
                {%- endfor %}
            }
        }
        self.redb_table.set_relationship_multi(field, relationships.clone())?;
        for (left_id, right_ids) in relationships {
            event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: vec![left_id], data: Some(format!("{}:{}", field, right_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(","))) });
        }
        Ok(())
    }

    pub fn set_relationship(&mut self, event_buffer: &mut EventBuffer, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<(), Error> {
        // Validate that all right_ids exist
        if !right_ids.is_empty() {
            match field {
                {% for rid, r in s.entities[e].forward_relationships %}
                {{ s.entities[e].pascal_name }}RelationshipField::{{ r.field_pascal_name }} => {
                    let child_repo = repository_factory::write::create_{{ s.entities[r.inner.right_entity].snake_name }}_repository(self.transaction);
                    let found = child_repo.get_multi(right_ids)?;
                    let missing: Vec<_> = right_ids.iter().zip(found.iter())
                        .filter(|(_, entity)| entity.is_none())
                        .map(|(id, _)| *id)
                        .collect();
                    if !missing.is_empty() {
                        return Err(Error::TableDoesNotExist(
                            format!("set_relationship: child entities do not exist: {:?}", missing)
                        ));
                    }
                }
                {%- endfor %}
            }
        }
        self.redb_table.set_relationship(id, field, right_ids)?;
        event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: vec![*id], data: Some(format!("{}:{}", field, right_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(","))) });
        Ok(())
    }
{% endif %}

    pub fn snapshot(&self, ids: &[EntityId]) -> Result<EntityTreeSnapshot, Error> {
        let table_data = self.redb_table.snapshot_rows(ids)?;

        // Recursively snapshot strong children
        #[allow(unused_mut)]
        let mut children = Vec::new();
        {% for f in s.entities[e].fields %}
        {%- if f.inner.field_type == "Entity" and f.inner.strong %}
        {
            // Extract child IDs from the forward junction snapshot for {{ f.snake_name }}
            let junction_name = "{{ s.entities[f.inner.entity].snake_name }}_from_{{ s.entities[e].snake_name }}_{{ f.snake_name }}_junction";
            let child_ids: Vec<EntityId> = table_data.forward_junctions.iter()
                .filter(|j| j.table_name == junction_name)
                .flat_map(|j| j.entries.iter().flat_map(|(_, right_ids)| right_ids.iter().copied()))
                .collect();
            if !child_ids.is_empty() {
                let child_repo = repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction);
                children.push(child_repo.snapshot(&child_ids)?);
            }
        }
        {%- endif %}
        {%- endfor %}

        Ok(EntityTreeSnapshot { table_data, children })
    }

    pub fn restore(&mut self, event_buffer: &mut EventBuffer, snap: &EntityTreeSnapshot) -> Result<(), Error> {
        // Restore children first (bottom-up)
        {% for f in s.entities[e].fields %}
        {%- if f.inner.field_type == "Entity" and f.inner.strong %}
        for child_snap in &snap.children {
            if child_snap.table_data.entity_rows.table_name == "{{ s.entities[f.inner.entity].snake_name }}" {
                repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
                    .restore(event_buffer, child_snap)?;
            }
        }
        {%- endif %}
        {%- endfor %}

        // Restore this entity's rows
        self.redb_table.restore_rows(&snap.table_data)?;

        // Emit Created events for restored entity IDs
        let restored_ids: Vec<EntityId> = snap.table_data.entity_rows.rows.iter().map(|(id, _)| *id).collect();
        if !restored_ids.is_empty() {
            event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Created)), ids: restored_ids.clone(), data: None });
        }
{% if s.entities[e].forward_relationships %}
        // Emit Updated events for restored relationships
        if !restored_ids.is_empty() {
            event_buffer.push(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: restored_ids, data: None });
        }
{% endif %}
        Ok(())
    }
}

pub struct {{ s.entities[e].pascal_name }}RepositoryRO<'a> { redb_table: Box<dyn {{ s.entities[e].pascal_name }}TableRO + 'a>, }
impl<'a> {{ s.entities[e].pascal_name }}RepositoryRO<'a> {
    pub fn new(redb_table: Box<dyn {{ s.entities[e].pascal_name }}TableRO + 'a>) -> Self { {{ s.entities[e].pascal_name }}RepositoryRO { redb_table } }
    pub fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error> { self.redb_table.get(id) }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error> { self.redb_table.get_multi(ids) }
{% if s.entities[e].forward_relationships %}
    pub fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error> { self.redb_table.get_relationship(id, field) }
    pub fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> { self.redb_table.get_relationships_from_right_ids(field, right_ids) }
{% endif %}
}
{% else %}
// No entity bound to this file
{% endif %}
