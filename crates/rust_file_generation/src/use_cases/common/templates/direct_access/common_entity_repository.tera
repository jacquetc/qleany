// Auto-generated by qleany. Do not edit by hand.

{% set e = s.file.inner.entity %}
{% if e %}
use std::fmt::Display;
use std::sync::Arc;

use crate::{
    database::transactions::Transaction,
    direct_access::repository_factory,
    entities::{{ s.entities[e].pascal_name }},
    event::{DirectAccessEntity, EntityEvent, Event, EventHub, Origin},
    types::EntityId,
};

use redb::Error;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum {{ s.entities[e].pascal_name }}RelationshipField {
    {% for rid, r in s.entities[e].forward_relationships %}
    {{ r.field_name | capitalize }},
    {%- endfor %}
}

impl Display for {{ s.entities[e].pascal_name }}RelationshipField {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub trait {{ s.entities[e].pascal_name }}Table {
    fn create(&mut self, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error>;
    fn create_multi(&mut self, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error>;
    fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error>;
    fn update(&mut self, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error>;
    fn update_multi(&mut self, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error>;
    fn delete(&mut self, id: &EntityId) -> Result<(), Error>;
    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error>;
{% if s.entities[e].forward_relationships %}
    fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error>;
    fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error>;
    fn set_relationship_multi(&mut self, field: &{{ s.entities[e].pascal_name }}RelationshipField, relationships: Vec<(EntityId, Vec<EntityId>)>) -> Result<(), Error>;
    fn set_relationship(&mut self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<(), Error>;
{% endif %}
}

pub trait {{ s.entities[e].pascal_name }}TableRO {
    fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error>;
    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error>;
{% if s.entities[e].forward_relationships %}
    fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error>;
    fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error>;
{%- endif %}
}

pub struct {{ s.entities[e].pascal_name }}Repository<'a> {
    redb_table: Box<dyn {{ s.entities[e].pascal_name }}Table + 'a>,
    transaction: &'a Transaction,
}

impl<'a> {{ s.entities[e].pascal_name }}Repository<'a> {
    pub fn new(redb_table: Box<dyn {{ s.entities[e].pascal_name }}Table + 'a>, transaction: &'a Transaction) -> Self {
        {{ s.entities[e].pascal_name }}Repository { redb_table, transaction }
    }

    pub fn create(&mut self, event_hub: &Arc<EventHub>, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error> {
        let new = self.redb_table.create(entity)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Created)), ids: vec![new.id.clone()], data: None });
        Ok(new)
    }

    pub fn create_multi(&mut self, event_hub: &Arc<EventHub>, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error> {
        let new_entities = self.redb_table.create_multi(entities)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Created)), ids: new_entities.iter().map(|e| e.id.clone()).collect(), data: None });
        Ok(new_entities)
    }

    pub fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error> { self.redb_table.get(id) }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error> { self.redb_table.get_multi(ids) }

    pub fn update(&mut self, event_hub: &Arc<EventHub>, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error> {
        let updated = self.redb_table.update(entity)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: vec![updated.id.clone()], data: None });
        Ok(updated)
    }

    pub fn update_multi(&mut self, event_hub: &Arc<EventHub>, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error> {
        let updated = self.redb_table.update_multi(entities)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: updated.iter().map(|e| e.id.clone()).collect(), data: None });
        Ok(updated)
    }

    pub fn delete(&mut self, event_hub: &Arc<EventHub>, id: &EntityId) -> Result<(), Error> {
        let entity = match self.redb_table.get(id)? { Some(e) => e, None => return Ok(()), };
        // get all strong forward relationship fields
        {% for f in s.entities[e].fields %}
        {% if f.inner.field_type == "Entity" and f.inner.strong %}
        let {{ f.snake_name }} = entity.{{ f.snake_name }}.clone();
        {%- endif %}
        {%- endfor %}

        // delete all strong relationships, initiating a cascade delete
        {% for f in s.entities[e].fields %}
        {% if f.inner.field_type == "Entity" and f.inner.strong %}
        {% if f.inner.relationship == "OneToOne" or f.inner.relationship == "ManyToOne" %}
            {% if f.required %}
        repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
            .delete(event_hub, &{{ f.snake_name }})?;
            {%- else %}
        if let Some({{ f.snake_name }}_id) = {{ f.snake_name }} {
            repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
                .delete(event_hub, &{{ f.snake_name }}_id)?;
            }
            {%- endif %}
        {% else %}
        repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
            .delete_multi(event_hub, &{{ f.snake_name }})?;
        {%- endif %}
        {%- endif %}
        {%- endfor %}

        // delete entity
        self.redb_table.delete(id)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Removed)), ids: vec![id.clone()], data: None });
        Ok(())
    }

    pub fn delete_multi(&mut self, event_hub: &Arc<EventHub>, ids: &[EntityId]) -> Result<(), Error> {
        let entities = self.redb_table.get_multi(ids)?;
        if entities.is_empty() || entities.iter().all(|e| e.is_none()) { return Ok(()); }

        // get all strong forward relationship fields
        {% for f in s.entities[e].fields %}
        {% if f.inner.field_type == "Entity" and f.inner.strong %}
        {% if f.inner.relationship == "OneToOne" or f.inner.relationship == "ManyToOne" %}
            {% if f.required %}
        let {{ f.snake_name }}_ids: Vec<EntityId> = entities
            .iter()
            .filter_map(|entity| entity.as_ref().map(|entity| entity.{{ f.snake_name }}.clone()))
            .collect();
            {% else %}
        let {{ f.snake_name }}_ids: Vec<EntityId> = entities
            .iter()
            .filter_map(|entity| entity.as_ref().and_then(|entity| entity.{{ f.snake_name }}.clone()))
            .collect();
            {%- endif %}
        {% else %}
        let mut {{ f.snake_name }}_ids: Vec<EntityId> = entities
            .iter()
            .flat_map(|entity| entity.as_ref().map(|entity| entity.{{ f.snake_name }}.clone()))
            .flatten()
            .collect();
        // remove duplicates
        {{ f.snake_name }}_ids.sort();
        {{ f.snake_name }}_ids.dedup();
        {%- endif %}
        {%- endif %}
        {%- endfor %}

        // delete all strong relationships, initiating a cascade delete
        {% for f in s.entities[e].fields %}
        {% if f.inner.field_type == "Entity" and f.inner.strong %}
        repository_factory::write::create_{{ s.entities[f.inner.entity].snake_name }}_repository(self.transaction)
            .delete_multi(event_hub, &{{ f.snake_name }}_ids)?;
        {%- endif %}
        {%- endfor %}

        self.redb_table.delete_multi(ids)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Removed)), ids: ids.into(), data: None });
        Ok(())
    }

{% if s.entities[e].forward_relationships %}
    pub fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error> { self.redb_table.get_relationship(id, field) }
    pub fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> { self.redb_table.get_relationships_from_right_ids(field, right_ids) }

    pub fn set_relationship_multi(&mut self, event_hub: &Arc<EventHub>, field: &{{ s.entities[e].pascal_name }}RelationshipField, relationships: Vec<(EntityId, Vec<EntityId>)>) -> Result<(), Error> {
        self.redb_table.set_relationship_multi(field, relationships.clone())?;
        for (left_id, right_ids) in relationships {
            event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: vec![left_id], data: Some(format!("{}:{}", field, right_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(","))) });
        }
        Ok(())
    }

    pub fn set_relationship(&mut self, event_hub: &Arc<EventHub>, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<(), Error> {
        self.redb_table.set_relationship(id, field, right_ids)?;
        event_hub.send_event(Event { origin: Origin::DirectAccess(DirectAccessEntity::{{ s.entities[e].pascal_name }}(EntityEvent::Updated)), ids: vec![id.clone()], data: Some(format!("{}:{}", field, right_ids.iter().map(|id| id.to_string()).collect::<Vec<_>>().join(","))) });
        Ok(())
    }
{% endif %}
}

pub struct {{ s.entities[e].pascal_name }}RepositoryRO<'a> { redb_table: Box<dyn {{ s.entities[e].pascal_name }}TableRO + 'a>, }
impl<'a> {{ s.entities[e].pascal_name }}RepositoryRO<'a> {
    pub fn new(redb_table: Box<dyn {{ s.entities[e].pascal_name }}TableRO + 'a>) -> Self { {{ s.entities[e].pascal_name }}RepositoryRO { redb_table } }
    pub fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error> { self.redb_table.get(id) }
    pub fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error> { self.redb_table.get_multi(ids) }
{% if s.entities[e].forward_relationships %}
    pub fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error> { self.redb_table.get_relationship(id, field) }
    pub fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> { self.redb_table.get_relationships_from_right_ids(field, right_ids) }
{% endif %}
}
{% else %}
// No entity bound to this file
{% endif %}
