// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

{% set e = s.file.inner.entity %}
{% if e %}
use super::{{ s.entities[e].snake_name }}_repository::{{ s.entities[e].pascal_name }}RelationshipField;
use super::{{ s.entities[e].snake_name }}_repository::{{ s.entities[e].pascal_name }}Table;
use super::{{ s.entities[e].snake_name }}_repository::{{ s.entities[e].pascal_name }}TableRO;
use crate::database::db_helpers;
use crate::database::Bincode;
use crate::entities::{{ s.entities[e].pascal_name }};
use crate::snapshot::{JunctionSnapshot, TableLevelSnapshot, TableSnapshot};
use crate::types::EntityId;
use redb::{Error, ReadTransaction, ReadableTable, TableDefinition, WriteTransaction};

const {{ s.entities[e].snake_name | upper }}_TABLE: TableDefinition<EntityId, Bincode<{{ s.entities[e].pascal_name }}>> = TableDefinition::new("{{ s.entities[e].snake_name }}");
const COUNTER_TABLE: TableDefinition<String, EntityId> = TableDefinition::new("__counter");
// forward relationships
{% for rid, r in s.entities[e].forward_relationships %}
const {{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> = TableDefinition::new("{{ s.entities[r.inner.right_entity].snake_name }}_from_{{ s.entities[e].snake_name }}_{{ r.field_snake_name }}_junction");
{%- endfor %}
// backward relationships
{% for rid, r in s.entities[e].backward_relationships %}
{%- if r.inner.left_entity == e %}
const {{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE_BACKWARD: TableDefinition<EntityId, Vec<EntityId>> = TableDefinition::new("{{ s.entities[e].snake_name }}_from_{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_junction");
{%- else %}
const {{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE: TableDefinition<EntityId, Vec<EntityId>> = TableDefinition::new("{{ s.entities[e].snake_name }}_from_{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_junction");
{%- endif %}
{%- endfor %}

{% if s.entities[e].forward_relationships | length > 0 %}
fn get_junction_table_definition(
    field: &'_ {{ s.entities[e].pascal_name }}RelationshipField,
) -> TableDefinition<'_, EntityId, Vec<EntityId>> {
    match field {
        {% for rid, r in s.entities[e].forward_relationships %}
        {{ s.entities[e].pascal_name }}RelationshipField::{{ r.field_pascal_name }} => {{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE,
        {%- endfor %}
    }
}
{% endif %}

pub struct {{ s.entities[e].pascal_name }}RedbTable<'a> { transaction: &'a WriteTransaction }
impl<'a> {{ s.entities[e].pascal_name }}RedbTable<'a> {
    pub fn new(transaction: &'a WriteTransaction) -> Self { {{ s.entities[e].pascal_name }}RedbTable { transaction } }

    pub fn init_tables(transaction: &WriteTransaction) -> Result<(), Error> {
        transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;
        transaction.open_table(COUNTER_TABLE)?;
        {% for rid, r in s.entities[e].forward_relationships %}
        transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
        {%- endfor %}
        {% for rid, r in s.entities[e].backward_relationships %}
        {%- if r.inner.left_entity == e %}
        transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE_BACKWARD)?;
        {%- else %}
        transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
        {%- endif %}
        {%- endfor %}
        Ok(())
    }
}

impl<'a> {{ s.entities[e].pascal_name }}Table for {{ s.entities[e].pascal_name }}RedbTable<'a> {
    fn create(&mut self, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error> { let v = self.create_multi(std::slice::from_ref(entity))?; Ok(v.into_iter().next().unwrap()) }
    fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error> { let v = self.get_multi(std::slice::from_ref(id))?; Ok(v.into_iter().next().unwrap()) }
    fn update(&mut self, entity: &{{ s.entities[e].pascal_name }}) -> Result<{{ s.entities[e].pascal_name }}, Error> { let v = self.update_multi(std::slice::from_ref(entity))?; Ok(v.into_iter().next().unwrap()) }
    fn delete(&mut self, id: &EntityId) -> Result<(), Error> { self.delete_multi(std::slice::from_ref(id)) }

    fn create_multi(&mut self, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error> {
        let mut created = Vec::new();
        let mut counter_table = self.transaction.open_table(COUNTER_TABLE)?;
        let mut counter = if let Some(counter) = counter_table.get(&"{{ s.entities[e].snake_name }}".to_string())? { counter.value() } else { 1 };
        let mut {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;
        {% for rid, r in s.entities[e].forward_relationships %}
        let mut {{ r.field_snake_name }}_junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
        {%- endfor %}

        for entity in entities {
            let new_entity = if entity.id == EntityId::default() {
            {{ s.entities[e].pascal_name }} { id: counter, ..entity.clone() }
            }
            else {
                if {{ s.entities[e].snake_name }}_table.get(&entity.id)?.is_some() {
                return Err(Error::TableDoesNotExist(format!("UseCase id {} already in use", &entity.id).to_string(), ));
                }
            entity.clone()
            };
            {% if s.entities[e].snake_name == "dto" %}{{ s.entities[e].pascal_name }} { id: counter, ..entity.clone() };{% endif %}
            {% for f in s.entities[e].fields %}
            {% if f.inner.field_type == "Entity" and f.relationship == "OneToOne" %}
            // one-to-one constraint check: ensure {{ f.snake_name }} is not already referenced by another {{ s.entities[e].snake_name }}
            {
                let mut iter = {{ f.snake_name }}_junction_table.iter()?;
                while let Some(Ok((existing_id, right_ids))) = iter.next() {
                    let existing_id = existing_id.value();
                    {% if f.optional %}
                    if let Some(ref right_id) = new_entity.{{ f.snake_name }}
                        && existing_id != new_entity.id && right_ids.value().contains(right_id) {
                            panic!("One-to-one constraint violation: {{ s.entities[f.inner.entity].pascal_name }} {} is already referenced by {{ s.entities[e].pascal_name }} {}", right_id, existing_id);

                    }
                    {% else %}
                    if existing_id != new_entity.id && right_ids.value().contains(&new_entity.{{ f.snake_name }}) {
                        panic!("One-to-one constraint violation: {{ s.entities[f.inner.entity].pascal_name }} {} is already referenced by {{ s.entities[e].pascal_name }} {}", new_entity.{{ f.snake_name }}, existing_id);
                    }
                    {% endif %}
                }
            }
            {% endif %}
            {% endfor %}
            {{ s.entities[e].snake_name }}_table.insert(new_entity.id, new_entity.clone())?;
            {% for rid, r in s.entities[e].forward_relationships %}
            {{ r.field_snake_name }}_junction_table.insert(new_entity.id,
                {% if r.inner.cardinality == "ZeroOrMore" or r.inner.cardinality == "OneOrMore" %}
                new_entity.{{ r.field_snake_name }}.clone())?;
                {%- elif r.inner.cardinality == "One" %}
                vec![new_entity.{{ r.field_snake_name }}] as Vec<EntityId>)?;
                {%- elif r.inner.cardinality == "ZeroOrOne" %}
                new_entity.{{ r.field_snake_name }}.into_iter().collect::<Vec<EntityId>>())?;
                {%- endif %}

            {%- endfor %}
            created.push(new_entity);
            if entity.id == EntityId::default() { counter += 1; }
        }
        counter_table.insert("{{ s.entities[e].snake_name }}".to_string(), counter)?;
        Ok(created)
    }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error> {
        let mut list = Vec::new();
        let {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;
        {% for rid, r in s.entities[e].forward_relationships %}
        let {{ r.field_snake_name }}_junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper  }}_JUNCTION_TABLE)?;
        {%- endfor %}

        if ids.is_empty() {
            let mut iter = {{ s.entities[e].snake_name }}_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                {% for f in s.entities[e].fields %}
                {% if f.inner.field_type == "Entity" %}
                // get {{ f.snake_name }} from junction table
                    {% if f.relationship == "OneToMany" or f.relationship == "OrderedOneToMany" or f.relationship == "ManyToMany" %}
                let fetched_{{ f.snake_name }} = {{ f.snake_name }}_junction_table.get(&id)?.map(|g| g.value().clone()).unwrap_or_default();
                    {% elif f.optional %}
                let fetched_{{ f.snake_name }}: Option<EntityId> = {{ f.snake_name }}_junction_table.get(&id)?.map(|g| g.value().clone()).unwrap_or_default().pop();
                    {% else %}
                let fetched_{{ f.snake_name }}: EntityId = {{ f.snake_name }}_junction_table.get(&id)?.map(|g| g.value().clone()).unwrap_or_default().pop().expect("{{ s.entities[e].pascal_name }} has no {{ f.snake_name }}");
                    {% endif %}
                entity.{{ f.snake_name }} = fetched_{{ f.snake_name }};
                {% endif %}
                {% endfor %}

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = {{ s.entities[e].snake_name }}_table.get(id)? {
                    let mut entity = guard.value().clone();
                    {% for f in s.entities[e].fields %}
                    {% if f.inner.field_type == "Entity" %}
                    // get {{ f.snake_name }} from junction table
                        {% if f.relationship == "OneToMany" or f.relationship == "OrderedOneToMany" or f.relationship == "ManyToMany" %}
                    let fetched_{{ f.snake_name }} = {{ f.snake_name }}_junction_table.get(id)?.map(|g| g.value().clone()).unwrap_or_default();
                        {% elif f.optional %}
                    let fetched_{{ f.snake_name }}: Option<EntityId> = {{ f.snake_name }}_junction_table.get(id)?.map(|g| g.value().clone()).unwrap_or_default().pop();
                        {% else %}
                    let fetched_{{ f.snake_name }}: EntityId = {{ f.snake_name }}_junction_table.get(id)?.map(|g| g.value().clone()).unwrap_or_default().pop().expect("{{ s.entities[e].pascal_name }} has no {{ f.snake_name }}");
                        {% endif %}
                    entity.{{ f.snake_name }} = fetched_{{ f.snake_name }};
                    {% endif %}
                    {% endfor %}
                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }

    fn update_multi(&mut self, entities: &[{{ s.entities[e].pascal_name }}]) -> Result<Vec<{{ s.entities[e].pascal_name }}>, Error> {
        let mut updated = Vec::new();
        let mut {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;
        {% for rid, r in s.entities[e].forward_relationships %}
        let mut {{ r.field_snake_name }}_junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper  }}_JUNCTION_TABLE)?;
        {%- endfor %}

        for entity in entities {
            {% for f in s.entities[e].fields %}
            {% if f.inner.field_type == "Entity" and f.relationship == "OneToOne" %}
            // one-to-one constraint check: ensure {{ f.snake_name }} is not already referenced by another {{ s.entities[e].snake_name }}
            {
                let mut iter = {{ f.snake_name }}_junction_table.iter()?;
                while let Some(Ok((existing_id, right_ids))) = iter.next() {
                    let existing_id = existing_id.value();
                    {% if f.optional %}
                    if let Some(ref right_id) = entity.{{ f.snake_name }}
                         && existing_id != entity.id && right_ids.value().contains(right_id) {
                            panic!("One-to-one constraint violation: {{ s.entities[f.inner.entity].pascal_name }} {} is already referenced by {{ s.entities[e].pascal_name }} {}", right_id, existing_id);

                    }
                    {% else %}
                    if existing_id != entity.id && right_ids.value().contains(&entity.{{ f.snake_name }}) {
                        panic!("One-to-one constraint violation: {{ s.entities[f.inner.entity].pascal_name }} {} is already referenced by {{ s.entities[e].pascal_name }} {}", entity.{{ f.snake_name }}, existing_id);
                    }
                    {% endif %}
                }
            }
            {% endif %}
            {% endfor %}
            {{ s.entities[e].snake_name }}_table.insert(entity.id, entity)?;
            {% for f in s.entities[e].fields %}
            {%- if f.inner.field_type == "Entity" %}
                {% if f.relationship == "OneToMany" or f.relationship == "OrderedOneToMany" or f.relationship == "ManyToMany" %}
            {{ f.snake_name }}_junction_table.insert(entity.id, entity.{{ f.snake_name }}.clone())?;
                {% elif f.optional %}
            {{ f.snake_name }}_junction_table.insert(entity.id, entity.{{ f.snake_name }}.into_iter().collect::<Vec<EntityId>>())?;
                {% else %}
            {{ f.snake_name }}_junction_table.insert(entity.id, vec![entity.{{ f.snake_name }}] as Vec<EntityId>)?;
            {%- endif %}
            {%- endif %}
            {%- endfor %}
            updated.push(entity.clone());
        }
        Ok(updated)
    }

    fn delete_multi(&mut self, ids: &[EntityId]) -> Result<(), Error> {
        let mut {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;

        // forward relationships
        {% for rid, r in s.entities[e].forward_relationships %}
        let mut {{ r.field_snake_name }}_junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper  }}_JUNCTION_TABLE)?;
        {% endfor %}

        // backward relationships
        {% for rid, r in s.entities[e].backward_relationships %}
            {%- if r.inner.left_entity == e %}
                {%- continue %}
            {%- endif %}
        let mut backward_{{ s.entities[r.inner.left_entity].snake_name}}_{{ r.field_snake_name }}_junction_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
        {%- endfor %}

        for id in ids {
            {{ s.entities[e].snake_name }}_table.remove(id)?;
            {% for f in s.entities[e].fields %}
                {%- if f.inner.field_type == "Entity" %}
            {{ f.snake_name }}_junction_table.remove(id)?;
                {%- endif %}
            {%- endfor %}
            {% for rid, r in s.entities[e].backward_relationships %}
                {%- if r.inner.left_entity == e %}
            // special case: backward relationship to self
            db_helpers::delete_from_backward_junction_table(&mut {{ r.field_snake_name }}_junction_table, id)?;
                    {%- continue %}
                {%- endif %}
            db_helpers::delete_from_backward_junction_table(&mut backward_{{ s.entities[r.inner.left_entity].snake_name}}_{{ r.field_snake_name }}_junction_table, id)?;
            {%- endfor %}
        }
        Ok(())
    }

{% if s.entities[e].forward_relationships | length > 0 %}
    fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error> {
        let table = self.transaction.open_table(get_junction_table_definition(field))?;
        let guard = table.get(id)?;
        Ok(guard.map(|g| g.value().clone()).unwrap_or_default())
    }

    fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        let table = self.transaction.open_table(get_junction_table_definition(field))?;
        let mut iter = table.iter()?;
        let mut rels = vec![];
        while let Some(Ok((left_id, right_entities))) = iter.next() {
            let left_id = left_id.value();
            let right_entities = right_entities.value();
            if right_ids.iter().any(|eid| right_entities.contains(eid)) { rels.push((left_id, right_entities)); }
        }
        Ok(rels)
    }

    fn set_relationship_multi(&mut self, field: &{{ s.entities[e].pascal_name }}RelationshipField, relationships: Vec<(EntityId, Vec<EntityId>)>) -> Result<(), Error> {
        let mut table = self.transaction.open_table(get_junction_table_definition(field))?;
        for (left_id, entities) in relationships { table.insert(left_id, entities)?; }
        Ok(())
    }

    fn set_relationship(&mut self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<(), Error> {
        let mut table = self.transaction.open_table(get_junction_table_definition(field))?;
        table.insert(*id, right_ids.to_vec())?;
        Ok(())
    }
{% endif %}

    fn snapshot_rows(&self, ids: &[EntityId]) -> Result<TableLevelSnapshot, Error> {
        let {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;

        // Snapshot entity rows as bincode bytes
        let mut rows = Vec::new();
        for id in ids {
            if let Some(guard) = {{ s.entities[e].snake_name }}_table.get(id)? {
                let entity = guard.value();
                let bytes = bincode::serialize(&entity).map_err(|e| Error::TableDoesNotExist(format!("bincode serialize error: {}", e)))?;
                rows.push((*id, bytes));
            }
        }

        // Snapshot forward junction tables
        {% if s.entities[e].forward_relationships | length > 0 %}let mut forward_junctions = Vec::new();{% else %}let forward_junctions = Vec::new();{% endif %}
        {% for rid, r in s.entities[e].forward_relationships %}
        {
            let junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            for id in ids {
                if let Some(guard) = junction_table.get(id)? {
                    entries.push((*id, guard.value().clone()));
                }
            }
            forward_junctions.push(JunctionSnapshot {
                table_name: "{{ s.entities[r.inner.right_entity].snake_name }}_from_{{ s.entities[e].snake_name }}_{{ r.field_snake_name }}_junction".to_string(),
                entries,
            });
        }
        {%- endfor %}

        // Snapshot backward junction tables (entries that reference any of the given ids)
        {% if s.entities[e].backward_relationships | length > 0 %}let mut backward_junctions = Vec::new();{% else %}let backward_junctions = Vec::new();{% endif %}
        {% for rid, r in s.entities[e].backward_relationships %}
            {%- if r.inner.left_entity == e %}
        {
            let junction_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE_BACKWARD)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "{{ s.entities[e].snake_name }}_from_{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_junction".to_string(),
                    entries,
                });
            }
        }
            {%- else %}
        {
            let junction_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
            let mut entries = Vec::new();
            let mut iter = junction_table.iter()?;
            while let Some(Ok((left_id_guard, right_ids_guard))) = iter.next() {
                let left_id = left_id_guard.value();
                let right_ids = right_ids_guard.value();
                if ids.iter().any(|id| right_ids.contains(id)) {
                    entries.push((left_id, right_ids));
                }
            }
            if !entries.is_empty() {
                backward_junctions.push(JunctionSnapshot {
                    table_name: "{{ s.entities[e].snake_name }}_from_{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_junction".to_string(),
                    entries,
                });
            }
        }
            {%- endif %}
        {%- endfor %}

        Ok(TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "{{ s.entities[e].snake_name }}".to_string(),
                rows,
            },
            forward_junctions,
            backward_junctions,
        })
    }

    fn restore_rows(&mut self, snap: &TableLevelSnapshot) -> Result<(), Error> {
        let mut {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;

        // Restore entity rows from bincode bytes (redb insert is upsert)
        for (id, bytes) in &snap.entity_rows.rows {
            let entity: {{ s.entities[e].pascal_name }} = bincode::deserialize(bytes).map_err(|e| Error::TableDoesNotExist(format!("bincode deserialize error: {}", e)))?;
            {{ s.entities[e].snake_name }}_table.insert(*id, entity)?;
        }

        // Restore forward junction entries
        {% for rid, r in s.entities[e].forward_relationships %}
        {
            let mut junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
            for junction_snap in &snap.forward_junctions {
                if junction_snap.table_name == "{{ s.entities[r.inner.right_entity].snake_name }}_from_{{ s.entities[e].snake_name }}_{{ r.field_snake_name }}_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
        {%- endfor %}

        // Restore backward junction entries
        {% for rid, r in s.entities[e].backward_relationships %}
            {%- if r.inner.left_entity == e %}
        {
            let mut junction_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE_BACKWARD)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "{{ s.entities[e].snake_name }}_from_{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
            {%- else %}
        {
            let mut junction_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_FROM_{{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE)?;
            for junction_snap in &snap.backward_junctions {
                if junction_snap.table_name == "{{ s.entities[e].snake_name }}_from_{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_junction" {
                    for (left_id, right_ids) in &junction_snap.entries {
                        junction_table.insert(*left_id, right_ids.clone())?;
                    }
                }
            }
        }
            {%- endif %}
        {%- endfor %}

        Ok(())
    }
}

pub struct {{ s.entities[e].pascal_name }}RedbTableRO<'a> { transaction: &'a ReadTransaction }
impl<'a> {{ s.entities[e].pascal_name }}RedbTableRO<'a> { pub fn new(transaction: &'a ReadTransaction) -> Self { {{ s.entities[e].pascal_name }}RedbTableRO { transaction } } }

impl<'a> {{ s.entities[e].pascal_name }}TableRO for {{ s.entities[e].pascal_name }}RedbTableRO<'a> {
    fn get(&self, id: &EntityId) -> Result<Option<{{ s.entities[e].pascal_name }}>, Error> { let v = self.get_multi(std::slice::from_ref(id))?; Ok(v.into_iter().next().unwrap()) }

    fn get_multi(&self, ids: &[EntityId]) -> Result<Vec<Option<{{ s.entities[e].pascal_name }}>>, Error> {
        let mut list = Vec::new();
        let {{ s.entities[e].snake_name }}_table = self.transaction.open_table({{ s.entities[e].snake_name | upper }}_TABLE)?;
        {% for rid, r in s.entities[e].forward_relationships %}
        let {{ r.field_snake_name }}_junction_table = self.transaction.open_table({{ s.entities[r.inner.right_entity].snake_name | upper }}_FROM_{{ s.entities[e].snake_name | upper }}_{{ r.field_snake_name | upper  }}_JUNCTION_TABLE)?;
        {%- endfor %}

        if ids.is_empty() {
            let mut iter = {{ s.entities[e].snake_name }}_table.iter()?;
            let mut count = 0;

            while let Some(Ok((id, data))) = iter.next() {
                if count >= 1000 {
                    break;
                }

                let id = id.value();
                let mut entity = data.value().clone();

                {% for f in s.entities[e].fields %}
                {% if f.inner.field_type == "Entity" %}
                // get {{ f.snake_name }} from junction table
                    {% if f.relationship == "OneToMany" or f.relationship == "OrderedOneToMany" or f.relationship == "ManyToMany" %}
                let fetched_{{ f.snake_name }} = {{ f.snake_name }}_junction_table.get(&id)?.map(|g| g.value().clone()).unwrap_or_default();
                    {% elif f.optional %}
                let fetched_{{ f.snake_name }}: Option<EntityId> = {{ f.snake_name }}_junction_table.get(&id)?.map(|g| g.value().clone()).unwrap_or_default().pop();
                    {% else %}
                let fetched_{{ f.snake_name }}: EntityId = {{ f.snake_name }}_junction_table.get(&id)?.map(|g| g.value().clone()).unwrap_or_default().pop().expect("{{ s.entities[e].pascal_name }} has no {{ f.snake_name }}");
                    {% endif %}
                entity.{{ f.snake_name }} = fetched_{{ f.snake_name }};
                {% endif %}
                {% endfor %}

                list.push(Some(entity));
                count += 1;
            }
        } else {
            for id in ids {
                let item = if let Some(guard) = {{ s.entities[e].snake_name }}_table.get(id)? {
                    let mut entity = guard.value().clone();
                    {% for f in s.entities[e].fields %}
                    {% if f.inner.field_type == "Entity" %}
                    // get {{ f.snake_name }} from junction table
                        {% if f.relationship == "OneToMany" or f.relationship == "OrderedOneToMany" or f.relationship == "ManyToMany" %}
                    let fetched_{{ f.snake_name }} = {{ f.snake_name }}_junction_table.get(id)?.map(|g| g.value().clone()).unwrap_or_default();
                        {% elif f.optional %}
                    let fetched_{{ f.snake_name }}: Option<EntityId> = {{ f.snake_name }}_junction_table.get(id)?.map(|g| g.value().clone()).unwrap_or_default().pop();
                        {% else %}
                    let fetched_{{ f.snake_name }}: EntityId = {{ f.snake_name }}_junction_table.get(id)?.map(|g| g.value().clone()).unwrap_or_default().pop().expect("{{ s.entities[e].pascal_name }} has no {{ f.snake_name }}");
                        {% endif %}
                    entity.{{ f.snake_name }} = fetched_{{ f.snake_name }};
                    {% endif %}
                    {% endfor %}
                    Some(entity)
                } else {
                    None
                };
                list.push(item);
            }
        }

        Ok(list)
    }

{% if s.entities[e].forward_relationships | length > 0 %}
    fn get_relationship(&self, id: &EntityId, field: &{{ s.entities[e].pascal_name }}RelationshipField) -> Result<Vec<EntityId>, Error> {
        let table = self.transaction.open_table(get_junction_table_definition(field))?;
        let guard = table.get(id)?;
        Ok(guard.map(|g| g.value().clone()).unwrap_or_default())
    }

    fn get_relationships_from_right_ids(&self, field: &{{ s.entities[e].pascal_name }}RelationshipField, right_ids: &[EntityId]) -> Result<Vec<(EntityId, Vec<EntityId>)>, Error> {
        let table = self.transaction.open_table(get_junction_table_definition(field))?;
        let mut iter = table.iter()?;
        let mut rels = vec![];
        while let Some(Ok((left_id, right_entities))) = iter.next() {
            let left_id = left_id.value();
            let right_entities = right_entities.value();
            if right_ids.iter().any(|eid| right_entities.contains(eid)) { rels.push((left_id, right_entities)); }
        }
        Ok(rels)
    }

{% endif %}

}
{% else %}
// No entity bound to this file
{% endif %}
