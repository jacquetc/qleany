// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use anyhow::Result;
use std::any::Any;
use std::sync::Arc;
use crate::event::{EventHub, Event, Origin, UndoRedoEvent};
use crate::types::EntityId;

/// Trait for commands that can be undone and redone.
///
/// Implementors can optionally support command merging by overriding the
/// `can_merge` and `merge` methods. This allows the UndoRedoManager to combine
/// multiple commands of the same type into a single command, which is useful for
/// operations like continuous typing or dragging.
pub trait UndoRedoCommand: Send {
    /// Undoes the command, reverting its effects
    fn undo(&mut self) -> Result<()>;

    /// Redoes the command, reapplying its effects
    fn redo(&mut self) -> Result<()>;

    /// Returns true if this command can be merged with the other command.
    ///
    /// By default, commands cannot be merged. Override this method to enable
    /// merging for specific command types.
    ///
    /// # Example
    /// ```test
    /// fn can_merge(&self, other: &dyn UndoRedoCommand) -> bool {
    ///     // Check if the other command is of the same type
    ///     if let Some(_) = other.as_any().downcast_ref::<Self>() {
    ///         return true;
    ///     }
    ///     false
    /// }
    /// ```
    fn can_merge(&self, _other: &dyn UndoRedoCommand) -> bool {
        false
    }

    /// Merges this command with the other command.
    /// Returns true if the merge was successful.
    ///
    /// This method is called only if `can_merge` returns true.
    ///
    /// # Example
    /// ```test
    /// use common::undo_redo::UndoRedoCommand;
    ///
    /// fn merge(&mut self, other: &dyn UndoRedoCommand) -> bool {
    ///     if let Some(other_cmd) = other.as_any().downcast_ref::<Self>() {
    ///         // Merge the commands
    ///         self.value += other_cmd.value;
    ///         return true;
    ///     }
    ///     false
    /// }
    /// ```
    fn merge(&mut self, _other: &dyn UndoRedoCommand) -> bool {
        false
    }

    /// Returns the type ID of this command for type checking.
    ///
    /// This is used for downcasting in the `can_merge` and `merge` methods.
    ///
    /// # Example
    /// ```test
    /// fn as_any(&self) -> &dyn Any {
    ///     self
    /// }
    /// ```
    fn as_any(&self) -> &dyn Any;
}

/// A composite command that groups multiple commands as one.
///
/// This allows treating a sequence of commands as a single unit for undo/redo operations.
/// When a composite command is undone or redone, all its contained commands are undone
/// or redone in the appropriate order.
///
/// # Example
/// ```test
/// use common::undo_redo::CompositeCommand;
/// let mut composite = CompositeCommand::new();
/// composite.add_command(Box::new(Command1::new()));
/// composite.add_command(Box::new(Command2::new()));
/// // Now composite can be treated as a single command
/// ```
pub struct CompositeCommand {
    commands: Vec<Box<dyn UndoRedoCommand>>,
}

impl CompositeCommand {
    /// Creates a new empty composite command.
    pub fn new() -> Self {
        CompositeCommand {
            commands: Vec::new(),
        }
    }

    /// Adds a command to this composite.
    ///
    /// Commands are executed, undone, and redone in the order they are added.
    pub fn add_command(&mut self, command: Box<dyn UndoRedoCommand>) {
        self.commands.push(command);
    }

    /// Returns true if this composite contains no commands.
    pub fn is_empty(&self) -> bool {
        self.commands.is_empty()
    }
}

impl UndoRedoCommand for CompositeCommand {
    fn undo(&mut self) -> Result<()> {
        // Undo commands in reverse order
        for command in self.commands.iter_mut().rev() {
            command.undo()?;
        }
        Ok(())
    }

    fn redo(&mut self) -> Result<()> {
        // Redo commands in original order
        for command in self.commands.iter_mut() {
            command.redo()?;
        }
        Ok(())
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
/// Trait for commands that can be executed asynchronously with progress tracking and cancellation.
///
/// This trait extends the basic UndoRedoCommand trait with asynchronous capabilities.
/// Implementors must also implement the UndoRedoCommand trait to ensure compatibility
/// with the existing undo/redo system.
pub trait AsyncUndoRedoCommand: UndoRedoCommand {
    /// Starts the undo operation asynchronously and returns immediately.
    /// Returns Ok(()) if the operation was successfully started.
    fn start_undo(&mut self) -> Result<()>;

    /// Starts the redo operation asynchronously and returns immediately.
    /// Returns Ok(()) if the operation was successfully started.
    fn start_redo(&mut self) -> Result<()>;

    /// Checks the progress of the current operation.
    /// Returns a value between 0.0 (not started) and 1.0 (completed).
    fn check_progress(&self) -> f32;

    /// Attempts to cancel the in-progress operation.
    /// Returns Ok(()) if cancellation was successful or if no operation is in progress.
    fn cancel(&mut self) -> Result<()>;

    /// Checks if the current operation is complete.
    /// Returns true if the operation has finished successfully.
    fn is_complete(&self) -> bool;
}

/// Manager for undo and redo operations.
///
/// The UndoRedoManager maintains two stacks of commands:
/// - An undo stack for commands that can be undone
/// - A redo stack for commands that have been undone and can be redone
///
/// It also supports:
/// - Grouping multiple commands as a single unit using begin_composite/end_composite
/// - Merging commands of the same type when appropriate
pub struct UndoRedoManager {
    undo_stack: Vec<Box<dyn UndoRedoCommand>>,
    redo_stack: Vec<Box<dyn UndoRedoCommand>>,
    in_progress_composite: Option<CompositeCommand>,
    composite_nesting_level: usize,
    event_hub: Option<Arc<EventHub>>,
}

impl UndoRedoManager {
    /// Creates a new empty UndoRedoManager.
    pub fn new() -> Self {
        UndoRedoManager {
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            in_progress_composite: None,
            composite_nesting_level: 0,
            event_hub: None,
        }
    }

    /// Inject the event hub to allow sending undo/redo related events
    pub fn set_event_hub(&mut self, event_hub: &Arc<EventHub>) {
        self.event_hub = Some(Arc::clone(event_hub));
    }

    /// Undoes the most recent command.
    ///
    /// The undone command is moved to the redo stack.
    /// Returns Ok(()) if successful or if there are no commands to undo.
    pub fn undo(&mut self) -> Result<()> {
        if let Some(mut command) = self.undo_stack.pop() {
            command.undo()?;
            self.redo_stack.push(command);
            if let Some(event_hub) = &self.event_hub {
                event_hub.send_event(Event {
                    origin: Origin::UndoRedo(UndoRedoEvent::Undone),
                    ids: Vec::<EntityId>::new(),
                    data: None,
                });
            }
        }
        Ok(())
    }

    /// Redoes the most recently undone command.
    ///
    /// The redone command is moved back to the undo stack.
    /// Returns Ok(()) if successful or if there are no commands to redo.
    pub fn redo(&mut self) -> Result<()> {
        if let Some(mut command) = self.redo_stack.pop() {
            command.redo()?;
            self.undo_stack.push(command);
            if let Some(event_hub) = &self.event_hub {
                event_hub.send_event(Event {
                    origin: Origin::UndoRedo(UndoRedoEvent::Redone),
                    ids: Vec::<EntityId>::new(),
                    data: None,
                });
            }
        }
        Ok(())
    }

    /// Begins a composite command group.
    ///
    /// All commands added between begin_composite and end_composite will be treated as a single command.
    /// This is useful for operations that logically represent a single action but require multiple
    /// commands to implement.
    ///
    /// # Example
    /// ```test
    /// let mut manager = UndoRedoManager::new();
    /// manager.begin_composite();
    /// manager.add_command(Box::new(Command1::new()));
    /// manager.add_command(Box::new(Command2::new()));
    /// manager.end_composite();
    /// // Now undo() will undo both commands as a single unit
    /// ```
    pub fn begin_composite(&mut self) {
        // Increment the nesting level
        self.composite_nesting_level += 1;

        // If there's no composite in progress, create one
        if self.in_progress_composite.is_none() {
            self.in_progress_composite = Some(CompositeCommand::new());
        }

        if let Some(event_hub) = &self.event_hub {
            event_hub.send_event(Event {
                origin: Origin::UndoRedo(UndoRedoEvent::BeginComposite),
                ids: Vec::<EntityId>::new(),
                data: None,
            });
        }
    }

    /// Ends the current composite command group and adds it to the undo stack.
    ///
    /// If no commands were added to the composite, nothing is added to the undo stack.
    /// If this is a nested composite, only the outermost composite is added to the undo stack.
    pub fn end_composite(&mut self) {
        // Decrement the nesting level
        if self.composite_nesting_level > 0 {
            self.composite_nesting_level -= 1;
        }

        // Only end the composite if we're at the outermost level
        if self.composite_nesting_level == 0 {
            if let Some(composite) = self.in_progress_composite.take() {
                if !composite.is_empty() {
                    self.undo_stack.push(Box::new(composite));
                    self.redo_stack.clear();
                }
            }
            if let Some(event_hub) = &self.event_hub {
                event_hub.send_event(Event {
                    origin: Origin::UndoRedo(UndoRedoEvent::EndComposite),
                    ids: Vec::<EntityId>::new(),
                    data: None,
                });
            }
        }
    }

    /// Adds a command to the undo stack.
    ///
    /// This method handles several cases:
    /// 1. If a composite command is in progress, the command is added to the composite
    /// 2. If the command can be merged with the last command on the undo stack, they are merged
    /// 3. Otherwise, the command is added to the undo stack as a new entry
    ///
    /// In all cases, the redo stack is cleared when a new command is added.
    ///
    /// # Example
    /// ```test
    /// use common::undo_redo::UndoRedoManager;
    /// let mut manager = UndoRedoManager::new();
    /// manager.add_command(Box::new(MyCommand::new("initial text")));
    /// // Later, add another command that might be merged with the first
    /// manager.add_command(Box::new(MyCommand::new("additional text")));
    /// ```
    pub fn add_command(&mut self, command: Box<dyn UndoRedoCommand>) {
        // If we have a composite in progress, add the command to it
        if let Some(composite) = &mut self.in_progress_composite {
            composite.add_command(command);
            return;
        }

        // Try to merge with the last command if possible
        if let Some(last_command) = self.undo_stack.last_mut() {
            if last_command.can_merge(&*command) {
                if last_command.merge(&*command) {
                    // Successfully merged, no need to add the new command
                    self.redo_stack.clear();
                    return;
                }
            }
        }

        // If we couldn't merge, just add the command normally
        self.undo_stack.push(command);
        self.redo_stack.clear();
    }

    /// Returns true if there are commands that can be undone.
    pub fn can_undo(&self) -> bool {
        !self.undo_stack.is_empty()
    }

    /// Returns true if there are commands that can be redone.
    pub fn can_redo(&self) -> bool {
        !self.redo_stack.is_empty()
    }

    /// Clears all undo and redo history.
    ///
    /// This method removes all commands from both the undo and redo stacks,
    /// and resets any in-progress composite command.
    pub fn clear(&mut self) {
        self.undo_stack.clear();
        self.redo_stack.clear();
        self.in_progress_composite = None;
        self.composite_nesting_level = 0;
    }
}
