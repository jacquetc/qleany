// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.
#![cfg(test)]
#![allow(dead_code)]
#![allow(unused_imports)]

use common::snapshot::{EntityTreeSnapshot, JunctionSnapshot, TableLevelSnapshot, TableSnapshot};
use common::types::EntityId;

#[test]
fn test_snapshot_types_default() {
    // Verify all snapshot types have sensible defaults
    let table_snap = TableSnapshot::default();
    assert!(table_snap.table_name.is_empty());
    assert!(table_snap.rows.is_empty());

    let junction_snap = JunctionSnapshot::default();
    assert!(junction_snap.table_name.is_empty());
    assert!(junction_snap.entries.is_empty());

    let table_level = TableLevelSnapshot::default();
    assert!(table_level.entity_rows.rows.is_empty());
    assert!(table_level.forward_junctions.is_empty());
    assert!(table_level.backward_junctions.is_empty());

    let tree_snap = EntityTreeSnapshot::default();
    assert!(tree_snap.table_data.entity_rows.rows.is_empty());
    assert!(tree_snap.children.is_empty());
}

#[test]
fn test_snapshot_serialization_roundtrip() {
    // Test that snapshots can be serialized and deserialized
    let snap = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "test_entity".to_string(),
                rows: vec![
                    (1, vec![1, 2, 3, 4]),
                    (2, vec![5, 6, 7, 8]),
                ],
            },
            forward_junctions: vec![JunctionSnapshot {
                table_name: "child_from_test_entity_children_junction".to_string(),
                entries: vec![
                    (1, vec![10, 11]),
                    (2, vec![12]),
                ],
            }],
            backward_junctions: vec![JunctionSnapshot {
                table_name: "test_entity_from_parent_items_junction".to_string(),
                entries: vec![(100, vec![1, 2])],
            }],
        },
        children: vec![EntityTreeSnapshot {
            table_data: TableLevelSnapshot {
                entity_rows: TableSnapshot {
                    table_name: "child_entity".to_string(),
                    rows: vec![
                        (10, vec![20, 21]),
                        (11, vec![22, 23]),
                        (12, vec![24, 25]),
                    ],
                },
                forward_junctions: vec![],
                backward_junctions: vec![],
            },
            children: vec![],
        }],
    };

    let serialized = bincode::serialize(&snap).expect("serialize failed");
    let deserialized: EntityTreeSnapshot =
        bincode::deserialize(&serialized).expect("deserialize failed");

    assert_eq!(deserialized.table_data.entity_rows.table_name, "test_entity");
    assert_eq!(deserialized.table_data.entity_rows.rows.len(), 2);
    assert_eq!(deserialized.table_data.forward_junctions.len(), 1);
    assert_eq!(deserialized.table_data.backward_junctions.len(), 1);
    assert_eq!(deserialized.children.len(), 1);
    assert_eq!(
        deserialized.children[0].table_data.entity_rows.table_name,
        "child_entity"
    );
    assert_eq!(deserialized.children[0].table_data.entity_rows.rows.len(), 3);
}

#[test]
fn test_snapshot_empty_tree() {
    // An empty EntityTreeSnapshot should round-trip
    let snap = EntityTreeSnapshot::default();
    let serialized = bincode::serialize(&snap).expect("serialize failed");
    let deserialized: EntityTreeSnapshot =
        bincode::deserialize(&serialized).expect("deserialize failed");
    assert!(deserialized.table_data.entity_rows.rows.is_empty());
    assert!(deserialized.children.is_empty());
}

#[test]
fn test_snapshot_deeply_nested() {
    // Test a snapshot tree with 3 levels of nesting
    let leaf = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "leaf".to_string(),
                rows: vec![(100, vec![1])],
            },
            forward_junctions: vec![],
            backward_junctions: vec![],
        },
        children: vec![],
    };

    let middle = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "middle".to_string(),
                rows: vec![(10, vec![2])],
            },
            forward_junctions: vec![JunctionSnapshot {
                table_name: "leaf_from_middle_leaves_junction".to_string(),
                entries: vec![(10, vec![100])],
            }],
            backward_junctions: vec![],
        },
        children: vec![leaf],
    };

    let root = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "root".to_string(),
                rows: vec![(1, vec![3])],
            },
            forward_junctions: vec![JunctionSnapshot {
                table_name: "middle_from_root_middles_junction".to_string(),
                entries: vec![(1, vec![10])],
            }],
            backward_junctions: vec![],
        },
        children: vec![middle],
    };

    // Verify structure
    assert_eq!(root.children.len(), 1);
    assert_eq!(root.children[0].children.len(), 1);
    assert_eq!(root.children[0].children[0].children.len(), 0);

    // Verify round-trip
    let serialized = bincode::serialize(&root).expect("serialize failed");
    let deserialized: EntityTreeSnapshot =
        bincode::deserialize(&serialized).expect("deserialize failed");
    assert_eq!(deserialized.table_data.entity_rows.table_name, "root");
    assert_eq!(
        deserialized.children[0].table_data.entity_rows.table_name,
        "middle"
    );
    assert_eq!(
        deserialized.children[0].children[0]
            .table_data
            .entity_rows
            .table_name,
        "leaf"
    );
}

#[test]
fn test_snapshot_multiple_children() {
    // Test a snapshot with multiple child types
    let child_a = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "child_a".to_string(),
                rows: vec![(10, vec![1, 2]), (11, vec![3, 4])],
            },
            forward_junctions: vec![],
            backward_junctions: vec![],
        },
        children: vec![],
    };

    let child_b = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "child_b".to_string(),
                rows: vec![(20, vec![5, 6])],
            },
            forward_junctions: vec![],
            backward_junctions: vec![],
        },
        children: vec![],
    };

    let parent = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "parent".to_string(),
                rows: vec![(1, vec![10, 11, 12])],
            },
            forward_junctions: vec![
                JunctionSnapshot {
                    table_name: "child_a_from_parent_items_a_junction".to_string(),
                    entries: vec![(1, vec![10, 11])],
                },
                JunctionSnapshot {
                    table_name: "child_b_from_parent_items_b_junction".to_string(),
                    entries: vec![(1, vec![20])],
                },
            ],
            backward_junctions: vec![],
        },
        children: vec![child_a, child_b],
    };

    assert_eq!(parent.children.len(), 2);
    assert_eq!(parent.table_data.forward_junctions.len(), 2);

    // Look up children by table name
    let found_a = parent
        .children
        .iter()
        .find(|c| c.table_data.entity_rows.table_name == "child_a");
    assert!(found_a.is_some());
    assert_eq!(found_a.unwrap().table_data.entity_rows.rows.len(), 2);

    let found_b = parent
        .children
        .iter()
        .find(|c| c.table_data.entity_rows.table_name == "child_b");
    assert!(found_b.is_some());
    assert_eq!(found_b.unwrap().table_data.entity_rows.rows.len(), 1);
}

#[test]
fn test_snapshot_clone() {
    // Verify Clone works correctly for deep structures
    let snap = EntityTreeSnapshot {
        table_data: TableLevelSnapshot {
            entity_rows: TableSnapshot {
                table_name: "entity".to_string(),
                rows: vec![(1, vec![1, 2, 3])],
            },
            forward_junctions: vec![JunctionSnapshot {
                table_name: "junction".to_string(),
                entries: vec![(1, vec![10])],
            }],
            backward_junctions: vec![],
        },
        children: vec![EntityTreeSnapshot {
            table_data: TableLevelSnapshot {
                entity_rows: TableSnapshot {
                    table_name: "child".to_string(),
                    rows: vec![(10, vec![4, 5])],
                },
                forward_junctions: vec![],
                backward_junctions: vec![],
            },
            children: vec![],
        }],
    };

    let cloned = snap.clone();
    assert_eq!(
        cloned.table_data.entity_rows.table_name,
        snap.table_data.entity_rows.table_name
    );
    assert_eq!(
        cloned.table_data.entity_rows.rows.len(),
        snap.table_data.entity_rows.rows.len()
    );
    assert_eq!(cloned.children.len(), snap.children.len());
}
