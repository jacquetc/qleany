// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

{%- set f_id = s.file.inner.feature %}
{%- if f_id %}
{%- set f = s.features[f_id] %}
{% for uc_id, uc in f.use_cases %}
use crate::units_of_work::{{ uc.snake_name }}_uow::{{ uc.pascal_name }}UnitOfWorkFactory;
use crate::use_cases::{{ uc.snake_name }}_uc::{{ uc.pascal_name }}UseCase;
{%- if uc.dto_in %}
use crate::{{ uc.dto_in.pascal_name }};
{%- endif %}
{%- if uc.dto_out %}
use crate::{{ uc.dto_out.pascal_name }};
{%- endif %}
{%- endfor %}
use anyhow::Result;
use common::event::{Event, Origin};
{% for uc_id, uc in f.use_cases %}
use common::event::{{ f.pascal_name }}Event::{{ uc.pascal_name }};
{%- endfor %}
{% for uc_id, uc in f.use_cases %}
{%- if uc.inner.long_operation %}
use common::long_operation::LongOperationManager;
{%- break %}
{%- endif %}
{%- endfor %}
use common::{database::db_context::DbContext, event::EventHub};
use std::sync::Arc;


{% for uc_id, uc in f.use_cases %}
{%- if uc.inner.long_operation %}

pub fn {{ uc.snake_name }}(
    db_context: &DbContext,
    event_hub: &Arc<EventHub>,
    long_operation_manager: &mut LongOperationManager,
{%- if uc.dto_in %}
    dto: &{{ uc.dto_in.pascal_name }},
{%- endif %}
) -> Result<String> {
    let uow_context = {{ uc.pascal_name }}UnitOfWorkFactory::new(db_context);
    let uc = {{ uc.pascal_name }}UseCase::new(Box::new(uow_context) {% if uc.dto_in %} , dto {% endif %} );
    let operation_id = long_operation_manager.start_operation(uc);
    Ok(operation_id)
}

pub fn get_{{ uc.snake_name }}_progress(
    long_operation_manager: &LongOperationManager,
    operation_id: &str,
) -> Option<OperationProgress> {
    long_operation_manager.get_operation_progress(operation_id)
}

pub fn get_{{ uc.snake_name }}_result(
    long_operation_manager: &LongOperationManager,
    operation_id: &str,
) -> Result<Option<{{ uc.dto_out.pascal_name }}>> {
    // Get the operation result as a JSON string
    let result_json = long_operation_manager.get_operation_result(operation_id);

    // If there's no result, return None
    if result_json.is_none() {
        return Ok(None);
    }

    // Parse the JSON string into a {{ uc.dto_out.pascal_name }}
    let result_dto: {{ uc.dto_out.pascal_name }} = serde_json::from_str(&result_json.unwrap())?;

    Ok(Some(result_dto))
}

{%- else %}

pub fn {{ uc.snake_name }} (
    db_context: &DbContext,
    event_hub: &Arc<EventHub>,
{%- if uc.dto_in %}
    dto: &{{ uc.dto_in.pascal_name }},
{%- endif %}
) -> Result<{% if uc.dto_out %}{{ uc.dto_out.pascal_name }}{% else %}(){% endif %}> {
{%- if uc.inner.read_only %}
    let uow_context = {{ uc.pascal_name }}UnitOfWorkFactory::new(db_context);
{%- else %}{# read_only #}
    let uow_context = {{ uc.pascal_name }}UnitOfWorkFactory::new(db_context, event_hub);
{%- endif %}{# read_only #}
    let mut uc = {{ uc.pascal_name }}UseCase::new(Box::new(uow_context));
    let return_dto = uc.execute({% if uc.dto_in %} dto {% endif %})?;
    // Notify that the handling manifest has been loaded
    event_hub.send_event(Event {
        origin: Origin::{{ f.pascal_name }}({{ uc.pascal_name }}),
        ids: vec![],
        data: None,
    });
    Ok(return_dto)
}

{%- endif %}
{%- endfor %}

{% else %}
// No feature bound to this file
{% endif %}
