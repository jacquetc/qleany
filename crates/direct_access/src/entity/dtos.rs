// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use common::entities::Entity;
use common::types::EntityId;
use serde::{Deserialize, Serialize};
use std::convert::From;

#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
pub struct EntityDto {
    pub id: EntityId,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub name: String,
    pub inherits_from: Option<EntityId>,
    pub only_for_heritage: bool,
    pub fields: Vec<EntityId>,
    pub relationships: Vec<EntityId>,
    pub single_model: bool,
    pub undoable: bool,
}

impl From<EntityDto> for Entity {
    fn from(dto: EntityDto) -> Self {
        Entity {
            id: dto.id,
            created_at: dto.created_at,
            updated_at: dto.updated_at,
            name: dto.name,
            inherits_from: dto.inherits_from,
            only_for_heritage: dto.only_for_heritage,
            fields: dto.fields,
            relationships: dto.relationships,
            single_model: dto.single_model,
            undoable: dto.undoable,
        }
    }
}

impl From<&EntityDto> for Entity {
    fn from(dto: &EntityDto) -> Self {
        Entity {
            id: dto.id,
            created_at: dto.created_at.clone(),
            updated_at: dto.updated_at.clone(),
            name: dto.name.clone(),
            inherits_from: dto.inherits_from.clone(),
            only_for_heritage: dto.only_for_heritage.clone(),
            fields: dto.fields.clone(),
            relationships: dto.relationships.clone(),
            single_model: dto.single_model.clone(),
            undoable: dto.undoable.clone(),
        }
    }
}

impl From<Entity> for EntityDto {
    fn from(entity: Entity) -> Self {
        EntityDto {
            id: entity.id,
            created_at: entity.created_at,
            updated_at: entity.updated_at,
            name: entity.name,
            inherits_from: entity.inherits_from,
            only_for_heritage: entity.only_for_heritage,
            fields: entity.fields,
            relationships: entity.relationships,
            single_model: entity.single_model,
            undoable: entity.undoable,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
pub struct CreateEntityDto {
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
    pub name: String,
    pub inherits_from: Option<EntityId>,
    pub only_for_heritage: bool,
    pub fields: Vec<EntityId>,
    pub relationships: Vec<EntityId>,
    pub single_model: bool,
    pub undoable: bool,
}

impl From<CreateEntityDto> for Entity {
    fn from(dto: CreateEntityDto) -> Self {
        Entity {
            id: 0,
            created_at: dto.created_at,
            updated_at: dto.updated_at,
            name: dto.name,
            inherits_from: dto.inherits_from,
            only_for_heritage: dto.only_for_heritage,
            fields: dto.fields,
            relationships: dto.relationships,
            single_model: dto.single_model,
            undoable: dto.undoable,
        }
    }
}

impl From<&CreateEntityDto> for Entity {
    fn from(dto: &CreateEntityDto) -> Self {
        Entity {
            id: 0,
            created_at: dto.created_at.clone(),
            updated_at: dto.updated_at.clone(),
            name: dto.name.clone(),
            inherits_from: dto.inherits_from.clone(),
            only_for_heritage: dto.only_for_heritage.clone(),
            fields: dto.fields.clone(),
            relationships: dto.relationships.clone(),
            single_model: dto.single_model.clone(),
            undoable: dto.undoable.clone(),
        }
    }
}

impl From<Entity> for CreateEntityDto {
    fn from(entity: Entity) -> Self {
        CreateEntityDto {
            created_at: entity.created_at,
            updated_at: entity.updated_at,
            name: entity.name,
            inherits_from: entity.inherits_from,
            only_for_heritage: entity.only_for_heritage,
            fields: entity.fields,
            relationships: entity.relationships,
            single_model: entity.single_model,
            undoable: entity.undoable,
        }
    }
}
pub use common::direct_access::entity::EntityRelationshipField;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EntityRelationshipDto {
    pub id: EntityId,
    pub field: EntityRelationshipField,
    pub right_ids: Vec<EntityId>,
}
