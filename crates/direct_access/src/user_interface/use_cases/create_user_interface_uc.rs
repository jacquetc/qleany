// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use super::UserInterfaceUnitOfWorkFactoryTrait;
use crate::user_interface::dtos::{CreateUserInterfaceDto, UserInterfaceDto};
use anyhow::{Ok, Result};
use common::entities::UserInterface;
use common::snapshot::EntityTreeSnapshot;
use common::types::EntityId;
use common::undo_redo::UndoRedoCommand;
use std::any::Any;

pub struct CreateUserInterfaceUseCase {
    uow_factory: Box<dyn UserInterfaceUnitOfWorkFactoryTrait>,
    created_entity: Option<UserInterface>,
    owner_id: Option<EntityId>,
    index: i32,
    old_tree_snapshot: Option<EntityTreeSnapshot>,
    existing_child_ids: Vec<EntityId>,
    displaced_children_snapshot: Option<EntityTreeSnapshot>,
}

impl CreateUserInterfaceUseCase {
    pub fn new(uow_factory: Box<dyn UserInterfaceUnitOfWorkFactoryTrait>) -> Self {
        CreateUserInterfaceUseCase {
            uow_factory,
            created_entity: None,
            owner_id: None,
            index: -1,
            old_tree_snapshot: None,
            existing_child_ids: Vec::new(),
            displaced_children_snapshot: None,
        }
    }

    pub fn execute(
        &mut self,
        dto: CreateUserInterfaceDto,
        owner_id: EntityId,
        index: i32,
    ) -> Result<UserInterfaceDto> {
        let mut uow = self.uow_factory.create();
        uow.begin_transaction()?;
        self.owner_id = Some(owner_id);
        self.index = index;
        // Pre-snapshot existing children that will be displaced by create
        self.existing_child_ids = uow.get_relationships_from_owner(&owner_id)?;
        if !self.existing_child_ids.is_empty() {
            self.displaced_children_snapshot =
                Some(uow.snapshot_user_interface(&self.existing_child_ids)?);
        }

        // Create with owner (repository handles junction management internally)
        let entity = uow.create_user_interface_with_owner(&dto.into(), owner_id, index)?;

        uow.commit()?;
        self.created_entity = Some(entity.clone());

        Ok(entity.into())
    }
}
impl UndoRedoCommand for CreateUserInterfaceUseCase {
    fn undo(&mut self) -> Result<()> {
        if let Some(ref created) = self.created_entity {
            let owner_id = self.owner_id.expect("owner_id not set");
            let mut uow = self.uow_factory.create();
            uow.begin_transaction()?;

            // Snapshot the created entity tree before removing (for redo)
            self.old_tree_snapshot = Some(uow.snapshot_user_interface(&[created.id])?);

            // Remove the created entity
            uow.delete_user_interface(&created.id)?;
            // Restore displaced children and fix owner junction
            if let Some(ref snap) = self.displaced_children_snapshot {
                uow.restore_user_interface(snap)?;
                uow.set_relationships_in_owner(&owner_id, &self.existing_child_ids)?;
            } else {
                uow.set_relationships_in_owner(&owner_id, &[])?;
            }

            uow.commit()?;
        }
        Ok(())
    }

    fn redo(&mut self) -> Result<()> {
        if let Some(ref snapshot) = self.old_tree_snapshot {
            let owner_id = self.owner_id.expect("owner_id not set");
            let mut uow = self.uow_factory.create();
            uow.begin_transaction()?;
            // Re-snapshot displaced children for next undo cycle
            if !self.existing_child_ids.is_empty() {
                self.displaced_children_snapshot =
                    Some(uow.snapshot_user_interface(&self.existing_child_ids)?);
                uow.delete_user_interface_multi(&self.existing_child_ids)?;
            }

            // Restore the created entity tree
            uow.restore_user_interface(snapshot)?;

            // Fix owner junction to point to the recreated entity
            if let Some(ref created) = self.created_entity {
                uow.set_relationships_in_owner(&owner_id, &[created.id])?;
            }

            uow.commit()?;
        }
        Ok(())
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
}
