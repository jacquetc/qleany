// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.

use common::entities::Field;
use common::entities::FieldRelationshipType;
use common::entities::FieldType;
use common::types::EntityId;
use serde::{Deserialize, Serialize};
use std::convert::From;

#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
pub struct FieldDto {
    pub id: EntityId,
    pub name: String,
    pub field_type: FieldType,
    pub entity: Option<EntityId>,
    pub relationship: FieldRelationshipType,
    pub optional: bool,
    pub strong: bool,
    pub list_model: bool,
    pub list_model_displayed_field: Option<String>,
    pub enum_name: Option<String>,
    pub enum_values: Option<Vec<String>>,
}

impl From<FieldDto> for Field {
    fn from(dto: FieldDto) -> Self {
        Field {
            id: dto.id,
            name: dto.name,
            field_type: dto.field_type,
            entity: dto.entity,
            relationship: dto.relationship,
            optional: dto.optional,
            strong: dto.strong,
            list_model: dto.list_model,
            list_model_displayed_field: dto.list_model_displayed_field,
            enum_name: dto.enum_name,
            enum_values: dto.enum_values,
        }
    }
}

impl From<&FieldDto> for Field {
    fn from(dto: &FieldDto) -> Self {
        Field {
            id: dto.id,
            name: dto.name.clone(),
            field_type: dto.field_type.clone(),
            entity: dto.entity,
            relationship: dto.relationship.clone(),
            optional: dto.optional,
            strong: dto.strong,
            list_model: dto.list_model,
            list_model_displayed_field: dto.list_model_displayed_field.clone(),
            enum_name: dto.enum_name.clone(),
            enum_values: dto.enum_values.clone(),
        }
    }
}

impl From<Field> for FieldDto {
    fn from(entity: Field) -> Self {
        FieldDto {
            id: entity.id,
            name: entity.name,
            field_type: entity.field_type,
            entity: entity.entity,
            relationship: entity.relationship,
            optional: entity.optional,
            strong: entity.strong,
            list_model: entity.list_model,
            list_model_displayed_field: entity.list_model_displayed_field,
            enum_name: entity.enum_name,
            enum_values: entity.enum_values,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Default, Serialize, Deserialize)]
pub struct CreateFieldDto {
    pub name: String,
    pub field_type: FieldType,
    pub entity: Option<EntityId>,
    pub relationship: FieldRelationshipType,
    pub optional: bool,
    pub strong: bool,
    pub list_model: bool,
    pub list_model_displayed_field: Option<String>,
    pub enum_name: Option<String>,
    pub enum_values: Option<Vec<String>>,
}

impl From<CreateFieldDto> for Field {
    fn from(dto: CreateFieldDto) -> Self {
        Field {
            id: 0,
            name: dto.name,
            field_type: dto.field_type,
            entity: dto.entity,
            relationship: dto.relationship,
            optional: dto.optional,
            strong: dto.strong,
            list_model: dto.list_model,
            list_model_displayed_field: dto.list_model_displayed_field,
            enum_name: dto.enum_name,
            enum_values: dto.enum_values,
        }
    }
}

impl From<&CreateFieldDto> for Field {
    fn from(dto: &CreateFieldDto) -> Self {
        Field {
            id: 0,
            name: dto.name.clone(),
            field_type: dto.field_type.clone(),
            entity: dto.entity,
            relationship: dto.relationship.clone(),
            optional: dto.optional,
            strong: dto.strong,
            list_model: dto.list_model,
            list_model_displayed_field: dto.list_model_displayed_field.clone(),
            enum_name: dto.enum_name.clone(),
            enum_values: dto.enum_values.clone(),
        }
    }
}

impl From<Field> for CreateFieldDto {
    fn from(entity: Field) -> Self {
        CreateFieldDto {
            name: entity.name,
            field_type: entity.field_type,
            entity: entity.entity,
            relationship: entity.relationship,
            optional: entity.optional,
            strong: entity.strong,
            list_model: entity.list_model,
            list_model_displayed_field: entity.list_model_displayed_field,
            enum_name: entity.enum_name,
            enum_values: entity.enum_values,
        }
    }
}

pub use common::direct_access::field::FieldRelationshipField;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FieldRelationshipDto {
    pub id: EntityId,
    pub field: FieldRelationshipField,
    pub right_ids: Vec<EntityId>,
}
