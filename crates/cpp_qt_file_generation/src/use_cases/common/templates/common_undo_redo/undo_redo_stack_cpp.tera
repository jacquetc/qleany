#include "undo_redo_stack.h"
#include <QRecursiveMutex>

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

UndoRedoStack::UndoRedoStack(QObject *parent) : QObject(parent)
{
}

void UndoRedoStack::push(std::shared_ptr<UndoRedoCommand> command)
{
    if (!command)
    {
        return;
    }

    QMutexLocker locker(&m_mutex);

    // Clear redo stack when pushing a new command
    m_redoStack.clear();

    // Try to merge with the top command if possible
    if (!m_undoStack.isEmpty())
    {
        auto topCommand = m_undoStack.top();
        if (topCommand->canMergeWith(command))
        {
            topCommand->mergeWith(command);
            updateState(); // Update to reflect the merged command text
            return;
        }
    }

    // If merging is not possible, push the new command
    m_undoStack.push(command);

    // Enforce stack size limit if set
    if (m_maxStackSize > 0 && m_undoStack.size() > m_maxStackSize)
    {
        m_undoStack.removeFirst();
    }

    // Perform auto-cleanup if enabled (remove old commands beyond a reasonable limit)
    if (m_autoCleanupEnabled && m_undoStack.size() > 100)
    { // Default cleanup at 100 commands
        while (m_undoStack.size() > 50)
        { // Keep last 50 commands
            m_undoStack.removeFirst();
        }
    }

    updateState();
}

bool UndoRedoStack::canUndo() const
{
    QMutexLocker locker(&m_mutex);
    return !m_undoStack.isEmpty();
}

bool UndoRedoStack::canRedo() const
{
    QMutexLocker locker(&m_mutex);
    return !m_redoStack.isEmpty();
}
void UndoRedoStack::execute()
{
    QMutexLocker locker(&m_mutex);

    if (m_undoStack.isEmpty())
    {
        return;
    }

    auto command = m_undoStack.top();
    m_currentCommand = command;

    // Connect to command finished signal
    connect(command.get(), &UndoRedoCommand::finished, this, &UndoRedoStack::onCommandFinished, Qt::UniqueConnection);

    updateState();

    // Execute the command asynchronously (for newly pushed commands)
    command->asyncExecute();
}

void UndoRedoStack::undo()
{
    QMutexLocker locker(&m_mutex);

    if (m_undoStack.isEmpty())
    {
        return;
    }

    auto command = m_undoStack.pop();
    m_redoStack.push(command);
    m_currentCommand = command;

    // Connect to command finished signal
    connect(command.get(), &UndoRedoCommand::finished, this, &UndoRedoStack::onCommandFinished, Qt::UniqueConnection);

    updateState();

    // Execute undo asynchronously
    command->asyncUndo();
}

void UndoRedoStack::redo()
{
    QMutexLocker locker(&m_mutex);

    if (m_redoStack.isEmpty())
    {
        return;
    }

    auto command = m_redoStack.pop();
    m_undoStack.push(command);
    m_currentCommand = command;

    // Connect to command finished signal
    connect(command.get(), &UndoRedoCommand::finished, this, &UndoRedoStack::onCommandFinished, Qt::UniqueConnection);

    updateState();

    // Execute redo asynchronously
    command->asyncRedo();
}

void UndoRedoStack::clear()
{
    QMutexLocker locker(&m_mutex);

    m_undoStack.clear();
    m_redoStack.clear();
    m_currentCommand.reset();

    updateState();
}

int UndoRedoStack::undoCount() const
{
    QMutexLocker locker(&m_mutex);
    return m_undoStack.size();
}

int UndoRedoStack::redoCount() const
{
    QMutexLocker locker(&m_mutex);
    return m_redoStack.size();
}

QString UndoRedoStack::undoText() const
{
    QMutexLocker locker(&m_mutex);

    if (m_undoStack.isEmpty())
    {
        return QString();
    }

    return m_undoStack.top()->text();
}

QString UndoRedoStack::redoText() const
{
    QMutexLocker locker(&m_mutex);

    if (m_redoStack.isEmpty())
    {
        return QString();
    }

    return m_redoStack.top()->text();
}

void UndoRedoStack::setMaxStackSize(int maxSize)
{
    QMutexLocker locker(&m_mutex);
    m_maxStackSize = maxSize;

    // Apply stack size limit immediately if enabled
    if (m_maxStackSize > 0)
    {
        while (m_undoStack.size() > m_maxStackSize)
        {
            m_undoStack.removeFirst();
        }
        updateState();
    }
}

int UndoRedoStack::maxStackSize() const
{
    QMutexLocker locker(&m_mutex);
    return m_maxStackSize;
}

void UndoRedoStack::setAutoCleanupEnabled(bool enabled)
{
    QMutexLocker locker(&m_mutex);
    m_autoCleanupEnabled = enabled;
}

bool UndoRedoStack::isAutoCleanupEnabled() const
{
    QMutexLocker locker(&m_mutex);
    return m_autoCleanupEnabled;
}

void UndoRedoStack::onCommandFinished(bool success)
{
    m_currentCommand.reset();
    Q_EMIT commandFinished(success);
}

void UndoRedoStack::updateState()
{
    // This method assumes mutex is already locked
    Q_EMIT canUndoChanged(!m_undoStack.isEmpty());
    Q_EMIT canRedoChanged(!m_redoStack.isEmpty());

    QString undoText = m_undoStack.isEmpty() ? QString() : m_undoStack.top()->text();
    QString redoText = m_redoStack.isEmpty() ? QString() : m_redoStack.top()->text();

    Q_EMIT undoTextChanged(undoText);
    Q_EMIT redoTextChanged(redoText);
}

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo