#include "group_command.h"
#include <QDebug>

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

GroupCommand::GroupCommand(const QString &text, QObject *parent)
    : UndoRedoCommand(text, parent), m_currentCommandIndex(-1), m_executionInProgress(false), m_successfulCommands(0)
{
}

void GroupCommand::addCommand(std::shared_ptr<UndoRedoCommand> command)
{
    if (command && !m_executionInProgress)
    {
        m_commands.append(command);
    }
}

void GroupCommand::insertCommand(int index, std::shared_ptr<UndoRedoCommand> command)
{
    if (command && !m_executionInProgress && index >= 0 && index <= m_commands.size())
    {
        m_commands.insert(index, command);
    }
}

void GroupCommand::removeCommand(int index)
{
    if (!m_executionInProgress && index >= 0 && index < m_commands.size())
    {
        m_commands.removeAt(index);
    }
}

void GroupCommand::clearCommands()
{
    if (!m_executionInProgress)
    {
        m_commands.clear();
    }
}

int GroupCommand::commandCount() const
{
    return m_commands.size();
}

std::shared_ptr<UndoRedoCommand> GroupCommand::command(int index) const
{
    if (index >= 0 && index < m_commands.size())
    {
        return m_commands.at(index);
    }
    return nullptr;
}

QList<std::shared_ptr<UndoRedoCommand>> GroupCommand::commands() const
{
    return m_commands;
}

void GroupCommand::setFailureStrategy(FailureStrategy strategy)
{
    if (!m_executionInProgress)
    {
        m_failureStrategy = strategy;
    }
}

FailureStrategy GroupCommand::failureStrategy() const
{
    return m_failureStrategy;
}
void GroupCommand::asyncExecute()
{
    m_executionState = ExecutionState::Executing;
    m_executionInProgress = true;
    m_currentCommandIndex = 0; // Start from first command for execute
    m_successfulCommands = 0;

    executeNextExecuteCommand();
}

void GroupCommand::asyncUndo()
{
    if (m_executionInProgress || m_commands.isEmpty())
    {
        Q_EMIT finished(m_commands.isEmpty());
        return;
    }

    m_executionState = ExecutionState::Undoing;
    m_executionInProgress = true;
    m_currentCommandIndex = m_commands.size() - 1; // Start from last command for undo
    m_successfulCommands = 0;

    executeNextUndoCommand();
}

void GroupCommand::asyncRedo()
{
    if (m_executionInProgress || m_commands.isEmpty())
    {
        Q_EMIT finished(m_commands.isEmpty());
        return;
    }

    m_executionState = ExecutionState::Redoing;
    m_executionInProgress = true;
    m_currentCommandIndex = 0; // Start from first command for redo
    m_successfulCommands = 0;

    executeNextRedoCommand();
}

void GroupCommand::onChildCommandFinished(bool success)
{
    // Disconnect from the finished command
    auto *command = qobject_cast<UndoRedoCommand *>(sender());
    if (command)
    {
        disconnect(command, &UndoRedoCommand::finished, this, &GroupCommand::onChildCommandFinished);
    }

    if (success)
    {
        m_successfulCommands++;
    }
    switch (m_executionState)
    {
    case ExecutionState::Executing:
        if (success && m_currentCommandIndex < m_commands.size() - 1)
        {
            m_currentCommandIndex++;
            executeNextExecuteCommand();
        }
        else if (!success && m_failureStrategy == FailureStrategy::ContinueOnFailure &&
                 m_currentCommandIndex < m_commands.size() - 1)
        {
            // Continue to next command despite failure
            m_currentCommandIndex++;
            executeNextExecuteCommand();
        }
        else
        {
            // Finished or failed
            finishExecution(success);
        }

        break;
    case ExecutionState::Undoing:
        if (success && m_currentCommandIndex > 0)
        {
            m_currentCommandIndex--;
            executeNextUndoCommand();
        }
        else
        {
            // Finished or failed
            finishExecution(success);
        }

        break;
    case ExecutionState::Redoing:

        if (success && m_currentCommandIndex < m_commands.size() - 1)
        {
            m_currentCommandIndex++;
            executeNextRedoCommand();
        }
        else
        {
            // Finished or failed
            finishExecution(success);
        }
        break;

    case ExecutionState::RollingBack:
        // We're rolling back - continue in reverse order until we reach target
        // For RollbackAll: target is -1, meaning we go all the way to index 0
        // For RollbackPartial: target equals the index we started at, so we stop after one
        if (m_currentCommandIndex > 0 && m_currentCommandIndex - 1 >= m_rollbackTargetIndex &&
            m_rollbackTargetIndex != m_currentCommandIndex)
        {
            m_currentCommandIndex--;
            executeNextRollbackCommand();
        }
        else
        {
            // Rollback complete, finish with failure status
            finishExecution(false);
        }
        break;

    default:
        qCritical() << "GroupCommand::onChildCommandFinished: Unknown execution state.";
        break;
    }
}

void GroupCommand::executeNextExecuteCommand()
{
    if (m_currentCommandIndex >= 0 && m_currentCommandIndex < m_commands.size())
    {
        auto command = m_commands.at(m_currentCommandIndex);
        connect(command.get(), &UndoRedoCommand::finished, this, &GroupCommand::onChildCommandFinished,
                Qt::UniqueConnection);
        command->asyncExecute();
    }
    else
    {
        finishExecution(false);
    }
}

void GroupCommand::executeNextRedoCommand()
{
    if (m_currentCommandIndex >= 0 && m_currentCommandIndex < m_commands.size())
    {
        auto command = m_commands.at(m_currentCommandIndex);
        connect(command.get(), &UndoRedoCommand::finished, this, &GroupCommand::onChildCommandFinished,
                Qt::UniqueConnection);
        command->asyncRedo();
    }
    else
    {
        finishExecution(false);
    }
}

void GroupCommand::executeNextUndoCommand()
{
    if (m_currentCommandIndex >= 0 && m_currentCommandIndex < m_commands.size())
    {
        auto command = m_commands.at(m_currentCommandIndex);
        connect(command.get(), &UndoRedoCommand::finished, this, &GroupCommand::onChildCommandFinished,
                Qt::UniqueConnection);
        command->asyncUndo();
    }
    else
    {
        finishExecution(false);
    }
}

void GroupCommand::finishExecution(bool success)
{
    // Consider success if we executed all commands successfully
    bool allSuccess = success && (m_successfulCommands == m_commands.size());

    // Handle cleanup strategy for failed executions
    if (!allSuccess && !m_hadFailure)
    {
        m_hadFailure = true;
        handleFailureCleanup();
        // If rollback was started, don't emit finished yet - wait for rollback to complete
        if (m_executionState == ExecutionState::RollingBack)
        {
            return;
        }
    }

    m_executionInProgress = false;
    m_currentCommandIndex = -1;
    m_rollbackTargetIndex = -1;
    m_hadFailure = false;
    Q_EMIT finished(allSuccess);
}

void GroupCommand::handleFailureCleanup()
{
    switch (m_failureStrategy)
    {
    case FailureStrategy::StopOnFailure:
        // Default behavior: just stop, no additional cleanup needed
        break;

    case FailureStrategy::ContinueOnFailure:
        // Continue with remaining commands (handled in onChildCommandFinished)
        break;

    case FailureStrategy::RollbackAll:
        // Rollback all successfully executed commands in reverse order
        if (m_successfulCommands > 0)
        {
            startRollback(m_successfulCommands - 1);
        }
        break;

    case FailureStrategy::RollbackPartial:
        // Only rollback the failed command (which may have partially executed)
        // Unlike RollbackAll, successful commands remain intact
        if (m_currentCommandIndex >= 0 && m_currentCommandIndex < m_commands.size())
        {
            // Set target to current index so we only undo this one command
            startRollback(m_currentCommandIndex);
            m_rollbackTargetIndex = m_currentCommandIndex; // Stop after this one
        }
        break;
    }
}

void GroupCommand::startRollback(int fromIndex)
{
    if (fromIndex < 0 || fromIndex >= m_commands.size())
    {
        return;
    }

    m_executionState = ExecutionState::RollingBack;
    m_currentCommandIndex = fromIndex;
    m_rollbackTargetIndex = -1; // Default: rollback all the way to index 0

    executeNextRollbackCommand();
}

void GroupCommand::executeNextRollbackCommand()
{
    if (m_currentCommandIndex >= 0 && m_currentCommandIndex < m_commands.size())
    {
        auto command = m_commands.at(m_currentCommandIndex);
        connect(command.get(), &UndoRedoCommand::finished, this, &GroupCommand::onChildCommandFinished,
                Qt::UniqueConnection);
        command->asyncUndo();
    }
    else
    {
        // Rollback complete, now finish with failure status
        finishExecution(false);
    }
}

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo