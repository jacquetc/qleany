#include "undo_redo_manager.h"
#include <QMutexLocker>

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

UndoRedoManager::UndoRedoManager(QObject *parent) : QObject(parent), m_currentStackId(0), m_nextStackId(1)
{
}

int UndoRedoManager::createStack()
{
    QMutexLocker locker(&m_mutex);
    int newStackId = m_nextStackId++;
    getOrCreateStack(newStackId);
    return newStackId;
}

void UndoRedoManager::removeStack(int stackId)
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    if (it != m_stacks.end())
    {
        it.value()->clear();
        m_stacks.erase(it);

        if (stackId == m_currentStackId)
        {
            updateCurrentStackSignals();
        }
    }
}

void UndoRedoManager::setCurrentStackId(int stackId)
{
    QMutexLocker locker(&m_mutex);

    if (m_currentStackId == stackId)
    {
        return;
    }

    m_currentStackId = stackId;
    updateCurrentStackSignals();
    Q_EMIT currentStackIdChanged(stackId);
}

int UndoRedoManager::currentStackId() const
{
    QMutexLocker locker(&m_mutex);
    return m_currentStackId;
}

void UndoRedoManager::pushCommand(std::shared_ptr<UndoRedoCommand> command)
{
    QMutexLocker locker(&m_mutex);
    if (!command)
    {
        return;
    }

    auto *stack = getOrCreateStack(m_currentStackId);
    stack->push(command);
}

void UndoRedoManager::pushCommand(std::shared_ptr<UndoRedoCommand> command, int stackId)
{
    if (!command)
    {
        return;
    }

    QMutexLocker locker(&m_mutex);
    auto *stack = getOrCreateStack(stackId);
    stack->push(command);
}

bool UndoRedoManager::canUndo() const
{
    QMutexLocker locker(&m_mutex);
    return canUndo(m_currentStackId);
}

bool UndoRedoManager::canRedo() const
{
    QMutexLocker locker(&m_mutex);
    return canRedo(m_currentStackId);
}

void UndoRedoManager::execute()
{
    QMutexLocker locker(&m_mutex);
    execute(m_currentStackId);
}

void UndoRedoManager::undo()
{
    QMutexLocker locker(&m_mutex);
    undo(m_currentStackId);
}

void UndoRedoManager::redo()
{
    QMutexLocker locker(&m_mutex);
    redo(m_currentStackId);
}

QString UndoRedoManager::undoText() const
{
    QMutexLocker locker(&m_mutex);
    return undoText(m_currentStackId);
}

QString UndoRedoManager::redoText() const
{
    QMutexLocker locker(&m_mutex);
    return redoText(m_currentStackId);
}

bool UndoRedoManager::canUndo(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->canUndo() : false;
}

bool UndoRedoManager::canRedo(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->canRedo() : false;
}

void UndoRedoManager::execute(int stackId)
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    if (it != m_stacks.end())
    {
        it.value()->execute();
    }
}

void UndoRedoManager::undo(int stackId)
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    if (it != m_stacks.end())
    {
        it.value()->undo();
    }
}

void UndoRedoManager::redo(int stackId)
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    if (it != m_stacks.end())
    {
        it.value()->redo();
    }
}

QString UndoRedoManager::undoText(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->undoText() : QString();
}

QString UndoRedoManager::redoText(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->redoText() : QString();
}

void UndoRedoManager::clearStack(int stackId)
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    if (it != m_stacks.end())
    {
        it.value()->clear();
        m_stacks.erase(it);

        if (stackId == m_currentStackId)
        {
            updateCurrentStackSignals();
        }
    }
}

void UndoRedoManager::clearAllStacks()
{
    QMutexLocker locker(&m_mutex);
    m_stacks.clear();
    updateCurrentStackSignals();
}

QList<int> UndoRedoManager::activeStackIds() const
{
    QMutexLocker locker(&m_mutex);
    return m_stacks.keys();
}

int UndoRedoManager::undoCount(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->undoCount() : 0;
}

int UndoRedoManager::redoCount(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->redoCount() : 0;
}

void UndoRedoManager::setMaxStackSize(int maxSize)
{
    QMutexLocker locker(&m_mutex);
    setMaxStackSize(m_currentStackId, maxSize);
}

int UndoRedoManager::maxStackSize() const
{
    QMutexLocker locker(&m_mutex);
    return maxStackSize(m_currentStackId);
}

void UndoRedoManager::setAutoCleanupEnabled(bool enabled)
{
    QMutexLocker locker(&m_mutex);
    setAutoCleanupEnabled(m_currentStackId, enabled);
}

bool UndoRedoManager::isAutoCleanupEnabled() const
{
    QMutexLocker locker(&m_mutex);
    return isAutoCleanupEnabled(m_currentStackId);
}

void UndoRedoManager::setMaxStackSize(int stackId, int maxSize)
{
    QMutexLocker locker(&m_mutex);
    auto *stack = getOrCreateStack(stackId);
    stack->setMaxStackSize(maxSize);
}

int UndoRedoManager::maxStackSize(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->maxStackSize() : -1;
}

void UndoRedoManager::setAutoCleanupEnabled(int stackId, bool enabled)
{
    QMutexLocker locker(&m_mutex);
    auto *stack = getOrCreateStack(stackId);
    stack->setAutoCleanupEnabled(enabled);
}

bool UndoRedoManager::isAutoCleanupEnabled(int stackId) const
{
    QMutexLocker locker(&m_mutex);
    auto it = m_stacks.find(stackId);
    return it != m_stacks.end() ? it.value()->isAutoCleanupEnabled() : false;
}

void UndoRedoManager::cancelAllCommands()
{
    QMutexLocker locker(&m_mutex);

    // Cancel all running commands in all stacks
    for (auto it = m_stacks.begin(); it != m_stacks.end(); ++it)
    {
        auto stack = it.value();
        if (stack && stack->m_currentCommand)
        {
            // Cancel the currently executing command
            stack->m_currentCommand->cancel();
            // Clear the current command reference
            stack->m_currentCommand.reset();
        }

        // Clear both undo and redo stacks
        stack->clear();
    }
}

void UndoRedoManager::onStackCanUndoChanged(bool canUndo)
{
    auto *stack = qobject_cast<UndoRedoStack *>(sender());
    if (!stack)
        return;

    QMutexLocker locker(&m_mutex);
    for (auto it = m_stacks.begin(); it != m_stacks.end(); ++it)
    {
        if (it.value().get() == stack && it.key() == m_currentStackId)
        {
            Q_EMIT canUndoChanged(canUndo);
            break;
        }
    }
}

void UndoRedoManager::onStackCanRedoChanged(bool canRedo)
{
    auto *stack = qobject_cast<UndoRedoStack *>(sender());
    if (!stack)
        return;

    QMutexLocker locker(&m_mutex);
    for (auto it = m_stacks.begin(); it != m_stacks.end(); ++it)
    {
        if (it.value().get() == stack && it.key() == m_currentStackId)
        {
            Q_EMIT canRedoChanged(canRedo);
            break;
        }
    }
}

void UndoRedoManager::onStackUndoTextChanged(const QString &undoText)
{
    auto *stack = qobject_cast<UndoRedoStack *>(sender());
    if (!stack)
        return;

    QMutexLocker locker(&m_mutex);
    for (auto it = m_stacks.begin(); it != m_stacks.end(); ++it)
    {
        if (it.value().get() == stack && it.key() == m_currentStackId)
        {
            Q_EMIT undoTextChanged(undoText);
            break;
        }
    }
}

void UndoRedoManager::onStackRedoTextChanged(const QString &redoText)
{
    auto *stack = qobject_cast<UndoRedoStack *>(sender());
    if (!stack)
        return;

    QMutexLocker locker(&m_mutex);
    for (auto it = m_stacks.begin(); it != m_stacks.end(); ++it)
    {
        if (it.value().get() == stack && it.key() == m_currentStackId)
        {
            Q_EMIT redoTextChanged(redoText);
            break;
        }
    }
}

void UndoRedoManager::onStackCommandFinished(bool success)
{
    Q_EMIT commandFinished(success);
}

UndoRedoStack *UndoRedoManager::getOrCreateStack(int stackId)
{
    // Assumes mutex is already locked
    auto it = m_stacks.find(stackId);
    if (it == m_stacks.end())
    {
        auto stack = std::make_shared<UndoRedoStack>(this);
        connectStackSignals(stack.get());
        m_stacks[stackId] = stack;
        return stack.get();
    }
    return it.value().get();
}

void UndoRedoManager::connectStackSignals(UndoRedoStack *stack)
{
    connect(stack, &UndoRedoStack::canUndoChanged, this, &UndoRedoManager::onStackCanUndoChanged, Qt::QueuedConnection);
    connect(stack, &UndoRedoStack::canRedoChanged, this, &UndoRedoManager::onStackCanRedoChanged, Qt::QueuedConnection);
    connect(stack, &UndoRedoStack::undoTextChanged, this, &UndoRedoManager::onStackUndoTextChanged,
            Qt::QueuedConnection);
    connect(stack, &UndoRedoStack::redoTextChanged, this, &UndoRedoManager::onStackRedoTextChanged,
            Qt::QueuedConnection);
    connect(stack, &UndoRedoStack::commandFinished, this, &UndoRedoManager::onStackCommandFinished,
            Qt::QueuedConnection);
}

void UndoRedoManager::updateCurrentStackSignals()
{
    // Assumes mutex is already locked
    auto it = m_stacks.find(m_currentStackId);
    if (it != m_stacks.end())
    {
        Q_EMIT canUndoChanged(it.value()->canUndo());
        Q_EMIT canRedoChanged(it.value()->canRedo());
        Q_EMIT undoTextChanged(it.value()->undoText());
        Q_EMIT redoTextChanged(it.value()->redoText());
    }
    else
    {
        Q_EMIT canUndoChanged(false);
        Q_EMIT canRedoChanged(false);
        Q_EMIT undoTextChanged(QString());
        Q_EMIT redoTextChanged(QString());
    }
}

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
