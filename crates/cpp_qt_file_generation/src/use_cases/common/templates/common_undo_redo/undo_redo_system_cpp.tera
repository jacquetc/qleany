#include "undo_redo_system.h"
#include <QCoro/QCoroSignal>
#include <QElapsedTimer>
#include <QScopeGuard>
#include <QThread>
#include <atomic>

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

UndoRedoSystem::UndoRedoSystem(QObject *parent)
    : QObject(parent), m_manager(std::make_unique<UndoRedoManager>(this)),
      m_queryHandler(std::make_unique<QueryHandler>(this))
{
    // Connect signals for forwarding
    connect(m_manager.get(), &UndoRedoManager::commandFinished, this,
            [this](bool success) { Q_EMIT commandExecuted(m_manager->currentStackId(), success); });
    connect(m_queryHandler.get(), &QueryHandler::queryFinished, this, &UndoRedoSystem::onQueryFinished);
}

UndoRedoManager *UndoRedoSystem::manager() const
{
    return m_manager.get();
}

QueryHandler *UndoRedoSystem::queryHandler() const
{
    return m_queryHandler.get();
}

/** DO NOT USE THIS METHOD ! Use executeCommandAsync instead. This Undo Redo system is async by nature.
 *
 * @param command
 * @param stackId
 */
void UndoRedoSystem::executeCommand(std::shared_ptr<UndoRedoCommand> command, int stackId)
{
    m_manager->pushCommand(command, stackId);
    m_manager->execute(stackId);
}

/** DO NOT USE THIS METHOD ! Use executeQueryAsync instead. This Undo Redo system is async by nature.
 *
 * @param query
 */
void UndoRedoSystem::executeQuery(std::shared_ptr<QueryBase> query)
{
    m_queryHandler->executeQuery(query);
}

void UndoRedoSystem::setMaxStackSize(int maxSize)
{
    m_manager->setMaxStackSize(maxSize);
}

int UndoRedoSystem::maxStackSize() const
{
    return m_manager->maxStackSize();
}

void UndoRedoSystem::setAutoCleanupEnabled(bool enabled)
{
    m_manager->setAutoCleanupEnabled(enabled);
}

bool UndoRedoSystem::isAutoCleanupEnabled() const
{
    return m_manager->isAutoCleanupEnabled();
}

void UndoRedoSystem::shutdown()
{
    qDebug() << "UndoRedoSystem: Starting graceful shutdown. Active operations:" << m_activeOperations.load();

    // Step 1: Block all new queries and commands
    m_isShuttingDown = true;

    // Step 2: Clear all undo/redo stacks to release stored commands and their database connections
    if (m_manager)
    {
        m_manager->clearAllStacks();
        qDebug() << "UndoRedoSystem: Cleared all undo/redo stacks";
    }

    // Step 3: Wait for active operations to complete (if any)
    if (m_activeOperations.load() == 0)
    {
        qDebug() << "UndoRedoSystem: No active operations, shutdown complete.";
        return;
    }

    // Wait for existing operations with detailed progress
    const int maxWaitTime = 2000;
    const int pollInterval = 100;
    int elapsed = 0;
    int lastOperationCount = m_activeOperations.load();

    qDebug() << "UndoRedoSystem: Waiting for" << lastOperationCount << "operations to complete...";

    while (m_activeOperations.load() > 0 && elapsed < maxWaitTime)
    {
        QThread::msleep(pollInterval);
        elapsed += pollInterval;

        int currentCount = m_activeOperations.load();
        if (currentCount != lastOperationCount)
        {
            qDebug() << "UndoRedoSystem: Operations remaining:" << currentCount << "("
                     << (lastOperationCount - currentCount) << "completed)";
            lastOperationCount = currentCount;
        }
    }

    if (m_activeOperations.load() > 0)
    {
        qWarning() << "UndoRedoSystem: Timeout after" << elapsed << "ms. Forcefully cancelling"
                   << m_activeOperations.load() << "remaining operations.";

        // Brutal cancellation
        if (m_queryHandler)
        {
            m_queryHandler->cancelAllQueries();
        }
        if (m_manager)
        {
            m_manager->cancelAllCommands();
        }
    }
    else
    {
        qDebug() << "UndoRedoSystem: All operations completed gracefully in" << elapsed << "ms.";
    }
}

QCoro::Task<std::optional<bool>> UndoRedoSystem::executeCommandAsync(std::shared_ptr<UndoRedoCommand> command,
                                                                     int millisecondsTimeout, int stackId)

{
    // Check if shutting down - block new commands
    if (m_isShuttingDown.load())
    {
        qDebug() << "UndoRedoSystem: Rejecting new command during shutdown:" << command->text();
        co_return false;
    }

    if (!command)
    {
        co_return false;
    }

    // Increment active operations counter
    ++m_activeOperations;

    // Ensure we decrement the counter when done
    auto decrementOnExit = qScopeGuard([this]() { --m_activeOperations; });

    // ... rest of the existing method implementation stays the same until the end

    // ensure millisecondsTimeout range between 1 and 20000 ms
    if (millisecondsTimeout < 1)
    {
        millisecondsTimeout = 1;
    }
    else if (millisecondsTimeout > 20000)
    {
        millisecondsTimeout = 20000;
    }

    // Start timing for performance monitoring
    QElapsedTimer timer;
    timer.start();

    m_manager->pushCommand(command, stackId);

    // Emit stack size change signal
    Q_EMIT stackSizeChanged(stackId, m_manager->undoCount(stackId), m_manager->redoCount(stackId));

    m_manager->execute(stackId);

    // Wait for the specific command to finish using QCoro
    auto success =
        co_await qCoro(command.get(), &UndoRedoCommand::finished, std::chrono::milliseconds(millisecondsTimeout));

    // Emit execution time signal
    qint64 executionTime = timer.elapsed();
    Q_EMIT commandExecutionTime(command->text(), executionTime);

    if (!success)
    {
        qWarning() << "Timeout reached while waiting for command to finish:" << command->text();
        qDebug() << "The command could not be completed in the allotted time.";
    }

    // decrementOnExit will automatically decrement m_activeOperations
    co_return success;
}

void UndoRedoSystem::onCommandFinished(int stackId, bool success)
{
    Q_EMIT commandExecuted(stackId, success);
}

void UndoRedoSystem::onQueryFinished(std::shared_ptr<QueryBase> query, bool success)
{
    Q_EMIT queryExecuted(query, success);
}

void UndoRedoSystem::onCommandFinishedWithResult(int stackId, const Result<void> &result)
{
    Q_EMIT commandExecutedWithResult(stackId, result);

    if (!result.isSuccess())
    {
        Q_EMIT commandErrorOccurred(stackId, result.error(), result.category(), result.severity());
    }
}

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
