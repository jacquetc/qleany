#pragma once

#include "undo_redo_command.h"
#include <QList>
#include <QObject>
#include <memory>

using namespace Qt::StringLiterals;

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

enum class FailureStrategy
{
    ContinueOnFailure, // Continue executing remaining commands even if one fails
    StopOnFailure,     // Stop execution on first failure (default behavior)
    RollbackAll,       // Rollback all successfully executed commands on any failure
    RollbackPartial    // Rollback only the partially executed commands
};

class GroupCommand : public UndoRedoCommand
{
    Q_OBJECT

  public:
    explicit GroupCommand(const QString &text, QObject *parent = nullptr);

    void addCommand(std::shared_ptr<UndoRedoCommand> command);
    void insertCommand(int index, std::shared_ptr<UndoRedoCommand> command);
    void removeCommand(int index);
    void clearCommands();

    int commandCount() const;
    std::shared_ptr<UndoRedoCommand> command(int index) const;
    QList<std::shared_ptr<UndoRedoCommand>> commands() const;

    // Failure strategy
    void setFailureStrategy(FailureStrategy strategy);
    FailureStrategy failureStrategy() const;

    // Override base class methods
    void asyncExecute() override;
    void asyncUndo() override;
    void asyncRedo() override;

  private Q_SLOTS:
    void onChildCommandFinished(bool success);

  private:
    enum class ExecutionState
    {
        Idle,
        Executing,
        Undoing,
        Redoing,
        RollingBack
    };

    void executeNextExecuteCommand();
    void executeNextRedoCommand();
    void executeNextUndoCommand();
    void executeNextRollbackCommand();
    void finishExecution(bool success);
    void handleFailureCleanup();
    void startRollback(int fromIndex);

    QList<std::shared_ptr<UndoRedoCommand>> m_commands;
    int m_currentCommandIndex;
    bool m_executionInProgress;
    int m_successfulCommands;
    int m_rollbackTargetIndex = -1; // Target index to rollback to (-1 = rollback all successful, else specific index)
    bool m_hadFailure = false;      // Track if we had a failure that triggered rollback
    ExecutionState m_executionState = ExecutionState::Idle;
    FailureStrategy m_failureStrategy = FailureStrategy::StopOnFailure;
};

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
