#pragma once

#include <QFutureWatcher>
#include <QObject>
#include <QPromise>
#include <QString>
#include <QVariant>
#include <QDateTime>
#include <QElapsedTimer>
#include <functional>
#include <memory>

using namespace Qt::StringLiterals;

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

enum class ErrorCategory
{
    None,
    ValidationError,
    ExecutionError,
    DatabaseError,
    NetworkError,
    TimeoutError,
    PermissionError,
    SystemError,
    UserCancelledError,
    UnknownError
};

enum class ErrorSeverity
{
    Info,
    Warning,
    Error,
    Critical,
    Fatal
};

template <typename T> class Result
{
  public:
    Result() : m_success(true), m_category(ErrorCategory::None), m_severity(ErrorSeverity::Info),
               m_errorCode(0), m_timestamp(QDateTime::currentDateTimeUtc())
    {
    }

    explicit Result(const QString &error, ErrorCategory category = ErrorCategory::UnknownError,
                    const QVariant &errorData = QVariant(), ErrorSeverity severity = ErrorSeverity::Error,
                    int errorCode = 0, const QString &context = QString(), const QString &sourceLocation = QString())
        : m_success(false), m_error(error), m_category(category), m_errorData(errorData),
          m_severity(severity), m_errorCode(errorCode), m_context(context),
          m_sourceLocation(sourceLocation), m_timestamp(QDateTime::currentDateTimeUtc())
    {
    }

    [[nodiscard]] bool isSuccess() const { return m_success; }
    [[nodiscard]] QString error() const { return m_error; }
    [[nodiscard]] ErrorCategory category() const { return m_category; }
    [[nodiscard]] QVariant errorData() const { return m_errorData; }
    [[nodiscard]] ErrorSeverity severity() const { return m_severity; }
    [[nodiscard]] int errorCode() const { return m_errorCode; }
    [[nodiscard]] QString context() const { return m_context; }
    [[nodiscard]] QString sourceLocation() const { return m_sourceLocation; }
    [[nodiscard]] QDateTime timestamp() const { return m_timestamp; }
    [[nodiscard]] qint64 executionTimeMs() const { return m_executionTimeMs; }

    void setExecutionTime(qint64 milliseconds) { m_executionTimeMs = milliseconds; }
    void setSeverity(ErrorSeverity severity) { m_severity = severity; }
    void setContext(const QString &context) { m_context = context; }
    void setSourceLocation(const QString &sourceLocation) { m_sourceLocation = sourceLocation; }

    /// Detailed error description including context, code, location and duration.
    [[nodiscard]] QString detailedError() const
    {
        if (m_success) return "Success"_L1;

        QString details = m_error;
        if (!m_context.isEmpty()) details += QString(" [Context: %1]").arg(m_context);
        if (m_errorCode != 0) details += QString(" [Code: %1]").arg(m_errorCode);
        if (!m_sourceLocation.isEmpty()) details += QString(" [Location: %1]").arg(m_sourceLocation);
        if (m_executionTimeMs > 0) details += QString(" [Duration: %1ms]").arg(m_executionTimeMs);
        return details;
    }

  private:
    bool m_success;
    QString m_error;
    ErrorCategory m_category;
    QVariant m_errorData;
    ErrorSeverity m_severity;
    int m_errorCode;
    QString m_context;
    QString m_sourceLocation;
    QDateTime m_timestamp;
    qint64 m_executionTimeMs = 0;
};

class UndoRedoCommand : public QObject
{
    Q_OBJECT

  public:
    explicit UndoRedoCommand(const QString &text, QObject *parent = nullptr);

    void setExecuteFunction(const std::function<void(QPromise<Result<void>> &promise)> &function);
    void setUndoFunction(const std::function<Result<void>()> &function);
    void setRedoFunction(const std::function<Result<void>()> &function);

    virtual void asyncExecute();
    virtual void asyncUndo();
    virtual void asyncRedo();

    /// Command merging support
    [[nodiscard]] virtual bool canMergeWith(const std::shared_ptr<UndoRedoCommand> &other) const;
    virtual void mergeWith(const std::shared_ptr<UndoRedoCommand> &other);

    [[nodiscard]] QString text() const;
    void setText(const QString &newText);

    /// Cancel any running async operations
    void cancel();

  Q_SIGNALS:
    void finished(bool isSuccessful);
    void finishedWithResult(const Result<void> &result);

  private Q_SLOTS:
    void onExecuteFinished();
    void onUndoFinished();
    void onRedoFinished();

  private:
    QString m_text;
    bool m_wasAlreadyExecuted = false;
    std::function<void(QPromise<Result<void>> &promise)> m_executeFunction;
    std::function<Result<void>()> m_undoFunction;
    std::function<Result<void>()> m_redoFunction;
    QFutureWatcher<Result<void>> *m_executeWatcher;
    QFutureWatcher<Result<void>> *m_redoWatcher;
    QFutureWatcher<Result<void>> *m_undoWatcher;
};

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
