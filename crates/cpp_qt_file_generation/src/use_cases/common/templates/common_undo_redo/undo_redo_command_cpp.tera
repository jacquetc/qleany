#include "undo_redo_command.h"
#include <QDebug>
#include <QFutureWatcher>
#include <QPointer>
#include <QtConcurrent/QtConcurrentRun>

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

UndoRedoCommand::UndoRedoCommand(const QString &text, QObject *parent)
    : QObject(parent), m_text(text), m_executeWatcher(new QFutureWatcher<Result<void>>(this)),
      m_redoWatcher(new QFutureWatcher<Result<void>>(this)), m_undoWatcher(new QFutureWatcher<Result<void>>(this))
{
    connect(m_executeWatcher, &QFutureWatcher<Result<void>>::finished, this, &UndoRedoCommand::onExecuteFinished);
    connect(m_redoWatcher, &QFutureWatcher<Result<void>>::finished, this, &UndoRedoCommand::onRedoFinished);
    connect(m_undoWatcher, &QFutureWatcher<Result<void>>::finished, this, &UndoRedoCommand::onUndoFinished);
}

void UndoRedoCommand::setExecuteFunction(const std::function<void(QPromise<Result<void>> &promise)> &function)
{
    m_executeFunction = function;
}

void UndoRedoCommand::setUndoFunction(const std::function<Result<void>()> &function)
{
    m_undoFunction = function;
}

void UndoRedoCommand::setRedoFunction(const std::function<Result<void>()> &function)
{
    m_redoFunction = function;
}

void UndoRedoCommand::asyncExecute()
{
    if (m_wasAlreadyExecuted)
    {
        qCritical() << "Command already executed, calling redo instead.";
        asyncRedo();
        return;
    }

    if (m_executeFunction)
    {
        // Use QPointer to prevent use-after-free
        QPointer<UndoRedoCommand> safeThis(this);
        auto executeFunction = m_executeFunction; // Copy function to avoid capture issues

        auto future = QtConcurrent::run([safeThis, executeFunction]() -> Result<void> {
            if (safeThis.isNull())
            {
                return Result<void>("Command object destroyed during execution"_L1, ErrorCategory::ExecutionError);
            }

            try
            {
                QPromise<Result<void>> promise;
                executeFunction(promise);
                return Result<void>(); // Success by default
            }
            catch (const std::exception &e)
            {
                return Result<void>(QString::fromStdString(e.what()), ErrorCategory::ExecutionError);
            }
            catch (...)
            {
                return Result<void>("Unknown exception during command execution"_L1, ErrorCategory::UnknownError);
            }
        });
        m_executeWatcher->setFuture(future);
        m_wasAlreadyExecuted = true;
    }
    else
    {
        // No execute function, emit finished signal immediately
        m_wasAlreadyExecuted = true;
        Q_EMIT finished(true);
    }
}

void UndoRedoCommand::asyncUndo()
{
    if (!m_wasAlreadyExecuted)
    {
        qCritical() << "Command not yet executed, cannot undo.";
        return;
    }

    if (m_undoFunction)
    {
        QPointer<UndoRedoCommand> safeThis(this);
        auto undoFunction = m_undoFunction;

        auto future = QtConcurrent::run([safeThis, undoFunction]() -> Result<void> {
            if (safeThis.isNull())
            {
                return Result<void>("Command object destroyed during undo"_L1, ErrorCategory::ExecutionError);
            }

            try
            {
                return undoFunction();
            }
            catch (const std::exception &e)
            {
                return Result<void>(QString::fromStdString(e.what()), ErrorCategory::ExecutionError);
            }
            catch (...)
            {
                return Result<void>("Unknown exception during command undo"_L1, ErrorCategory::UnknownError);
            }
        });
        m_undoWatcher->setFuture(future);
    }
    else
    {
        // No undo function, emit finished signal immediately
        Q_EMIT finished(true);
    }
}

void UndoRedoCommand::asyncRedo()
{
    if (!m_wasAlreadyExecuted)
    {
        qCritical() << "Command not yet executed, calling execute instead.";
        asyncExecute();
        return;
    }

    if (m_redoFunction)
    {
        QPointer<UndoRedoCommand> safeThis(this);
        auto redoFunction = m_redoFunction;

        auto future = QtConcurrent::run([safeThis, redoFunction]() -> Result<void> {
            if (safeThis.isNull())
            {
                return Result<void>("Command object destroyed during redo"_L1, ErrorCategory::ExecutionError);
            }

            try
            {
                return redoFunction();
            }
            catch (const std::exception &e)
            {
                return Result<void>(QString::fromStdString(e.what()), ErrorCategory::ExecutionError);
            }
            catch (...)
            {
                return Result<void>("Unknown exception during command redo"_L1, ErrorCategory::UnknownError);
            }
        });
        m_redoWatcher->setFuture(future);
    }
    else
    {
        // No redo function, emit finished signal immediately
        Q_EMIT finished(true);
    }
}

QString UndoRedoCommand::text() const
{
    return m_text;
}

void UndoRedoCommand::setText(const QString &newText)
{
    m_text = newText;
}

void UndoRedoCommand::cancel()
{
    if (m_executeWatcher && m_executeWatcher->isRunning())
    {
        m_executeWatcher->cancel();
    }

    if (m_undoWatcher && m_undoWatcher->isRunning())
    {
        m_undoWatcher->cancel();
    }

    if (m_redoWatcher && m_redoWatcher->isRunning())
    {
        m_redoWatcher->cancel();
    }
}

bool UndoRedoCommand::canMergeWith(const std::shared_ptr<UndoRedoCommand> &other) const
{
    Q_UNUSED(other)
    return false; // Default implementation: no merging
}

void UndoRedoCommand::mergeWith(const std::shared_ptr<UndoRedoCommand> &other)
{
    Q_UNUSED(other)
    // Default implementation: do nothing
}

void UndoRedoCommand::onExecuteFinished()
{
    if (m_executeWatcher->isFinished())
    {
        auto result = m_executeWatcher->result();
        
        // Log detailed error information if operation failed
        if (!result.isSuccess())
        {
            qWarning() << "Command execution failed:" << result.error()
                      << "Category:" << static_cast<int>(result.category())
                      << "Severity:" << static_cast<int>(result.severity())
                      << "Context:" << result.context()
                      << "Error Code:" << result.errorCode();
        }
        
        Q_EMIT finished(result.isSuccess());
        Q_EMIT finishedWithResult(result);
    }
}

void UndoRedoCommand::onRedoFinished()
{
    if (m_redoWatcher->isFinished())
    {
        auto result = m_redoWatcher->result();
        
        // Log detailed error information if operation failed
        if (!result.isSuccess())
        {
            qWarning() << "Command redo failed:" << result.error()
                      << "Category:" << static_cast<int>(result.category())
                      << "Severity:" << static_cast<int>(result.severity())
                      << "Context:" << result.context()
                      << "Error Code:" << result.errorCode();
        }
        
        Q_EMIT finished(result.isSuccess());
        Q_EMIT finishedWithResult(result);
    }
}

void UndoRedoCommand::onUndoFinished()
{
    if (m_undoWatcher->isFinished())
    {
        auto result = m_undoWatcher->result();
        
        // Log detailed error information if operation failed
        if (!result.isSuccess())
        {
            qWarning() << "Command undo failed:" << result.error()
                      << "Category:" << static_cast<int>(result.category())
                      << "Severity:" << static_cast<int>(result.severity())
                      << "Context:" << result.context()
                      << "Error Code:" << result.errorCode();
        }
        
        Q_EMIT finished(result.isSuccess());
        Q_EMIT finishedWithResult(result);
    }
}

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo