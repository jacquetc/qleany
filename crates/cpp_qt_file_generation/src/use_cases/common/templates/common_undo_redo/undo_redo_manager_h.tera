#pragma once

#include "undo_redo_stack.h"
#include <QHash>
#include <QMutex>
#include <QObject>
#include <memory>

using namespace Qt::StringLiterals;

namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
{

class UndoRedoManager : public QObject
{
    Q_OBJECT

  public:
    explicit UndoRedoManager(QObject *parent = nullptr);

    // Stack management
    Q_INVOKABLE int createStack();
    Q_INVOKABLE void removeStack(int stackId);
    Q_INVOKABLE void setCurrentStackId(int stackId);
    Q_INVOKABLE int currentStackId() const;

    // Command operations
    void pushCommand(std::shared_ptr<UndoRedoCommand> command);
    void pushCommand(std::shared_ptr<UndoRedoCommand> command, int stackId);

    // Undo/Redo operations for current stack
    Q_INVOKABLE bool canUndo() const;
    Q_INVOKABLE bool canRedo() const;
    Q_INVOKABLE void execute();
    Q_INVOKABLE void undo();
    Q_INVOKABLE void redo();
    Q_INVOKABLE QString undoText() const;
    Q_INVOKABLE QString redoText() const;

    // Undo/Redo operations for specific stack
    Q_INVOKABLE bool canUndo(int stackId) const;
    Q_INVOKABLE bool canRedo(int stackId) const;
    Q_INVOKABLE void execute(int stackId);
    Q_INVOKABLE void undo(int stackId);
    Q_INVOKABLE void redo(int stackId);
    Q_INVOKABLE QString undoText(int stackId) const;
    Q_INVOKABLE QString redoText(int stackId) const;

    // Stack management
    Q_INVOKABLE void clearStack(int stackId);
    Q_INVOKABLE void clearAllStacks();

    // Information
    Q_INVOKABLE QList<int> activeStackIds() const;
    Q_INVOKABLE int undoCount(int stackId) const;
    Q_INVOKABLE int redoCount(int stackId) const;

    // Stack size management for current stack
    Q_INVOKABLE void setMaxStackSize(int maxSize);
    Q_INVOKABLE int maxStackSize() const;
    Q_INVOKABLE void setAutoCleanupEnabled(bool enabled);
    Q_INVOKABLE bool isAutoCleanupEnabled() const;

    // Stack size management for specific stack
    Q_INVOKABLE void setMaxStackSize(int stackId, int maxSize);
    Q_INVOKABLE int maxStackSize(int stackId) const;
    Q_INVOKABLE void setAutoCleanupEnabled(int stackId, bool enabled);
    Q_INVOKABLE bool isAutoCleanupEnabled(int stackId) const;

    // Cancel all running commands in all stacks
    Q_INVOKABLE void cancelAllCommands();

  Q_SIGNALS:
    void currentStackIdChanged(int stackId);
    void canUndoChanged(bool canUndo);
    void canRedoChanged(bool canRedo);
    void undoTextChanged(const QString &undoText);
    void redoTextChanged(const QString &redoText);
    void commandFinished(bool success);

  private Q_SLOTS:
    void onStackCanUndoChanged(bool canUndo);
    void onStackCanRedoChanged(bool canRedo);
    void onStackUndoTextChanged(const QString &undoText);
    void onStackRedoTextChanged(const QString &redoText);
    void onStackCommandFinished(bool success);

  private:
    UndoRedoStack *getOrCreateStack(int stackId);
    void connectStackSignals(UndoRedoStack *stack);
    void updateCurrentStackSignals();

    mutable QRecursiveMutex m_mutex;
    QHash<int, std::shared_ptr<UndoRedoStack>> m_stacks;
    int m_currentStackId = 0; // Stack 0 is the global stack (default)
    int m_nextStackId = 1;    // Next available stack ID for createStack()
};

} // namespace {{ s.global.application_pascal_name }}::Common::UndoRedo
