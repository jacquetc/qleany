#include <QCoreApplication>
#include <QSignalSpy>
#include <QTest>
#include <QTimer>

#include "undo_redo/group_command_builder.h"
#include "undo_redo/undo_redo_command.h"
#include "undo_redo/undo_redo_manager.h"
#include "undo_redo/undo_redo_stack.h"
#include "undo_redo/undo_redo_system.h"

using namespace {{ s.global.application_pascal_name }}::Common::UndoRedo;

class TestEnhancedUndoRedo : public QObject
{
    Q_OBJECT

  private Q_SLOTS:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    // Test 1: Basic command execution with enhanced Result system
    void testBasicCommandExecution();

    // Test 2: Enhanced error handling
    void testErrorHandling();

    // Test 3: GroupCommandBuilder fluent API
    void testGroupCommandBuilder();

    // Test 4: Stack size management
    void testStackSizeManagement();

    // Test 5: Performance monitoring signals
    void testPerformanceMonitoring();

    // Test 6: Lifetime management
    void testLifetimeManagement();

    // Test 7: Failure strategies
    void testFailureStrategies();

    // Test 8: Query exception handling
    void testQueryExceptionHandling();

    // Test 9: ContinueOnFailure executes all commands
    void testContinueOnFailureExecutesAllCommands();

    // Test 10: RollbackAll undoes all successful commands
    void testRollbackAllUndoesSuccessfulCommands();

    // Test 11: RollbackPartial only undoes the failed command
    void testRollbackPartialUndoesOnlyFailedCommand();

    // Test 12: Async rollback waits for completion before emitting finished
    void testAsyncRollbackWaitsForCompletion();

    // Test 13: MaxStackSize via Manager API
    void testMaxStackSizeViaManager();

    // Test 14: MaxStackSize via System API
    void testMaxStackSizeViaSystem();

  private:
    std::unique_ptr<UndoRedoSystem> m_system;
    std::unique_ptr<UndoRedoStack> m_stack;
};

void TestEnhancedUndoRedo::initTestCase()
{
    // Application is already created by QTEST_MAIN
    // No need to create our own QCoreApplication
}

void TestEnhancedUndoRedo::cleanupTestCase()
{
    // Application cleanup is handled by QTEST_MAIN
}

void TestEnhancedUndoRedo::init()
{
    m_system = std::make_unique<UndoRedoSystem>();
    m_stack = std::make_unique<UndoRedoStack>();
}

void TestEnhancedUndoRedo::cleanup()
{
    m_system.reset();
    m_stack.reset();
}

void TestEnhancedUndoRedo::testBasicCommandExecution()
{
    // Arrange
    bool executeCalled = false;
    auto command = std::make_shared<UndoRedoCommand>("Test Command"_L1);
    command->setExecuteFunction([&executeCalled](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        executeCalled = true;
    });

    QSignalSpy finishedSpy(command.get(), &UndoRedoCommand::finished);

    // Act
    command->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert
    QVERIFY(executeCalled);
    QCOMPARE(finishedSpy.count(), 1);
    QCOMPARE(finishedSpy.first().first().toBool(), true);
}

void TestEnhancedUndoRedo::testErrorHandling()
{
    // Arrange
    auto command = std::make_shared<UndoRedoCommand>("Error Command"_L1);
    command->setExecuteFunction([](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        throw std::runtime_error("Test exception");
    });

    QSignalSpy finishedSpy(command.get(), &UndoRedoCommand::finished);

    // Act
    command->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert
    QCOMPARE(finishedSpy.count(), 1);
    QCOMPARE(finishedSpy.first().first().toBool(), false); // Should fail due to exception
}

void TestEnhancedUndoRedo::testGroupCommandBuilder()
{
    // Arrange
    auto cmd1 = std::make_shared<UndoRedoCommand>("Command 1"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Command 2"_L1);

    bool cmd1Executed = false;
    bool cmd2Executed = false;

    cmd1->setExecuteFunction([&cmd1Executed](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        cmd1Executed = true;
    });

    cmd2->setExecuteFunction([&cmd2Executed](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        cmd2Executed = true;
    });

    // Act
    auto groupCommand = GroupCommandBuilder("Group Test"_L1)
                            .addCommand(cmd1)
                            .addCommand(cmd2)
                            .onFailure(FailureStrategy::StopOnFailure)
                            .build();

    QSignalSpy finishedSpy(groupCommand.get(), &GroupCommand::finished);
    groupCommand->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert
    QVERIFY(cmd1Executed);
    QVERIFY(cmd2Executed);
    QCOMPARE(groupCommand->commandCount(), 2);
    QCOMPARE(groupCommand->failureStrategy(), FailureStrategy::StopOnFailure);
}

void TestEnhancedUndoRedo::testStackSizeManagement()
{
    // Arrange
    m_stack->setMaxStackSize(2);
    m_stack->setAutoCleanupEnabled(true);

    auto cmd1 = std::make_shared<UndoRedoCommand>("Command 1"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Command 2"_L1);
    auto cmd3 = std::make_shared<UndoRedoCommand>("Command 3"_L1);

    // Act
    m_stack->push(cmd1);
    m_stack->push(cmd2);
    m_stack->push(cmd3); // This should trigger size limit

    // Assert
    QCOMPARE(m_stack->undoCount(), 2); // Should be limited to max size
    QCOMPARE(m_stack->maxStackSize(), 2);
    QVERIFY(m_stack->isAutoCleanupEnabled());
}

void TestEnhancedUndoRedo::testPerformanceMonitoring()
{
    // Arrange
    QSignalSpy executionTimeSpy(m_system.get(), &UndoRedoSystem::commandExecutionTime);
    QSignalSpy stackSizeSpy(m_system.get(), &UndoRedoSystem::stackSizeChanged);

    auto command = std::make_shared<UndoRedoCommand>("Monitored Command"_L1);
    command->setExecuteFunction([](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        QThread::msleep(10); // Small delay to measure
    });

    // Act - Note: This test may have async issues, simplified for demonstration
    // In a real test, we'd need proper async handling

    // Assert - Basic structure test
    QVERIFY(executionTimeSpy.isValid());
    QVERIFY(stackSizeSpy.isValid());
}

void TestEnhancedUndoRedo::testLifetimeManagement()
{
    // Arrange
    auto command = std::make_shared<UndoRedoCommand>("Lifetime Test"_L1);
    bool executeCalled = false;

    command->setExecuteFunction([&executeCalled](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        executeCalled = true;
    });

    QSignalSpy finishedSpy(command.get(), &UndoRedoCommand::finished);

    // Act
    command->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert
    QVERIFY(executeCalled);
    QCOMPARE(finishedSpy.count(), 1);
    // The fact that this doesn't crash shows lifetime management works
}

void TestEnhancedUndoRedo::testFailureStrategies()
{
    // Arrange
    auto cmd1 = std::make_shared<UndoRedoCommand>("Success Command"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Fail Command"_L1);

    bool cmd1Executed = false;

    cmd1->setExecuteFunction([&cmd1Executed](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        cmd1Executed = true;
    });

    cmd2->setExecuteFunction([](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        throw std::runtime_error("Intentional failure");
    });

    // Act
    auto groupCommand = GroupCommandBuilder("Failure Strategy Test"_L1)
                            .addCommand(cmd1)
                            .addCommand(cmd2)
                            .onFailure(FailureStrategy::RollbackAll)
                            .build();

    QSignalSpy finishedSpy(groupCommand.get(), &GroupCommand::finished);
    groupCommand->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert
    QVERIFY(cmd1Executed);
    QCOMPARE(groupCommand->failureStrategy(), FailureStrategy::RollbackAll);
    QCOMPARE(finishedSpy.first().first().toBool(), false); // Should fail
}

void TestEnhancedUndoRedo::testQueryExceptionHandling()
{
    // Arrange
    auto query = m_system->createQuery<int>("Exception Query"_L1);
    query->setQueryFunction([]() -> int {
        throw std::runtime_error("Query exception");
        return 42;
    });

    QSignalSpy finishedSpy(query.get(), &QueryBase::finished);

    // Act
    query->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert
    QCOMPARE(finishedSpy.count(), 1);
    QCOMPARE(finishedSpy.first().first().toBool(), false); // Should fail due to exception
}

void TestEnhancedUndoRedo::testContinueOnFailureExecutesAllCommands()
{
    // Arrange: Create 3 commands where the second one fails
    auto cmd1 = std::make_shared<UndoRedoCommand>("Command 1"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Command 2 (fails)"_L1);
    auto cmd3 = std::make_shared<UndoRedoCommand>("Command 3"_L1);

    bool cmd1Executed = false;
    bool cmd2Executed = false;
    bool cmd3Executed = false;

    cmd1->setExecuteFunction([&cmd1Executed](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        cmd1Executed = true;
    });

    cmd2->setExecuteFunction([&cmd2Executed](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        cmd2Executed = true;
        throw std::runtime_error("Intentional failure in cmd2");
    });

    cmd3->setExecuteFunction([&cmd3Executed](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        cmd3Executed = true;
    });

    // Act
    auto groupCommand = GroupCommandBuilder("ContinueOnFailure Test"_L1)
                            .addCommand(cmd1)
                            .addCommand(cmd2)
                            .addCommand(cmd3)
                            .onFailure(FailureStrategy::ContinueOnFailure)
                            .build();

    QSignalSpy finishedSpy(groupCommand.get(), &GroupCommand::finished);
    groupCommand->asyncExecute();

    // Wait for async execution
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert: All commands should have been executed despite cmd2 failing
    QVERIFY(cmd1Executed);
    QVERIFY(cmd2Executed);
    QVERIFY(cmd3Executed);
    // Group should report failure since not all commands succeeded
    QCOMPARE(finishedSpy.first().first().toBool(), false);
}

void TestEnhancedUndoRedo::testRollbackAllUndoesSuccessfulCommands()
{
    // Arrange: Create 3 commands where the third one fails
    auto cmd1 = std::make_shared<UndoRedoCommand>("Command 1"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Command 2"_L1);
    auto cmd3 = std::make_shared<UndoRedoCommand>("Command 3 (fails)"_L1);

    bool cmd1Undone = false;
    bool cmd2Undone = false;

    cmd1->setExecuteFunction([](QPromise<Result<void>> &promise) { Q_UNUSED(promise) });
    cmd1->setUndoFunction([&cmd1Undone]() {
        cmd1Undone = true;
        return Result<void>();
    });

    cmd2->setExecuteFunction([](QPromise<Result<void>> &promise) { Q_UNUSED(promise) });
    cmd2->setUndoFunction([&cmd2Undone]() {
        cmd2Undone = true;
        return Result<void>();
    });

    cmd3->setExecuteFunction([](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        throw std::runtime_error("Intentional failure in cmd3");
    });

    // Act
    auto groupCommand = GroupCommandBuilder("RollbackAll Test"_L1)
                            .addCommand(cmd1)
                            .addCommand(cmd2)
                            .addCommand(cmd3)
                            .onFailure(FailureStrategy::RollbackAll)
                            .build();

    QSignalSpy finishedSpy(groupCommand.get(), &GroupCommand::finished);
    groupCommand->asyncExecute();

    // Wait for async execution and rollback
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert: Both successful commands should have been rolled back
    QVERIFY(cmd1Undone);
    QVERIFY(cmd2Undone);
    QCOMPARE(finishedSpy.first().first().toBool(), false);
}

void TestEnhancedUndoRedo::testRollbackPartialUndoesOnlyFailedCommand()
{
    // Arrange: Create 3 commands where the third one fails
    auto cmd1 = std::make_shared<UndoRedoCommand>("Command 1"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Command 2"_L1);
    auto cmd3 = std::make_shared<UndoRedoCommand>("Command 3 (fails)"_L1);

    bool cmd1Undone = false;
    bool cmd2Undone = false;
    bool cmd3Undone = false;

    cmd1->setExecuteFunction([](QPromise<Result<void>> &promise) { Q_UNUSED(promise) });
    cmd1->setUndoFunction([&cmd1Undone]() {
        cmd1Undone = true;
        return Result<void>();
    });

    cmd2->setExecuteFunction([](QPromise<Result<void>> &promise) { Q_UNUSED(promise) });
    cmd2->setUndoFunction([&cmd2Undone]() {
        cmd2Undone = true;
        return Result<void>();
    });

    cmd3->setExecuteFunction([](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        throw std::runtime_error("Intentional failure in cmd3");
    });
    cmd3->setUndoFunction([&cmd3Undone]() {
        cmd3Undone = true;
        return Result<void>();
    });

    // Act
    auto groupCommand = GroupCommandBuilder("RollbackPartial Test"_L1)
                            .addCommand(cmd1)
                            .addCommand(cmd2)
                            .addCommand(cmd3)
                            .onFailure(FailureStrategy::RollbackPartial)
                            .build();

    QSignalSpy finishedSpy(groupCommand.get(), &GroupCommand::finished);
    groupCommand->asyncExecute();

    // Wait for async execution and rollback
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert: Only the failed command should be rolled back, not the successful ones
    QVERIFY(!cmd1Undone);
    QVERIFY(!cmd2Undone);
    QVERIFY(cmd3Undone);
    QCOMPARE(finishedSpy.first().first().toBool(), false);
}

void TestEnhancedUndoRedo::testAsyncRollbackWaitsForCompletion()
{
    // Arrange: Commands with slow undo to verify timing
    auto cmd1 = std::make_shared<UndoRedoCommand>("Command 1"_L1);
    auto cmd2 = std::make_shared<UndoRedoCommand>("Command 2 (fails)"_L1);

    std::atomic<bool> cmd1UndoStarted{false};
    std::atomic<bool> cmd1UndoCompleted{false};
    std::atomic<bool> finishedEmittedBeforeUndoComplete{false};

    cmd1->setExecuteFunction([](QPromise<Result<void>> &promise) { Q_UNUSED(promise) });
    cmd1->setUndoFunction([&cmd1UndoStarted, &cmd1UndoCompleted]() {
        cmd1UndoStarted = true;
        QThread::msleep(50); // Simulate slow undo
        cmd1UndoCompleted = true;
        return Result<void>();
    });

    cmd2->setExecuteFunction([](QPromise<Result<void>> &promise) {
        Q_UNUSED(promise)
        throw std::runtime_error("Intentional failure");
    });

    auto groupCommand = GroupCommandBuilder("Async Rollback Test"_L1)
                            .addCommand(cmd1)
                            .addCommand(cmd2)
                            .onFailure(FailureStrategy::RollbackAll)
                            .build();

    // Connect to finished signal to check timing
    connect(groupCommand.get(), &GroupCommand::finished, this, [&]() {
        if (cmd1UndoStarted && !cmd1UndoCompleted)
        {
            finishedEmittedBeforeUndoComplete = true;
        }
    });

    QSignalSpy finishedSpy(groupCommand.get(), &GroupCommand::finished);

    // Act
    groupCommand->asyncExecute();

    // Wait for completion
    QTRY_VERIFY(finishedSpy.count() == 1);

    // Assert: Finished should only be emitted after undo completes
    QVERIFY(cmd1UndoCompleted);
    QVERIFY(!finishedEmittedBeforeUndoComplete);
}

void TestEnhancedUndoRedo::testMaxStackSizeViaManager()
{
    // Arrange
    auto manager = std::make_unique<UndoRedoManager>();

    // Act
    manager->setMaxStackSize(5);

    // Assert
    QCOMPARE(manager->maxStackSize(), 5);

    // Test with specific scope
    manager->setMaxStackSize(10);
    QCOMPARE(manager->maxStackSize(), 10);

    // Test auto cleanup
    manager->setAutoCleanupEnabled(true);
    QVERIFY(manager->isAutoCleanupEnabled());

    manager->setAutoCleanupEnabled(true);
    QVERIFY(manager->isAutoCleanupEnabled());
}

void TestEnhancedUndoRedo::testMaxStackSizeViaSystem()
{
    // Arrange - use m_system from init()

    // Act
    m_system->setMaxStackSize(3);

    // Assert
    QCOMPARE(m_system->maxStackSize(), 3);

    // Test auto cleanup
    m_system->setAutoCleanupEnabled(true);
    QVERIFY(m_system->isAutoCleanupEnabled());
}

QTEST_MAIN(TestEnhancedUndoRedo)
#include "tst_enhanced_undo_redo.moc"
