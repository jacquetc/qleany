#include "service_locator.h"
#include "undo_redo/group_command.h"
#include "undo_redo/query_handler.h"
#include "undo_redo/undo_redo_command.h"
#include "undo_redo/undo_redo_manager.h"
#include "undo_redo/undo_redo_stack.h"
#include "undo_redo/undo_redo_system.h"
#include <QObject>
#include <QSignalSpy>
#include <QTest>
#include <memory>

using namespace Qt::StringLiterals;

namespace SCU = {{ s.global.application_pascal_name }}::Common::UndoRedo;

class TestUndoRedo : public QObject
{
    Q_OBJECT

  private Q_SLOTS:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    void testBasicCommandExecution();
    void testCommandUndoRedo();
    void testCommandThreadExecution();
    void testBasicStackOperations();
    void testStackUndoRedo();
    void testMultiScopeManager();
    void testScopeIsolation();
    void testCommandGrouping();
    void testCommandMerging();
    void testQueryExecution();
    void testQueryThreadExecution();
    void testServiceLocatorRegistration();

  private:
};

void TestUndoRedo::initTestCase()
{
    std::string duration("20000"); // 20 secondes
    QByteArray timeoutDuration(duration.c_str(), static_cast<int>(duration.length()));
    qputenv("QTEST_FUNCTION_TIMEOUT", timeoutDuration);
}

void TestUndoRedo::cleanupTestCase()
{
}

void TestUndoRedo::init()
{
}

void TestUndoRedo::cleanup()
{
}
void TestUndoRedo::testBasicCommandExecution()
{
    // Arrange
    bool executed = false;
    auto command = std::make_shared<SCU::UndoRedoCommand>("Test Command"_L1);

    QSignalSpy finishedSpy(command.get(), &SCU::UndoRedoCommand::finished);
    command->setExecuteFunction([&executed](auto &) { executed = true; });
    command->asyncExecute();

    // Assert - wait for async completion
    QVERIFY(finishedSpy.wait(1000)); // Wait up to 1 second
    QVERIFY(executed);
    QCOMPARE(command->text(), "Test Command"_L1);
}

void TestUndoRedo::testCommandUndoRedo()
{
    // Arrange
    int value = 0;
    auto command = std::make_shared<SCU::UndoRedoCommand>("Increment Command"_L1);
    command->setExecuteFunction([&value](auto &) { value++; });
    command->setRedoFunction([&value]() {
        value++;
        return SCU::Result<void>();
    });
    command->setUndoFunction([&value]() {
        value--;
        return SCU::Result<void>();
    });

    QSignalSpy finishedSpy(command.get(), &SCU::UndoRedoCommand::finished);

    // Act & Assert
    command->asyncExecute();
    QVERIFY(finishedSpy.wait(1000));
    QCOMPARE(value, 1);

    finishedSpy.clear();
    command->asyncUndo();
    QVERIFY(finishedSpy.wait(1000));
    QCOMPARE(value, 0);

    finishedSpy.clear();
    command->asyncRedo();
    QVERIFY(finishedSpy.wait(1000));
    QCOMPARE(value, 1);
}

void TestUndoRedo::testCommandThreadExecution()
{
    // Arrange
    QThread::currentThread()->setObjectName("MainThread"_L1);
    QString executionThread;
    bool executed = false;

    auto command = std::make_shared<SCU::UndoRedoCommand>("Thread Test Command"_L1);
    command->setExecuteFunction([&executionThread, &executed](auto &) {
        executionThread = QThread::currentThread()->objectName();
        executed = true;
    });

    QSignalSpy finishedSpy(command.get(), &SCU::UndoRedoCommand::finished);

    // Act
    command->asyncExecute();

    // Assert - wait for async completion
    QVERIFY(finishedSpy.wait(1000));
    QVERIFY(executed);
    QCOMPARE(finishedSpy.count(), 1);
    // Verify execution on separate thread (QtConcurrent creates different thread)
    QVERIFY(executionThread != "MainThread"_L1);
}

void TestUndoRedo::testBasicStackOperations()
{
    // Arrange
    SCU::UndoRedoStack stack;

    // Test initial state
    QVERIFY(!stack.canUndo());
    QVERIFY(!stack.canRedo());
    QCOMPARE(stack.undoCount(), 0);
    QCOMPARE(stack.redoCount(), 0);
    QVERIFY(stack.undoText().isEmpty());
    QVERIFY(stack.redoText().isEmpty());

    // Create test commands
    auto command1 = std::make_shared<SCU::UndoRedoCommand>("Command 1"_L1);
    auto command2 = std::make_shared<SCU::UndoRedoCommand>("Command 2"_L1);

    // Test pushing commands
    stack.push(command1);
    QVERIFY(stack.canUndo());
    QVERIFY(!stack.canRedo());
    QCOMPARE(stack.undoCount(), 1);
    QCOMPARE(stack.redoCount(), 0);
    QCOMPARE(stack.undoText(), "Command 1"_L1);

    stack.push(command2);
    QVERIFY(stack.canUndo());
    QVERIFY(!stack.canRedo());
    QCOMPARE(stack.undoCount(), 2);
    QCOMPARE(stack.redoCount(), 0);
    QCOMPARE(stack.undoText(), "Command 2"_L1);

    // Test clear
    stack.clear();
    QVERIFY(!stack.canUndo());
    QVERIFY(!stack.canRedo());
    QCOMPARE(stack.undoCount(), 0);
    QCOMPARE(stack.redoCount(), 0);
}

void TestUndoRedo::testStackUndoRedo()
{
    // Arrange
    SCU::UndoRedoStack stack;
    int value = 0;

    auto command1 = std::make_shared<SCU::UndoRedoCommand>("Increment 1"_L1);
    command1->setExecuteFunction([&value](auto &) { value++; });
    command1->setRedoFunction([&value]() {
        value++;
        return SCU::Result<void>();
    });
    command1->setUndoFunction([&value]() {
        value--;
        return SCU::Result<void>();
    });

    auto command2 = std::make_shared<SCU::UndoRedoCommand>("Increment 2"_L1);
    command2->setExecuteFunction([&value](auto &) { value++; });
    command2->setRedoFunction([&value]() {
        value++;
        return SCU::Result<void>();
    });
    command2->setUndoFunction([&value]() {
        value--;
        return SCU::Result<void>();
    });

    QSignalSpy commandFinishedSpy(&stack, &SCU::UndoRedoStack::commandFinished);

    // Push and execute command1, wait for async completion
    stack.push(command1);
    stack.execute();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(value, 1);

    // Push and execute command2, wait for async completion
    commandFinishedSpy.clear();
    stack.push(command2);
    stack.execute();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(value, 2);

    QCOMPARE(stack.undoCount(), 2);
    QCOMPARE(stack.redoCount(), 0);

    // Test undo
    commandFinishedSpy.clear();
    stack.undo();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(value, 1); // Command2 undo executed
    QCOMPARE(stack.undoCount(), 1);
    QCOMPARE(stack.redoCount(), 1);
    QCOMPARE(stack.redoText(), "Increment 2"_L1);

    // Test redo
    commandFinishedSpy.clear();
    stack.redo();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(value, 2); // Command2 redo executed (value becomes 2)
    QCOMPARE(stack.undoCount(), 2);
    QCOMPARE(stack.redoCount(), 0);

    // Test multiple undos
    commandFinishedSpy.clear();
    stack.undo();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(value, 1); // Command2 undo

    commandFinishedSpy.clear();
    stack.undo();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(value, 0); // Command1 undo

    QCOMPARE(stack.undoCount(), 0);
    QCOMPARE(stack.redoCount(), 2);
}

void TestUndoRedo::testMultiScopeManager()
{
    // QSKIP("Multi-scope manager test temporarily disabled - has implementation issues causing timeouts");
    //   Arrange
    SCU::UndoRedoManager manager;

    // Create different stack IDs
    int stackId1 = 1;
    int stackId2 = 2;
    int stackId3 = 10;

    // Test initial state
    QCOMPARE(manager.currentStackId(), 0);
    QVERIFY(!manager.canUndo());
    QVERIFY(!manager.canRedo());
    QVERIFY(manager.activeStackIds().isEmpty());

    // Create commands for different stacks
    int value1 = 0, value2 = 0, value3 = 0;

    auto cmd1 = std::make_shared<SCU::UndoRedoCommand>("Stack1 Command"_L1);
    cmd1->setExecuteFunction([&value1](auto &) { value1++; });
    cmd1->setRedoFunction([&value1]() {
        value1++;
        return SCU::Result<void>();
    });
    cmd1->setUndoFunction([&value1]() {
        value1--;
        return SCU::Result<void>();
    });

    auto cmd2 = std::make_shared<SCU::UndoRedoCommand>("Stack2 Command"_L1);
    cmd2->setExecuteFunction([&value2](auto &) { value2++; });
    cmd2->setRedoFunction([&value2]() {
        value2++;
        return SCU::Result<void>();
    });
    cmd2->setUndoFunction([&value2]() {
        value2--;
        return SCU::Result<void>();
    });

    auto cmd3 = std::make_shared<SCU::UndoRedoCommand>("Stack3 Command"_L1);
    cmd3->setExecuteFunction([&value3](auto &) { value3++; });
    cmd3->setRedoFunction([&value3]() {
        value3++;
        return SCU::Result<void>();
    });
    cmd3->setUndoFunction([&value3]() {
        value3--;
        return SCU::Result<void>();
    });

    // Push commands to different stacks
    manager.pushCommand(cmd1, stackId1);
    manager.pushCommand(cmd2, stackId2);
    manager.pushCommand(cmd3, stackId3);

    // Verify active stacks
    auto activeStackIds = manager.activeStackIds();
    QCOMPARE(activeStackIds.size(), 3);
    QVERIFY(activeStackIds.contains(stackId1));
    QVERIFY(activeStackIds.contains(stackId2));
    QVERIFY(activeStackIds.contains(stackId3));

    // Verify each stack has commands
    QVERIFY(manager.canUndo(stackId1));
    QVERIFY(manager.canUndo(stackId2));
    QVERIFY(manager.canUndo(stackId3));
    QCOMPARE(manager.undoCount(stackId1), 1);
    QCOMPARE(manager.undoCount(stackId2), 1);
    QCOMPARE(manager.undoCount(stackId3), 1);

    // Test switching current stack
    QSignalSpy currentStackIdSpy(&manager, &SCU::UndoRedoManager::currentStackIdChanged);
    manager.setCurrentStackId(stackId1);
    QVERIFY(currentStackIdSpy.count() == 1);
    QCOMPARE(manager.currentStackId(), stackId1);
    QVERIFY(manager.canUndo()); // Current stack method
    QCOMPARE(manager.undoText(), "Stack1 Command"_L1);

    // Test stack isolation without command execution
    // Each stack should have independent state
    QCOMPARE(manager.undoText(stackId1), "Stack1 Command"_L1);
    QCOMPARE(manager.undoText(stackId2), "Stack2 Command"_L1);
    QCOMPARE(manager.undoText(stackId3), "Stack3 Command"_L1);

    // Verify each stack can independently track commands
    QVERIFY(manager.canUndo(stackId1));
    QVERIFY(manager.canUndo(stackId2));
    QVERIFY(manager.canUndo(stackId3));
    QVERIFY(!manager.canRedo(stackId1));
    QVERIFY(!manager.canRedo(stackId2));
    QVERIFY(!manager.canRedo(stackId3));

    // Test clearing specific stack
    manager.removeStack(stackId2);
    QVERIFY(!manager.canUndo(stackId2));
    QVERIFY(!manager.canRedo(stackId2));
    QCOMPARE(manager.undoCount(stackId2), 0);

    // Other stacks should remain unaffected
    QVERIFY(manager.canUndo(stackId1));
    QVERIFY(manager.canUndo(stackId3));
}

void TestUndoRedo::testScopeIsolation()
{
    // QSKIP("Scope isolation test temporarily disabled - has implementation issues causing timeouts");
    //  Arrange
    SCU::UndoRedoManager manager;

    int stackId1 = 100;
    int stackId2 = 200;

    // Create isolated variables for each stack
    int stack1Value = 10;
    int stack2Value = 20;

    // Create commands for stack 1
    auto stack1Cmd1 = std::make_shared<SCU::UndoRedoCommand>("Stack1 Increment"_L1);
    stack1Cmd1->setExecuteFunction([&stack1Value](auto &) { stack1Value += 5; });
    stack1Cmd1->setRedoFunction([&stack1Value]() {
        stack1Value += 5;
        return SCU::Result<void>();
    });
    stack1Cmd1->setUndoFunction([&stack1Value]() {
        stack1Value -= 5;
        return SCU::Result<void>();
    });

    auto stack1Cmd2 = std::make_shared<SCU::UndoRedoCommand>("Stack1 Double"_L1);
    stack1Cmd2->setExecuteFunction([&stack1Value](auto &) { stack1Value *= 2; });
    stack1Cmd2->setRedoFunction([&stack1Value]() {
        stack1Value *= 2;
        return SCU::Result<void>();
    });
    stack1Cmd2->setUndoFunction([&stack1Value]() {
        stack1Value /= 2;
        return SCU::Result<void>();
    });

    // Create commands for stack 2
    auto stack2Cmd1 = std::make_shared<SCU::UndoRedoCommand>("Stack2 Decrement"_L1);
    stack2Cmd1->setExecuteFunction([&stack2Value](auto &) { stack2Value -= 3; });
    stack2Cmd1->setRedoFunction([&stack2Value]() {
        stack2Value -= 3;

        return SCU::Result<void>();
    });
    stack2Cmd1->setUndoFunction([&stack2Value]() {
        stack2Value += 3;
        return SCU::Result<void>();
    });

    auto stack2Cmd2 = std::make_shared<SCU::UndoRedoCommand>("Stack2 Multiply"_L1);
    stack2Cmd2->setExecuteFunction([&stack2Value](auto &) { stack2Value *= 3; });
    stack2Cmd2->setRedoFunction([&stack2Value]() {
        stack2Value *= 3;
        return SCU::Result<void>();
    });
    stack2Cmd2->setUndoFunction([&stack2Value]() {
        stack2Value /= 3;
        return SCU::Result<void>();
    });
    QTest::qSleep(50); // Give some time for async execution

    // Verify initial isolation
    QCOMPARE(stack1Value, 10);
    QCOMPARE(stack2Value, 20);

    // Push commands to their respective stacks, without executing them
    manager.pushCommand(stack1Cmd1, stackId1);
    manager.pushCommand(stack1Cmd2, stackId1);
    manager.pushCommand(stack2Cmd1, stackId2);
    manager.pushCommand(stack2Cmd2, stackId2);

    // Verify stack counts
    QCOMPARE(manager.undoCount(stackId1), 2);
    QCOMPARE(manager.undoCount(stackId2), 2);
    QCOMPARE(manager.redoCount(stackId1), 0);
    QCOMPARE(manager.redoCount(stackId2), 0);

    // Test isolated stack state tracking (without execution)
    // Verify stack isolation - commands are tracked independently
    QCOMPARE(manager.undoText(stackId1), "Stack1 Double"_L1);   // Last command pushed
    QCOMPARE(manager.undoText(stackId2), "Stack2 Multiply"_L1); // Last command pushed

    // Each stack maintains independent command counts
    QVERIFY(manager.canUndo(stackId1));
    QVERIFY(manager.canUndo(stackId2));
    QVERIFY(!manager.canRedo(stackId1));
    QVERIFY(!manager.canRedo(stackId2));

    // Verify isolated text retrieval
    QCOMPARE(manager.undoText(stackId1), "Stack1 Double"_L1);
    QCOMPARE(manager.undoText(stackId2), "Stack2 Multiply"_L1);

    // Test clearing one stack doesn't affect the other
    manager.removeStack(stackId1);
    QCOMPARE(manager.undoCount(stackId1), 0);
    QCOMPARE(manager.redoCount(stackId1), 0);
    QCOMPARE(manager.undoCount(stackId2), 2); // Still has commands
    QCOMPARE(manager.redoCount(stackId2), 0); // Still has commands

    // Verify stack2 still works after stack1 removed
    QVERIFY(!manager.canUndo(stackId1)); // stack1 removed
    QVERIFY(manager.canUndo(stackId2));  // stack2 still has commands
    QCOMPARE(manager.undoText(stackId2), "Stack2 Multiply"_L1);
}

void TestUndoRedo::testCommandGrouping()
{
    // Arrange
    int value1 = 0, value2 = 10, value3 = 100;

    auto command1 = std::make_shared<SCU::UndoRedoCommand>("Increment Value1"_L1);
    command1->setExecuteFunction([&value1](auto &) { value1++; });
    command1->setRedoFunction([&value1]() {
        value1++;
        return SCU::Result<void>();
    });
    command1->setUndoFunction([&value1]() {
        value1--;
        return SCU::Result<void>();
    });

    auto command2 = std::make_shared<SCU::UndoRedoCommand>("Increment Value2"_L1);

    command2->setExecuteFunction([&value2](auto &) { value2++; });
    command2->setRedoFunction([&value2]() {
        value2++;
        return SCU::Result<void>();
    });
    command2->setUndoFunction([&value2]() {
        value2--;
        return SCU::Result<void>();
    });

    auto command3 = std::make_shared<SCU::UndoRedoCommand>("Increment Value3"_L1);
    command3->setExecuteFunction([&value3](auto &) { value3++; });
    command3->setRedoFunction([&value3]() {
        value3++;
        return SCU::Result<void>();
    });
    command3->setUndoFunction([&value3]() {
        value3--;
        return SCU::Result<void>();
    });

    // Create group command
    auto groupCommand = std::make_shared<SCU::GroupCommand>("Group Increment"_L1);
    groupCommand->addCommand(command1);
    groupCommand->addCommand(command2);
    groupCommand->addCommand(command3);

    QCOMPARE(groupCommand->commandCount(), 3);
    QCOMPARE(groupCommand->command(0), command1);
    QCOMPARE(groupCommand->text(), "Group Increment"_L1);

    QSignalSpy finishedSpy(groupCommand.get(), &SCU::GroupCommand::finished);

    // Act - Execute group execute
    groupCommand->asyncExecute();
    QVERIFY(finishedSpy.wait(2000)); // Wait longer for group execution
    QCOMPARE(finishedSpy.count(), 1);

    // Assert - All commands executed
    QCOMPARE(value1, 1);
    QCOMPARE(value2, 11);
    QCOMPARE(value3, 101);

    // Act - Execute group undo
    finishedSpy.clear();
    groupCommand->asyncUndo();
    QVERIFY(finishedSpy.wait(2000));
    QVERIFY(finishedSpy.count() == 1);

    // Assert - All commands undone (in reverse order)
    QCOMPARE(value1, 0);
    QCOMPARE(value2, 10);
    QCOMPARE(value3, 100);

    // Test with stack
    SCU::UndoRedoStack stack;
    stack.push(groupCommand);

    QSignalSpy stackFinishedSpy(&stack, &SCU::UndoRedoStack::commandFinished);

    stack.undo();
    QVERIFY(stackFinishedSpy.wait(2000));

    // Values should be modified again (group undo executed)
    QCOMPARE(value1, -1);
    QCOMPARE(value2, 9);
    QCOMPARE(value3, 99);
}

void TestUndoRedo::testCommandMerging()
{
    // Test mergeable commands - simulating typing characters
    QString text = "Hello"_L1;

    // Create a mergeable command that adds a character
    class TypeCommand : public SCU::UndoRedoCommand
    {
      public:
        TypeCommand(int pos, const QString &ch, QString *textRef)
            : UndoRedoCommand("Type '"_L1 + ch + "'"_L1), m_position(pos), m_character(ch), m_textRef(textRef)
        {
            setExecuteFunction([this](auto &) { m_textRef->insert(m_position, m_character); });
            setRedoFunction([this]() {
                m_textRef->insert(m_position, m_character);
                return SCU::Result<void>();
            });
            setUndoFunction([this]() {
                m_textRef->remove(m_position, m_character.length());
                return SCU::Result<void>();
            });
        }

        // Override for mergeability
        bool canMergeWith(const std::shared_ptr<UndoRedoCommand> &other) const override
        {
            auto typeCmd = std::dynamic_pointer_cast<TypeCommand>(other);
            if (!typeCmd)
                return false;

            // Can merge if positions are consecutive and text references are same
            return (typeCmd->m_position == m_position + m_character.length()) && (typeCmd->m_textRef == m_textRef);
        }

        void mergeWith(const std::shared_ptr<UndoRedoCommand> &other) override
        {
            auto typeCmd = std::dynamic_pointer_cast<TypeCommand>(other);
            if (typeCmd && canMergeWith(other))
            {
                m_character += typeCmd->m_character;
                setText("Type '"_L1 + m_character + "'"_L1);

                // Update redo function for merged command
                setExecuteFunction([this](auto &) { m_textRef->insert(m_position, m_character); });
                setRedoFunction([this]() {
                    m_textRef->insert(m_position, m_character);
                    return SCU::Result<void>();
                });
                setUndoFunction([this]() {
                    m_textRef->remove(m_position, m_character.length());
                    return SCU::Result<void>();
                });
            }
        }

      private:
        int m_position;
        QString m_character;
        QString *m_textRef;
    };

    SCU::UndoRedoStack stack;
    QSignalSpy commandFinishedSpy(&stack, &SCU::UndoRedoStack::commandFinished);

    // Push first command
    auto cmd1 = std::make_shared<TypeCommand>(text.length(), " "_L1, &text);
    stack.push(cmd1);
    QCOMPARE(stack.undoCount(), 1);

    // Push mergeable command
    auto cmd2 = std::make_shared<TypeCommand>(text.length() + 1, "W"_L1, &text);
    stack.push(cmd2);

    // Should still have 1 command due to merging
    QCOMPARE(stack.undoCount(), 1);
    QCOMPARE(stack.undoText(), "Type ' W'"_L1);

    // Push another mergeable command
    auto cmd3 = std::make_shared<TypeCommand>(text.length() + 2, "o"_L1, &text);
    stack.push(cmd3);

    // Should still have 1 command
    QCOMPARE(stack.undoCount(), 1);
    QCOMPARE(stack.undoText(), "Type ' Wo'"_L1);

    // Execute and wait for async completion
    stack.execute();
    QVERIFY(commandFinishedSpy.wait(1000));

    // Test execution - undo should remove all merged characters
    QCOMPARE(text, "Hello Wo"_L1);
    commandFinishedSpy.clear();
    stack.undo();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(text, "Hello"_L1); // Text unchanged because undo removes what was added

    // Redo should add merged text
    commandFinishedSpy.clear();
    stack.redo();
    QVERIFY(commandFinishedSpy.wait(1000));
    QCOMPARE(text, "Hello Wo"_L1); // Should add the merged " Wo"

    // Test non-mergeable command
    auto nonMergeableCmd = std::make_shared<SCU::UndoRedoCommand>("Delete All"_L1);
    nonMergeableCmd->setExecuteFunction([&text](auto &) { text.clear(); });
    nonMergeableCmd->setRedoFunction([&text]() {
        text.clear();
        return SCU::Result<void>();
    });
    nonMergeableCmd->setUndoFunction([&text]() {
        text = "Hello"_L1;
        return SCU::Result<void>();
    });

    stack.push(nonMergeableCmd);
    QCOMPARE(stack.undoCount(), 2); // Should not merge, so now we have 2 commands
}

void TestUndoRedo::testQueryExecution()
{
    // Arrange
    SCU::QueryHandler handler;
    auto query = handler.createQuery<int>("Test Query"_L1);

    int computedValue = 0;
    query->setQueryFunction([&computedValue]() -> int {
        computedValue = 42;
        return computedValue;
    });

    QSignalSpy queryFinishedSpy(&handler, &SCU::QueryHandler::queryFinished);
    QSignalSpy queryBaseFinishedSpy(query.get(), &SCU::QueryBase::finished);

    QCOMPARE(query->description(), "Test Query"_L1);
    QVERIFY(!query->result().isValid()); // No result yet

    // Act
    handler.executeQuery(query);

    // Assert
    QVERIFY(queryFinishedSpy.wait(1000));
    QVERIFY(queryBaseFinishedSpy.count() >= 1);
    QCOMPARE(queryFinishedSpy.count(), 1);

    // Verify query finished with success
    auto args = queryFinishedSpy.takeFirst();
    QVERIFY(args.at(1).toBool()); // success = true

    // Check result
    QCOMPARE(computedValue, 42);
    QCOMPARE(query->typedResult(), 42);
    QCOMPARE(query->result().toInt(), 42);
}

void TestUndoRedo::testQueryThreadExecution()
{
    // Arrange
    QThread::currentThread()->setObjectName("MainThread"_L1);
    QString executionThread;

    SCU::QueryHandler handler;
    auto query = handler.createQuery<QString>("Thread Test Query"_L1);

    query->setQueryFunction([&executionThread]() -> QString {
        executionThread = QThread::currentThread()->objectName();
        return "ThreadResult"_L1;
    });

    QSignalSpy queryFinishedSpy(&handler, &SCU::QueryHandler::queryFinished);

    // Act
    handler.executeQuery(query);

    // Assert
    QVERIFY(queryFinishedSpy.wait(1000));
    QCOMPARE(queryFinishedSpy.count(), 1);

    // Verify execution on separate thread
    QVERIFY(executionThread != "MainThread"_L1);
    QCOMPARE(query->typedResult(), "ThreadResult"_L1);

    // Verify query finished with success
    auto args = queryFinishedSpy.takeFirst();
    QVERIFY(args.at(1).toBool()); // success = true
}

void TestUndoRedo::testServiceLocatorRegistration()
{
    // Arrange
    auto locator = std::make_unique<{{ s.global.application_pascal_name }}::Common::ServiceLocator>();
    auto undoRedoSystem = std::make_unique<SCU::UndoRedoSystem>();

    // Test initial state
    QVERIFY(locator->undoRedoSystem() == nullptr);

    // Act - Register undo/redo system
    locator->setUndoRedoSystem(undoRedoSystem.get());

    // Assert - Verify registration
    QVERIFY(locator->undoRedoSystem() != nullptr);
    QCOMPARE(locator->undoRedoSystem(), undoRedoSystem.get());

    // Test functionality through ServiceLocator
    auto retrievedSystem = locator->undoRedoSystem();
    QVERIFY(!retrievedSystem.isNull());
    QVERIFY(retrievedSystem->manager() != nullptr);
    QVERIFY(retrievedSystem->queryHandler() != nullptr);

    // Test command execution through ServiceLocator
    int testValue = 0;
    auto command = std::make_shared<SCU::UndoRedoCommand>("ServiceLocator Test Command"_L1);
    command->setExecuteFunction([&testValue](auto &) { testValue = 42; });
    command->setRedoFunction([&testValue]() {
        testValue = 42;
        return SCU::Result<void>();
    });
    command->setUndoFunction([&testValue]() {
        testValue = 0;
        return SCU::Result<void>();
    });

    // Execute command through the system retrieved from ServiceLocator
    int testStackId = 99;
    retrievedSystem->manager()->pushCommand(command, testStackId);

    // Verify command is registered but not executed yet
    QCOMPARE(testValue, 0);
    QVERIFY(retrievedSystem->manager()->canUndo(testStackId));
    QCOMPARE(retrievedSystem->manager()->undoCount(testStackId), 1);

    // Test query execution through ServiceLocator
    auto query = retrievedSystem->queryHandler()->createQuery<QString>("ServiceLocator Test Query"_L1);
    query->setQueryFunction([]() -> QString { return "ServiceLocator Works"_L1; });

    QSignalSpy queryFinishedSpy(retrievedSystem->queryHandler(), &SCU::QueryHandler::queryFinished);
    retrievedSystem->queryHandler()->executeQuery(query);

    QVERIFY(queryFinishedSpy.wait(1000));
    QCOMPARE(query->typedResult(), "ServiceLocator Works"_L1);

    // Cleanup - Clear the registration before objects are destroyed
    locator->setUndoRedoSystem(nullptr);
    QVERIFY(locator->undoRedoSystem() == nullptr);
}

QTEST_MAIN(TestUndoRedo)
#include "tst_undo_redo.moc"
