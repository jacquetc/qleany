{%- set_global root_undoable = false %}
{%- for eid, ent in s.entities %}
{%- if ent.pascal_name == "Root" %}{% set_global root_undoable = ent.inner.undoable %}{% endif %}
{%- endfor %}
#include "root/dtos.h"
#include "root/use_cases/create_orphans_uc.h"
#include "root/use_cases/i_root_unit_of_work.h"
{%- if root_undoable %}
#include "undo_redo/undo_redo_command.h"
{%- endif %}
#include <QObject>
{%- if root_undoable %}
#include <QSignalSpy>
{%- endif %}
#include <QTest>
#include <memory>

using namespace Qt::StringLiterals;

{%- if root_undoable %}
namespace SCU = {{ s.global.application_pascal_name }}::Common::UndoRedo;
{%- endif %}
namespace SDAR = {{ s.global.application_pascal_name }}::DirectAccess::Root;

// Mock unit of work for testing
class MockRootUnitOfWork : public SDAR::IRootUnitOfWork
{
  public:
    MockRootUnitOfWork() = default;

    bool beginTransaction() override
    {
        m_inTransaction = true;
        return true;
    }
    bool commit() override
    {
        m_inTransaction = false;
        return true;
    }
    bool endTransaction() override
    {
        m_inTransaction = false;
        return true;
    }
    bool rollback() override
    {
        m_inTransaction = false;
        return true;
    }

    void createSavepoint() override
    {
    }
    void rollbackToSavepoint() override
    {
    }
    void releaseSavepoint() override
    {
    }

    QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> createOrphans(const QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> &roots) override
    {
        QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> result;
        for (QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> mutRoots = roots; auto &root : mutRoots)
        {
            root.id = ++m_nextId;
            m_createdRoots.append(root);
            result.append(root);
        }
        return result;
    }

    QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> get(const QList<int> &rootIds) override
    {
        QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> result;
        for (const auto &root : m_createdRoots)
        {
            if (rootIds.contains(root.id))
            {
                result.append(root);
            }
        }
        return result;
    }

    QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> update(const QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> &roots) override
    {
        return roots; // Simple mock implementation
    }

    QList<int> remove(const QList<int> &rootIds) override
    {
        for (int id : rootIds)
        {
            m_createdRoots.removeIf([id](const auto &root) { return root.id == id; });
        }
        return rootIds;
    }

    {{ s.global.application_pascal_name }}::Common::Database::EntityTreeSnapshot snapshot(const QList<int> &ids) override
    {
        {{ s.global.application_pascal_name }}::Common::Database::EntityTreeSnapshot snap;
        snap.tableData.entityRows.tableName = "root"_L1;
        for (const auto &root : m_createdRoots)
        {
            if (ids.contains(root.id))
            {
                QVariantMap row;
                row.insert("id"_L1, root.id);
                // In a real mock we might need more fields, but for this test id should be enough
                // as CreateOrphanRootUseCase doesn't seem to use other fields from snapshot
                snap.tableData.entityRows.rows.append(row);
            }
        }
        return snap;
    }

    void restore(const {{ s.global.application_pascal_name }}::Common::Database::EntityTreeSnapshot &snap) override
    {
        for (const auto &row : snap.tableData.entityRows.rows)
        {
            int id = row.value("id"_L1).toInt();
            // Check if already exists (INSERT OR REPLACE behavior)
            auto it = std::ranges::find_if(m_createdRoots, [id](const auto &r) { return r.id == id; });
            if (it == m_createdRoots.end())
            {
                {{ s.global.application_pascal_name }}::Common::Entities::Root root;
                root.id = id;
                m_createdRoots.append(root);
            }
        }
    }

    QList<int> getRelationship(int rootId,
                                   {{ s.global.application_pascal_name }}::Common::DirectAccess::Root::RootRelationshipField relationship) override
    {
        Q_UNUSED(rootId)
        Q_UNUSED(relationship)
        return {};
    }

    void setRelationship(int rootId, {{ s.global.application_pascal_name }}::Common::DirectAccess::Root::RootRelationshipField relationship,
                             const QList<int> &relatedIds) override
    {
        Q_UNUSED(rootId)
        Q_UNUSED(relationship)
        Q_UNUSED(relatedIds)
    }

    QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> createdRoots() const
    {
        return m_createdRoots;
    }
    bool isInTransaction() const
    {
        return m_inTransaction;
    }
    QHash<int, QList<int>> getRelationshipMany(
        const QList<int> &rootIds, {{ s.global.application_pascal_name }}::Common::DirectAccess::Root::RootRelationshipField relationship) override
    {
        Q_UNUSED(rootIds)
        Q_UNUSED(relationship)
        return {};
    }
    int getRelationshipCount(int rootId,
                                 {{ s.global.application_pascal_name }}::Common::DirectAccess::Root::RootRelationshipField relationship) override
    {
        Q_UNUSED(rootId)
        Q_UNUSED(relationship)
        return 0;
    }
    QList<int> getRelationshipInRange(int rootId,
                                          {{ s.global.application_pascal_name }}::Common::DirectAccess::Root::RootRelationshipField relationship,
                                          int offset, int limit) override
    {
        Q_UNUSED(rootId)
        Q_UNUSED(relationship)
        Q_UNUSED(offset)
        Q_UNUSED(limit)
        return {};
    }

  private:
    QList<{{ s.global.application_pascal_name }}::Common::Entities::Root> m_createdRoots;
    int m_nextId = 0;
    bool m_inTransaction = false;
};

class TestRootUndoRedo : public QObject
{
    Q_OBJECT

  private Q_SLOTS:
    void testCreateOrphansUseCaseExecute();
{%- if root_undoable %}
    void testCreateOrphansUseCaseExecuteUndoRedo();
    void testCreateOrphansUseCaseWithCommand();
    void testCreateOrphansUseCaseUndoWithoutExecute();
{%- endif %}

  private:
};

void TestRootUndoRedo::testCreateOrphansUseCaseExecute()
{
    // Arrange
    auto mockUow = std::make_unique<MockRootUnitOfWork>();
    auto *uowPtr = mockUow.get();
    SDAR::CreateOrphanRootUseCase useCase(std::move(mockUow));

    QList<SDAR::CreateRootDto> createDtos;
    SDAR::CreateRootDto dto1;
    dto1.createdAt = QDateTime::currentDateTime();
    createDtos.append(dto1);

    // Act - Execute
    auto results = useCase.execute(createDtos);

    // Assert - Verify creation
    QCOMPARE(results.size(), 1);
    QVERIFY(results.first().id > 0);
    QCOMPARE(uowPtr->createdRoots().size(), 1);
}

{%- if root_undoable %}

void TestRootUndoRedo::testCreateOrphansUseCaseExecuteUndoRedo()
{
    // Arrange
    auto mockUow = std::make_unique<MockRootUnitOfWork>();
    auto *uowPtr = mockUow.get();
    SDAR::CreateOrphanRootUseCase useCase(std::move(mockUow));

    QList<SDAR::CreateRootDto> createDtos;
    SDAR::CreateRootDto dto1;
    dto1.createdAt = QDateTime::currentDateTime();
    createDtos.append(dto1);

    // Act - Execute
    auto results = useCase.execute(createDtos);

    // Assert - Verify creation
    QCOMPARE(results.size(), 1);
    QVERIFY(results.first().id > 0);
    QCOMPARE(uowPtr->createdRoots().size(), 1);

    // Act - Undo
    auto undoResult = useCase.undo();

    // Assert - Verify undo
    QVERIFY(undoResult.isSuccess());
    QCOMPARE(uowPtr->createdRoots().size(), 0);

    // Act - Redo
    auto redoResult = useCase.redo();

    // Assert - Verify redo
    QVERIFY(redoResult.isSuccess());
    QCOMPARE(uowPtr->createdRoots().size(), 1);
}

void TestRootUndoRedo::testCreateOrphansUseCaseWithCommand()
{
    // Arrange
    auto mockUow = std::make_unique<MockRootUnitOfWork>();
    auto *uowPtr = mockUow.get();
    auto useCase = std::make_shared<SDAR::CreateOrphanRootUseCase>(std::move(mockUow));

    QList<SDAR::CreateRootDto> createDtos;
    SDAR::CreateRootDto dto1;
    dto1.createdAt = QDateTime::currentDateTime();
    createDtos.append(dto1);

    auto command = std::make_shared<SCU::UndoRedoCommand>("Test CreateOrphans Command"_L1);
    QList<SDAR::RootDto> result;

    // Prepare lambdas
    command->setExecuteFunction([useCase, createDtos, &result](auto &) { result = useCase->execute(createDtos); });

    command->setRedoFunction([useCase, createDtos, &result]() { return useCase->redo(); });

    command->setUndoFunction([useCase]() -> SCU::Result<void> { return useCase->undo(); });

    QSignalSpy finishedSpy(command.get(), &SCU::UndoRedoCommand::finished);

    // Act - Execute command (redo)
    command->asyncExecute();
    QVERIFY(finishedSpy.wait(1000));

    // Assert - Verify execution
    QCOMPARE(result.size(), 1);
    QVERIFY(result.first().id > 0);
    QCOMPARE(uowPtr->createdRoots().size(), 1);

    // Act - Undo command
    finishedSpy.clear();
    command->asyncUndo();
    QVERIFY(finishedSpy.wait(1000));

    // Assert - Verify undo
    QCOMPARE(uowPtr->createdRoots().size(), 0);

    // Act - Redo command
    finishedSpy.clear();
    command->asyncRedo();
    QVERIFY(finishedSpy.wait(1000));

    // Assert - Verify redo
    QCOMPARE(uowPtr->createdRoots().size(), 1);
}

void TestRootUndoRedo::testCreateOrphansUseCaseUndoWithoutExecute()
{
    // Arrange
    auto mockUow = std::make_unique<MockRootUnitOfWork>();
    SDAR::CreateOrphanRootUseCase useCase(std::move(mockUow));

    // Act - Try to undo without execute
    auto undoResult = useCase.undo();

    // Assert - Should fail
    QVERIFY(!undoResult.isSuccess());
    QVERIFY(undoResult.error().contains("Cannot undo"_L1));
}
{%- endif %}

QTEST_MAIN(TestRootUndoRedo)
#include "tst_root_undo_redo.moc"
