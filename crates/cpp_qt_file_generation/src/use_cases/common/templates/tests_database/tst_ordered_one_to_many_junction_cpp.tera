#include "database/junction_table_ops/junction_cache.h"
#include "database/junction_table_ops/ordered_one_to_many.h"
#include "service_locator.h"
#include <QObject>
#include <QSignalSpy>
#include <QSqlDatabase>
#include <QSqlError>
#include <QSqlQuery>
#include <QString>
#include <QTest>
#include <QThread>
#include <memory>

using namespace Qt::StringLiterals;

namespace SCU = {{ s.global.application_pascal_name }}::Common::Database;
namespace JUNCTIONOPS = {{ s.global.application_pascal_name }}::Common::Database::JunctionTableOps;

class TestOrderedOneToManyJunction : public QObject
{
    Q_OBJECT

  private Q_SLOTS:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    // Test cases for getRightIds functions
    void testGetRightIds();
    void testGetRightIdsMany();
    void testGetRightIdsEmpty();
    void testGetRightIdsNonExistent();

    // Test cases for removeWithLeftIds functions
    void testRemoveWithLeftIds();
    void testRemoveWithLeftIdsMany();
    void testRemoveWithLeftIdsEmpty();
    void testRemoveWithLeftIdsNonExistent();

    // Test cases for removeWithRightIds functions
    void testRemoveWithRightIds();
    void testRemoveWithRightIdsMany();
    void testRemoveWithRightIdsEmpty();
    void testRemoveWithRightIdsNonExistent();

    // Test cases for upsertRightIds functions
    void testUpsertRightIds();
    void testUpsertRightIdsMany();
    void testUpsertRightIdsOptional();
    void testUpsertRightIdsEmpty();
    void testUpsertRightIdsOverwrite();
    void testUpsertRightIdsOrdering();

    // Test cases for getLeftId functions (one-to-many specific)
    void testGetLeftId();
    void testGetLeftIdMany();
    void testGetLeftIdEmpty();
    void testGetLeftIdNonExistent();
    void testGetLeftIdMultipleRightIds();

    // Test cases for getRightIdsCount
    void testGetRightIdsCount();
    void testGetRightIdsCountZero();
    void testGetRightIdsCountNonExistent();

    // Test cases for getRightIdsInRange
    void testGetRightIdsInRange();
    void testGetRightIdsInRangeOffset();
    void testGetRightIdsInRangeLimit();
    void testGetRightIdsInRangeEmpty();
    void testGetRightIdsInRangeOrdering();

    // Test edge cases specific to ordered one-to-many
    void testOneToManyConstraint();
    void testOrderingPreservation();
    void testCacheInvalidation();

  private:
    QString m_junctionTableName = "test_junction"_L1;
    QString m_junctionTableDefinition = "CREATE TABLE IF NOT EXISTS test_junction ("
                                        "    left_id INTEGER NOT NULL,"
                                        "    right_id INTEGER NOT NULL UNIQUE,"
                                        "    order_ INTEGER NOT NULL,"
                                        "    PRIMARY KEY (left_id, right_id)"
                                        ");"_L1;
    QSqlDatabase m_db;

    void setupDatabase();
    void insertTestData(const QList<QPair<int, QPair<int, int>>> &data);
    void clearJunctionTable();
};

void TestOrderedOneToManyJunction::initTestCase()
{
    std::string duration("20000"); // 20 seconds
    QByteArray timeoutDuration(duration.c_str(), static_cast<int>(duration.length()));
    qputenv("QTEST_FUNCTION_TIMEOUT", timeoutDuration);
}

void TestOrderedOneToManyJunction::cleanupTestCase()
{
    m_db.close();
}

void TestOrderedOneToManyJunction::init()
{
    setupDatabase();
}

void TestOrderedOneToManyJunction::cleanup()
{
    if (m_db.isOpen())
    {
        QString connectionName = m_db.connectionName();
        clearJunctionTable();
        {
            QSqlDatabase db = m_db;
            m_db = QSqlDatabase(); // Reset member to avoid dangling reference

            // Clear junction cache
            SCU::JunctionTableOps::JunctionCache::instance().clear();

            // Close and remove the database connection
            db.close();
        }
        QSqlDatabase::removeDatabase(connectionName);
    }
}

void TestOrderedOneToManyJunction::setupDatabase()
{
    // Generate a truly unique connection name using thread ID and timestamp
    QString connectionName = QString("TestOrderedOneToManyJunction_%1_%2"_L1)
                                 .arg(reinterpret_cast<quintptr>(QThread::currentThread()))
                                 .arg(QDateTime::currentMSecsSinceEpoch());

    m_db = QSqlDatabase::addDatabase("QSQLITE"_L1, connectionName);
    m_db.setDatabaseName(":memory:"_L1);
    QVERIFY(m_db.open());

    QSqlQuery createTableQuery(m_db);
    QVERIFY(createTableQuery.exec(m_junctionTableDefinition));
}

void TestOrderedOneToManyJunction::insertTestData(const QList<QPair<int, QPair<int, int>>> &data)
{
    QSqlQuery insertQuery(m_db);
    insertQuery.prepare("INSERT INTO test_junction (left_id, right_id, order_) VALUES (?, ?, ?)"_L1);

    for (const auto &entry : data)
    {
        insertQuery.addBindValue(entry.first);
        insertQuery.addBindValue(entry.second.first);
        insertQuery.addBindValue(entry.second.second);
        QVERIFY(insertQuery.exec());
    }
}

void TestOrderedOneToManyJunction::clearJunctionTable()
{
    QSqlQuery clearQuery(m_db);
    QVERIFY(clearQuery.exec("DELETE FROM test_junction"_L1));
}

// Test getRightIds functions
void TestOrderedOneToManyJunction::testGetRightIds()
{
    // Test data: left_id=1 should return right_ids [10, 20, 30] in order
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {1, {30, 2000}} });

    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QList<int> expected = {10, 20, 30};
    QCOMPARE(result, expected);
}

void TestOrderedOneToManyJunction::testGetRightIdsMany()
{
    // Test data for multiple left_ids with ordering
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {1, {30, 2000}}, {2, {40, 0}}, {2, {50, 1000}}, {3, {60, 0}} });

    QHash<int, QList<int>> result =
        JUNCTIONOPS::OrderedOneToMany::getRightIdsMany(m_db, {1, 2, 3}, m_junctionTableName);

    QCOMPARE(result[1], QList<int>({10, 20, 30}));
    QCOMPARE(result[2], QList<int>({40, 50}));
    QCOMPARE(result[3], QList<int>({60}));
}

void TestOrderedOneToManyJunction::testGetRightIdsEmpty()
{
    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QVERIFY(result.isEmpty());
}

void TestOrderedOneToManyJunction::testGetRightIdsNonExistent()
{
    insertTestData({ {1, {10, 0}} });

    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 999, m_junctionTableName);
    QVERIFY(result.isEmpty());
}

// Test removeWithLeftIds functions
void TestOrderedOneToManyJunction::testRemoveWithLeftIds()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {2, {30, 0}} });

    bool result = JUNCTIONOPS::OrderedOneToMany::removeWithLeftIds(m_db, 1, m_junctionTableName);
    QVERIFY(result);

    QList<int> remainingForLeft1 = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QVERIFY(remainingForLeft1.isEmpty());

    QList<int> remainingForLeft2 = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 2, m_junctionTableName);
    QCOMPARE(remainingForLeft2, QList<int>({30}));
}

void TestOrderedOneToManyJunction::testRemoveWithLeftIdsMany()
{
    insertTestData({ {1, {10, 0}}, {2, {20, 0}}, {3, {30, 0}} });

    QHash<int, bool> result = JUNCTIONOPS::OrderedOneToMany::removeWithLeftIdsMany(m_db, {1, 2}, m_junctionTableName);
    QCOMPARE(result[1], true);
    QCOMPARE(result[2], true);

    QVERIFY(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName).isEmpty());
    QVERIFY(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 2, m_junctionTableName).isEmpty());
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 3, m_junctionTableName), QList<int>({30}));
}

void TestOrderedOneToManyJunction::testRemoveWithLeftIdsEmpty()
{
    QHash<int, bool> result = JUNCTIONOPS::OrderedOneToMany::removeWithLeftIdsMany(m_db, {}, m_junctionTableName);
    QVERIFY(result.isEmpty());
}

void TestOrderedOneToManyJunction::testRemoveWithLeftIdsNonExistent()
{
    bool result = JUNCTIONOPS::OrderedOneToMany::removeWithLeftIds(m_db, 999, m_junctionTableName);
    QVERIFY(result); // Should succeed even if nothing to remove
}

// Test removeWithRightIds functions
void TestOrderedOneToManyJunction::testRemoveWithRightIds()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {2, {30, 0}} });

    bool result = JUNCTIONOPS::OrderedOneToMany::removeWithRightIds(m_db, 10, m_junctionTableName);
    QVERIFY(result);

    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName), QList<int>({20}));
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 2, m_junctionTableName), QList<int>({30}));
}

void TestOrderedOneToManyJunction::testRemoveWithRightIdsMany()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {2, {40, 0}}, {2, {30, 1000}} });

    QHash<int, bool> result =
        JUNCTIONOPS::OrderedOneToMany::removeWithRightIdsMany(m_db, {10, 20}, m_junctionTableName);
    QCOMPARE(result[10], true);
    QCOMPARE(result[20], true);

    QVERIFY(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName).isEmpty());
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 2, m_junctionTableName), QList<int>({40, 30}));
}

void TestOrderedOneToManyJunction::testRemoveWithRightIdsEmpty()
{
    QHash<int, bool> result = JUNCTIONOPS::OrderedOneToMany::removeWithRightIdsMany(m_db, {}, m_junctionTableName);
    QVERIFY(result.isEmpty());
}

void TestOrderedOneToManyJunction::testRemoveWithRightIdsNonExistent()
{
    bool result = JUNCTIONOPS::OrderedOneToMany::removeWithRightIds(m_db, 999, m_junctionTableName);
    QVERIFY(result); // Should succeed even if nothing to remove
}

// Test upsertRightIds functions
void TestOrderedOneToManyJunction::testUpsertRightIds()
{
    QList<int> rightIds = {10, 20, 30};
    QList<int> result = JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, rightIds);
    QCOMPARE(result, rightIds);

    QList<int> retrieved = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QCOMPARE(retrieved, rightIds);
}

void TestOrderedOneToManyJunction::testUpsertRightIdsMany()
{
    QHash<int, QList<int>> input;
    input[1] = {10, 20};
    input[2] = {30, 40, 50};

    QHash<int, QList<int>> result = JUNCTIONOPS::OrderedOneToMany::upsertRightIdsMany(m_db, input, m_junctionTableName);
    QCOMPARE(result[1], QList<int>({10, 20}));
    QCOMPARE(result[2], QList<int>({30, 40, 50}));

    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName), QList<int>({10, 20}));
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 2, m_junctionTableName), QList<int>({30, 40, 50}));
}

void TestOrderedOneToManyJunction::testUpsertRightIdsOptional()
{
    // Test with nullopt
    std::optional<QList<int>> nullOpt;
    QList<int> result = JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, nullOpt);
    QVERIFY(result.isEmpty());

    // Test with value
    std::optional<QList<int>> withValue = QList<int>({10, 20});
    result = JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, withValue);
    QCOMPARE(result, QList<int>({10, 20}));
}

void TestOrderedOneToManyJunction::testUpsertRightIdsEmpty()
{
    QList<int> emptyList;
    QList<int> result = JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, emptyList);
    QVERIFY(result.isEmpty());

    QVERIFY(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName).isEmpty());
}

void TestOrderedOneToManyJunction::testUpsertRightIdsOverwrite()
{
    // Insert initial data
    JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, {10, 20});
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName), QList<int>({10, 20}));

    // Overwrite with new data
    QList<int> newRightIds = {30, 40, 50};
    JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, newRightIds);
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName), newRightIds);
}

void TestOrderedOneToManyJunction::testUpsertRightIdsOrdering()
{
    QList<int> rightIds = {30, 10, 20}; // Intentionally not in numeric order
    JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, rightIds);

    // Should preserve the insertion order
    QList<int> retrieved = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QCOMPARE(retrieved, rightIds); // Should maintain 30, 10, 20 order
}

// Test getLeftId functions
void TestOrderedOneToManyJunction::testGetLeftId()
{
    insertTestData({ {1, {10, 0}}, {2, {20, 0}} });

    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getLeftId(m_db, m_junctionTableName, 10), 1);
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getLeftId(m_db, m_junctionTableName, 20), 2);
}

void TestOrderedOneToManyJunction::testGetLeftIdMany()
{
    insertTestData({ {1, {10, 0}}, {2, {20, 0}}, {3, {30, 0}} });

    QMap<int, int> result = JUNCTIONOPS::OrderedOneToMany::getLeftIdMany(m_db, m_junctionTableName, {10, 20, 30});
    QCOMPARE(result[10], 1);
    QCOMPARE(result[20], 2);
    QCOMPARE(result[30], 3);
}

void TestOrderedOneToManyJunction::testGetLeftIdEmpty()
{
    QMap<int, int> result = JUNCTIONOPS::OrderedOneToMany::getLeftIdMany(m_db, m_junctionTableName, {});
    QVERIFY(result.isEmpty());
}

void TestOrderedOneToManyJunction::testGetLeftIdNonExistent()
{
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getLeftId(m_db, m_junctionTableName, 999), -1);
}

void TestOrderedOneToManyJunction::testGetLeftIdMultipleRightIds()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}} });

    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getLeftId(m_db, m_junctionTableName, 10), 1);
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getLeftId(m_db, m_junctionTableName, 20), 1);
}

// Test getRightIdsCount
void TestOrderedOneToManyJunction::testGetRightIdsCount()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {1, {30, 2000}} });

    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIdsCount(m_db, 1, m_junctionTableName), 3);
}

void TestOrderedOneToManyJunction::testGetRightIdsCountZero()
{
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIdsCount(m_db, 1, m_junctionTableName), 0);
}

void TestOrderedOneToManyJunction::testGetRightIdsCountNonExistent()
{
    insertTestData({ {1, {10, 0}} });
    QCOMPARE(JUNCTIONOPS::OrderedOneToMany::getRightIdsCount(m_db, 999, m_junctionTableName), 0);
}

// Test getRightIdsInRange
void TestOrderedOneToManyJunction::testGetRightIdsInRange()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {1, {30, 2000}}, {1, {40, 3000}}, {1, {50, 4000}} });

    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIdsInRange(m_db, 1, m_junctionTableName, 0, 3);
    QCOMPARE(result, QList<int>({10, 20, 30}));
}

void TestOrderedOneToManyJunction::testGetRightIdsInRangeOffset()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {1, {30, 2000}}, {1, {40, 3000}} });

    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIdsInRange(m_db, 1, m_junctionTableName, 2, 2);
    QCOMPARE(result, QList<int>({30, 40}));
}

void TestOrderedOneToManyJunction::testGetRightIdsInRangeLimit()
{
    insertTestData({ {1, {10, 0}}, {1, {20, 1000}}, {1, {30, 2000}} });

    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIdsInRange(m_db, 1, m_junctionTableName, 0, 2);
    QCOMPARE(result, QList<int>({10, 20}));
}

void TestOrderedOneToManyJunction::testGetRightIdsInRangeEmpty()
{
    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIdsInRange(m_db, 1, m_junctionTableName, 0, 5);
    QVERIFY(result.isEmpty());
}

void TestOrderedOneToManyJunction::testGetRightIdsInRangeOrdering()
{
    // Insert in non-sequential order values but with proper order_ values
    insertTestData({ {1, {50, 0}}, {1, {30, 1000}}, {1, {10, 2000}}, {1, {40, 3000}} });

    QList<int> result = JUNCTIONOPS::OrderedOneToMany::getRightIdsInRange(m_db, 1, m_junctionTableName, 0, 4);
    QCOMPARE(result, QList<int>({50, 30, 10, 40})); // Should respect order_ column
}

// Test edge cases
void TestOrderedOneToManyJunction::testOneToManyConstraint()
{
    // In one-to-many, each right_id can only belong to one left_id
    insertTestData({ {1, {10, 0}} });

    // Try to insert the same right_id with a different left_id - should fail due to UNIQUE constraint
    QSqlQuery conflictQuery(m_db);
    conflictQuery.prepare("INSERT INTO test_junction (left_id, right_id, order_) VALUES (?, ?, ?)"_L1);
    conflictQuery.addBindValue(2);
    conflictQuery.addBindValue(10); // Same right_id
    conflictQuery.addBindValue(0);

    QVERIFY(!conflictQuery.exec()); // Should fail due to UNIQUE constraint on right_id
}

void TestOrderedOneToManyJunction::testOrderingPreservation()
{
    QList<int> originalOrder = {100, 50, 200, 25, 300};
    JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, originalOrder);

    QList<int> retrieved = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QCOMPARE(retrieved, originalOrder);

    // Test with getRightIdsInRange
    QList<int> partial = JUNCTIONOPS::OrderedOneToMany::getRightIdsInRange(m_db, 1, m_junctionTableName, 1, 3);
    QCOMPARE(partial, QList<int>({50, 200, 25}));
}

void TestOrderedOneToManyJunction::testCacheInvalidation()
{
    // Insert initial data
    JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, {10, 20});

    // Get data to populate cache
    QList<int> initial = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QCOMPARE(initial, QList<int>({10, 20}));

    // Update data - cache should be invalidated
    JUNCTIONOPS::OrderedOneToMany::upsertRightIds(m_db, 1, m_junctionTableName, {30, 40});

    // Should get new data, not cached
    QList<int> updated = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QCOMPARE(updated, QList<int>({30, 40}));

    // Remove data - cache should be invalidated
    JUNCTIONOPS::OrderedOneToMany::removeWithLeftIds(m_db, 1, m_junctionTableName);

    QList<int> afterRemoval = JUNCTIONOPS::OrderedOneToMany::getRightIds(m_db, 1, m_junctionTableName);
    QVERIFY(afterRemoval.isEmpty());
}

QTEST_MAIN(TestOrderedOneToManyJunction)

#include "tst_ordered_one_to_many_junction.moc"