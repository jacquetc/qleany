#include "long_operation/long_operation_manager.h"

#include <QtConcurrent>

namespace {{ s.global.application_pascal_name }}::Common::LongOperation
{

LongOperationManager::LongOperationManager(QObject *parent)
    : QObject(parent)
{
}

LongOperationManager::~LongOperationManager()
{
    // Cancel all running operations
    for (auto it = m_running.begin(); it != m_running.end(); ++it)
    {
        it->cancelFlag->store(true);
        if (it->watcher)
        {
            it->watcher->waitForFinished();
            delete it->watcher;
        }
    }
}

QString LongOperationManager::startOperation(std::shared_ptr<ILongOperation> operation)
{
    const QString operationId = QString::number(m_nextId++);

    RunningOperation entry;
    entry.operation = std::move(operation);
    entry.cancelFlag = std::make_shared<std::atomic<bool>>(false);
    entry.watcher = new QFutureWatcher<QJsonObject>(this);

    auto cancelFlag = entry.cancelFlag;
    auto op = entry.operation;

    // Progress callback â€” marshalled to main thread via signal
    auto progressCallback = [this, operationId](const OperationProgress &progress) {
        QMetaObject::invokeMethod(this, [this, operationId, progress]() {
            Q_EMIT progressChanged(operationId, progress);
        }, Qt::QueuedConnection);
    };

    // Connect watcher finished signal
    connect(entry.watcher, &QFutureWatcher<QJsonObject>::finished, this,
            [this, operationId]() {
                auto it = m_running.find(operationId);
                if (it == m_running.end())
                    return;

                auto *watcher = it->watcher;
                const bool wasCancelled = it->cancelFlag->load();
                m_running.erase(it);

                try
                {
                    const QJsonObject result = watcher->result();
                    if (wasCancelled)
                        Q_EMIT operationCancelled(operationId);
                    else
                        Q_EMIT operationCompleted(operationId, result);
                }
                catch (const std::exception &e)
                {
                    Q_EMIT operationFailed(operationId, QString::fromUtf8(e.what()));
                }
                watcher->deleteLater();
            });

    // Launch on thread pool
    QFuture<QJsonObject> future = QtConcurrent::run(
        [op, progressCallback, cancelFlag]() -> QJsonObject {
            return op->execute(progressCallback, *cancelFlag);
        });

    entry.watcher->setFuture(future);
    m_running.insert(operationId, std::move(entry));

    return operationId;
}

void LongOperationManager::cancelOperation(const QString &operationId)
{
    auto it = m_running.find(operationId);
    if (it != m_running.end())
        it->cancelFlag->store(true);
}

bool LongOperationManager::isRunning(const QString &operationId) const
{
    return m_running.contains(operationId);
}

} // namespace {{ s.global.application_pascal_name }}::Common::LongOperation
