#pragma once

#include <QObject>
#include <QPointer>

#include <functional>
#include <mutex>
#include <vector>

namespace {{ s.global.application_pascal_name }}::Common
{

/**
 * @brief Thread-safe signal buffer for deferring event emissions during transactions.
 *
 * Repositories route their QMetaObject::invokeMethod calls through this buffer.
 * When buffering is active (between beginBuffering() and flush()/discard()),
 * emit callbacks are queued instead of delivered immediately.
 *
 * On flush() (after successful commit), all queued callbacks are executed.
 * On discard() (after rollback), all queued callbacks are dropped.
 *
 * Inherits QObject so that QPointer<SignalBuffer> works for safe null-checking.
 */
class SignalBuffer : public QObject
{
    Q_OBJECT
  public:
    explicit SignalBuffer(QObject *parent = nullptr) : QObject(parent) {}
    ~SignalBuffer() override = default;

    void beginBuffering()
    {
        std::lock_guard lock(m_mutex);
        m_buffering = true;
        m_pending.clear();
    }

    /**
     * @brief Queue a callback for deferred delivery.
     *
     * If buffering is not active, the callback is executed immediately.
     */
    void push(std::function<void()> callback)
    {
        std::lock_guard lock(m_mutex);
        if (m_buffering)
            m_pending.push_back(std::move(callback));
        else
            callback();
    }

    /**
     * @brief Deliver all queued callbacks and stop buffering.
     */
    void flush()
    {
        std::vector<std::function<void()>> toDeliver;
        {
            std::lock_guard lock(m_mutex);
            m_buffering = false;
            toDeliver.swap(m_pending);
        }
        for (auto &cb : toDeliver)
            cb();
    }

    /**
     * @brief Discard all queued callbacks and stop buffering.
     */
    void discard()
    {
        std::lock_guard lock(m_mutex);
        m_buffering = false;
        m_pending.clear();
    }

    [[nodiscard]] bool isBuffering() const
    {
        std::lock_guard lock(m_mutex);
        return m_buffering;
    }

  private:
    mutable std::mutex m_mutex;
    bool m_buffering = false;
    std::vector<std::function<void()>> m_pending;
};

} // namespace {{ s.global.application_pascal_name }}::Common
