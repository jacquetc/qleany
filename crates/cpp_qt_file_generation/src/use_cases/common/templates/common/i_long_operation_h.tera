#pragma once

#include <QJsonObject>
#include <QObject>
#include <QString>

#include <atomic>
#include <functional>

namespace {{ s.global.application_pascal_name }}::Common::LongOperation
{

/**
 * @brief Progress information for a long-running operation.
 */
struct OperationProgress
{
    Q_GADGET
    Q_PROPERTY(int current MEMBER current)
    Q_PROPERTY(int total MEMBER total)
    Q_PROPERTY(QString message MEMBER message)
    Q_PROPERTY(double percentage READ percentage)

  public:
    int current = 0;       ///< Current progress value
    int total = 0;         ///< Total progress value
    QString message;       ///< Human-readable status message

    [[nodiscard]] double percentage() const
    {
        return total > 0 ? (static_cast<double>(current) / total) * 100.0 : 0.0;
    }
};

/**
 * @brief Abstract interface for long-running operations.
 *
 * Implement this interface for operations that should run on a background thread
 * with progress reporting and cancellation support.
 *
 * Example:
 * @code
 * @endcode
 */
class ILongOperation
{
  public:
    virtual ~ILongOperation() = default;

    /**
     * @brief Execute the long-running operation.
     *
     * @param progressCallback Function to call with progress updates.
     *        Thread-safe: the LongOperationManager marshals these to the main thread.
     * @param cancelFlag Atomic flag that becomes true when cancellation is requested.
     *        Implementations should check this periodically and abort gracefully.
     * @return QJsonObject containing the operation result.
     */
    virtual QJsonObject execute(
        std::function<void(OperationProgress)> progressCallback,
        const std::atomic<bool> &cancelFlag) = 0;
};

} // namespace {{ s.global.application_pascal_name }}::Common::LongOperation
