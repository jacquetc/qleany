#pragma once

#include "long_operation/i_long_operation.h"

#include <QFutureWatcher>
#include <QObject>
#include <QString>

#include <atomic>
#include <memory>

namespace {{ s.global.application_pascal_name }}::Common::LongOperation
{

/**
 * @brief Manages execution of long-running operations on background threads.
 *
 * Provides:
 * - Background execution via QtConcurrent::run
 * - Progress reporting marshalled to the main thread
 * - Cancellation support via atomic flag
 * - Completion/failure/cancellation signals
 *
 * Usage from a controller:
 * @code
 *   auto operation = std::make_shared<MyLongOperation>(std::move(uow), dto);
 *   QString operationId = m_longOperationManager->startOperation(std::move(operation));
 *   // operationId can be returned to the caller for tracking
 * @endcode
 */
class LongOperationManager : public QObject
{
    Q_OBJECT
  public:
    explicit LongOperationManager(QObject *parent = nullptr);
    ~LongOperationManager() override;

    /**
     * @brief Start a long operation on a background thread.
     * @param operation The operation to execute. Ownership is shared.
     * @return A unique operation identifier string.
     */
    QString startOperation(std::shared_ptr<ILongOperation> operation);

    /**
     * @brief Request cancellation of a running operation.
     * @param operationId The identifier returned by startOperation().
     */
    void cancelOperation(const QString &operationId);

    /**
     * @brief Check if an operation is currently running.
     */
    [[nodiscard]] bool isRunning(const QString &operationId) const;

  Q_SIGNALS:
    void progressChanged(const QString &operationId, const OperationProgress &progress);
    void operationCompleted(const QString &operationId, const QJsonObject &result);
    void operationFailed(const QString &operationId, const QString &error);
    void operationCancelled(const QString &operationId);

  private:
    struct RunningOperation
    {
        std::shared_ptr<ILongOperation> operation;
        std::shared_ptr<std::atomic<bool>> cancelFlag;
        QFutureWatcher<QJsonObject> *watcher = nullptr;
    };

    QHash<QString, RunningOperation> m_running;
    int m_nextId = 1;
};

} // namespace {{ s.global.application_pascal_name }}::Common::LongOperation
