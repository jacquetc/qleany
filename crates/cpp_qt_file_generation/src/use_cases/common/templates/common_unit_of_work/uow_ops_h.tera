/******************************************************************************
 * UoW Operations - Template Interfaces, CRTP Implementations & Concepts
 *
 * Provides a type-safe, IDE-friendly alternative to the preprocessor macros
 * for GENERATED per-entity UoW classes. Custom multi-entity UoWs should
 * continue using the atomic macros in uow_macros.h.
 *
 * Architecture:
 *
 *   IEntityCrud<Entity>                          (pure virtual interface)
 *       ^                                         
 *       |-- IEntityWithRelationships<Entity, Rel> (extends with relationship ops)
 *       |
 *   EntityCrudImpl<Derived, Entity>              (CRTP providing overrides)
 *       ^
 *       |-- EntityFullImpl<Derived, Entity, Rel> (CRTP with relationships)
 *
 * Usage in generated code:
 *
 *   // Interface (i_person_unit_of_work.h):
 *   using IPersonUnitOfWork = SCUoW::IEntityCrud<SCE::Person>;
 *
 *   // Implementation (person_unit_of_work.h):
 *   class PersonUnitOfWork final
 *       : public SCUoW::UnitOfWorkBase,
 *         public SCUoW::EntityCrudImpl<PersonUnitOfWork, SCE::Person>
 *   {
 *   public:
 *       PersonUnitOfWork(SCDatabase::DbContext &db, QPointer<SCD::EventRegistry> er)
 *           : UnitOfWorkBase(db, er) {}
 *
 *       [[nodiscard]] auto makeRepository() {
 *           return SCD::RepositoryFactory::createPersonRepository(
 *               m_dbSubContext, m_eventRegistry);
 *       }
 *   };
 *
 * The CRTP base calls Derived::makeRepository() to obtain the repository,
 * then delegates CRUD/relationship operations to it.
 ******************************************************************************/

#pragma once

#include "uow_base.h"
#include <QHash>
#include <QList>
#include <concepts>
#include <type_traits>

namespace {{ s.global.application_pascal_name }}::Common::UnitOfWork
{

// =============================================================================
// Template Interfaces
// =============================================================================

/**
 * @brief Pure virtual CRUD interface for a single entity type.
 *
 * Inherits ITransactional virtually so that concrete classes only need one
 * ITransactional implementation (provided by UnitOfWorkBase).
 */
template <typename EntityType>
class IEntityCrud : public virtual ITransactional
{
  public:
    ~IEntityCrud() override = default;

    [[nodiscard]] virtual QList<EntityType> create(const QList<EntityType> &items) = 0;
    [[nodiscard]] virtual QList<EntityType> get(const QList<int> &ids) = 0;
    [[nodiscard]] virtual QList<EntityType> update(const QList<EntityType> &items) = 0;
    [[nodiscard]] virtual QList<int> remove(const QList<int> &ids) = 0;
};

/**
 * @brief Pure virtual CRUD + relationship interface for a single entity type.
 */
template <typename EntityType, typename RelFieldEnum>
class IEntityWithRelationships : public IEntityCrud<EntityType>
{
  public:
    ~IEntityWithRelationships() override = default;

    [[nodiscard]] virtual QList<int> getRelationship(int id, RelFieldEnum rel) = 0;
    virtual void setRelationship(int id, RelFieldEnum rel, const QList<int> &relatedIds) = 0;
    [[nodiscard]] virtual QHash<int, QList<int>> getRelationshipMany(const QList<int> &ids, RelFieldEnum rel) = 0;
    [[nodiscard]] virtual int getRelationshipCount(int id, RelFieldEnum rel) = 0;
    [[nodiscard]] virtual QList<int> getRelationshipInRange(int id, RelFieldEnum rel, int offset, int limit) = 0;
};

// =============================================================================
// C++20 Concepts
// =============================================================================

/**
 * @brief Concept satisfied by any type providing CRUD operations for EntityType.
 */
template <typename T, typename EntityType>
concept EntityCrudCapable = requires(T &t, const QList<EntityType> &items, const QList<int> &ids) {
    { t.create(items) } -> std::same_as<QList<EntityType>>;
    { t.get(ids) } -> std::same_as<QList<EntityType>>;
    { t.update(items) } -> std::same_as<QList<EntityType>>;
    { t.remove(ids) } -> std::same_as<QList<int>>;
};

/**
 * @brief Concept satisfied by any type providing relationship operations.
 */
template <typename T, typename EntityType, typename RelFieldEnum>
concept EntityRelationshipCapable =
    EntityCrudCapable<T, EntityType> &&
    requires(T &t, int id, RelFieldEnum rel, const QList<int> &ids, int offset, int limit) {
        { t.getRelationship(id, rel) } -> std::same_as<QList<int>>;
        { t.setRelationship(id, rel, ids) } -> std::same_as<void>;
        { t.getRelationshipMany(ids, rel) } -> std::same_as<QHash<int, QList<int>>>;
        { t.getRelationshipCount(id, rel) } -> std::same_as<int>;
        { t.getRelationshipInRange(id, rel, offset, limit) } -> std::same_as<QList<int>>;
    };

/**
 * @brief Concept for any type that can serve as a transactional UoW with CRUD.
 *
 * Use in use-case constructors:
 *   template <TransactionalCrud<Person> UoW>
 *   explicit CreatePersonUseCase(std::unique_ptr<UoW> uow);
 */
template <typename T, typename EntityType>
concept TransactionalCrud =
    std::derived_from<T, ITransactional> && EntityCrudCapable<T, EntityType>;

template <typename T, typename EntityType, typename RelFieldEnum>
concept TransactionalFull =
    std::derived_from<T, ITransactional> && EntityRelationshipCapable<T, EntityType, RelFieldEnum>;

// =============================================================================
// CRTP Implementations
// =============================================================================

/**
 * @brief CRTP mixin providing CRUD overrides.
 *
 * Requires: Derived must expose a `makeRepository()` method returning a
 * unique_ptr to a repository with create/get/update/remove methods.
 *
 * Derived must also inherit from UnitOfWorkBase (for m_dbSubContext,
 * m_eventRegistry access via makeRepository).
 */
template <typename Derived, typename EntityType>
class EntityCrudImpl : public virtual IEntityCrud<EntityType>
{
  public:
    ~EntityCrudImpl() override = default;

    [[nodiscard]] QList<EntityType> create(const QList<EntityType> &items) override
    {
        auto repo = self().makeRepository();
        return repo->create(items);
    }

    [[nodiscard]] QList<EntityType> get(const QList<int> &ids) override
    {
        auto repo = self().makeRepository();
        return repo->get(ids);
    }

    [[nodiscard]] QList<EntityType> update(const QList<EntityType> &items) override
    {
        auto repo = self().makeRepository();
        return repo->update(items);
    }

    [[nodiscard]] QList<int> remove(const QList<int> &ids) override
    {
        auto repo = self().makeRepository();
        return repo->remove(ids);
    }

  private:
    Derived &self() { return static_cast<Derived &>(*this); }
};

/**
 * @brief CRTP mixin providing full CRUD + relationship overrides.
 *
 * Same requirements as EntityCrudImpl. The repository returned by
 * makeRepository() must additionally support relationship methods.
 */
template <typename Derived, typename EntityType, typename RelFieldEnum>
class EntityFullImpl : public virtual IEntityWithRelationships<EntityType, RelFieldEnum>
{
  public:
    ~EntityFullImpl() override = default;

    // CRUD
    [[nodiscard]] QList<EntityType> create(const QList<EntityType> &items) override
    {
        auto repo = self().makeRepository();
        return repo->create(items);
    }

    [[nodiscard]] QList<EntityType> get(const QList<int> &ids) override
    {
        auto repo = self().makeRepository();
        return repo->get(ids);
    }

    [[nodiscard]] QList<EntityType> update(const QList<EntityType> &items) override
    {
        auto repo = self().makeRepository();
        return repo->update(items);
    }

    [[nodiscard]] QList<int> remove(const QList<int> &ids) override
    {
        auto repo = self().makeRepository();
        return repo->remove(ids);
    }

    // Relationships
    [[nodiscard]] QList<int> getRelationship(int id, RelFieldEnum rel) override
    {
        auto repo = self().makeRepository();
        return repo->getRelationshipIds(id, rel);
    }

    void setRelationship(int id, RelFieldEnum rel, const QList<int> &relatedIds) override
    {
        auto repo = self().makeRepository();
        repo->setRelationshipIds(id, rel, relatedIds);
    }

    [[nodiscard]] QHash<int, QList<int>> getRelationshipMany(const QList<int> &ids, RelFieldEnum rel) override
    {
        auto repo = self().makeRepository();
        return repo->getRelationshipIdsMany(ids, rel);
    }

    [[nodiscard]] int getRelationshipCount(int id, RelFieldEnum rel) override
    {
        auto repo = self().makeRepository();
        return repo->getRelationshipIdsCount(id, rel);
    }

    [[nodiscard]] QList<int> getRelationshipInRange(int id, RelFieldEnum rel, int offset, int limit) override
    {
        auto repo = self().makeRepository();
        return repo->getRelationshipIdsInRange(id, rel, offset, limit);
    }

  private:
    Derived &self() { return static_cast<Derived &>(*this); }
};

} // namespace {{ s.global.application_pascal_name }}::Common::UnitOfWork
