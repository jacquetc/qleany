/******************************************************************************
 * Unit of Work Base - Transaction Management
 *
 * This file provides:
 * - Transaction interface (ITransactional)
 * - Base implementation class (UnitOfWorkBase)
 *
 * UnitOfWorkBase inherits ITransactional virtually so that concrete UoW
 * classes automatically satisfy the ITransactional requirement without
 * explicit delegation macros.
 ******************************************************************************/

#pragma once

#include "database/db_context.h"
#include "database/snapshot_types.h"
#include "direct_access/event_registry.h"
#include "signal_buffer.h"

#include <QHash>
#include <QList>
#include <QPointer>

namespace {{ s.global.application_pascal_name }}::Common::UnitOfWork
{

namespace SCDatabase = {{ s.global.application_pascal_name }}::Common::Database;
namespace SCD = {{ s.global.application_pascal_name }}::Common::DirectAccess;

/**
 * @brief Interface for transaction operations
 *
 * All UoW interfaces should inherit from this (virtually) to get standard
 * transaction methods.
 */
class ITransactional
{
  public:
    virtual ~ITransactional() = default;
    [[nodiscard]] virtual bool beginTransaction() = 0;
    [[nodiscard]] virtual bool commit() = 0;
    [[nodiscard]] virtual bool endTransaction() = 0;
    virtual bool rollback() = 0;
    virtual void createSavepoint() = 0;
    virtual void rollbackToSavepoint() = 0;
    virtual void releaseSavepoint() = 0;
};

/**
 * @brief Base class providing transaction management for Unit of Work implementations
 *
 * Inherits ITransactional virtually and provides all transaction overrides.
 * Concrete UoW classes inherit from this and from their entity-specific interface;
 * virtual inheritance ensures a single ITransactional vtable entry.
 *
 * The DbSubContext is managed internally and provides connection lifecycle management.
 */
class UnitOfWorkBase : public virtual ITransactional
{
  public:
    UnitOfWorkBase(SCDatabase::DbContext &dbContext, QPointer<SCD::EventRegistry> eventRegistry)
        : m_dbSubContext(SCDatabase::DbSubContext(dbContext)), m_eventRegistry(std::move(eventRegistry)),
          m_signalBuffer(new SignalBuffer())
    {
    }

    ~UnitOfWorkBase() override
    {
        delete m_signalBuffer;
    }

    // ITransactional overrides â€” all forwarded to DbSubContext
    // Signal buffering is integrated into transaction lifecycle
    [[nodiscard]] bool beginTransaction() override
    {
        if (!m_dbSubContext.beginTransaction())
            return false;
        m_signalBuffer->beginBuffering();
        return true;
    }
    [[nodiscard]] bool commit() override
    {
        bool ok = m_dbSubContext.commit();
        if (ok)
            m_signalBuffer->flush();
        else
            m_signalBuffer->discard();
        return ok;
    }
    [[nodiscard]] bool endTransaction() override
    {
        return commit();
    }
    bool rollback() override
    {
        m_dbSubContext.rollback();
        m_signalBuffer->discard();
        return true;
    }
    void createSavepoint() override { m_dbSubContext.createSavepoint(); }
    void rollbackToSavepoint() override { m_dbSubContext.rollbackToSavepoint(); }
    void releaseSavepoint() override { m_dbSubContext.releaseSavepoint(); }

  protected:
    SCDatabase::DbSubContext m_dbSubContext;
    QPointer<SCD::EventRegistry> m_eventRegistry;
    QPointer<SignalBuffer> m_signalBuffer;
};

} // namespace {{ s.global.application_pascal_name }}::Common::UnitOfWork
