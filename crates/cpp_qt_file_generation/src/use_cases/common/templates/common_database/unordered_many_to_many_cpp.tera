#include "unordered_many_to_many.h"
#include "junction_cache.h"
#include <QSqlError>
#include <QSqlQuery>
#include <QSqlDriver>

namespace {{ s.global.application_pascal_name }}::Common::Database::JunctionTableOps
{

QHash<int, QList<int>> UnorderedManyToMany::getRightIdsMany(QSqlDatabase &db, const QList<int> &leftIds,
                                                            const QString &junctionTableName)
{
    QHash<int, QList<int>> result;

    if (leftIds.isEmpty())
    {
        return result;
    }

    // Initialize empty lists for all leftIds
    for (int leftId : leftIds)
    {
        result[leftId] = QList<int>();
    }

    // Build dynamic IN clause
    QStringList placeholders;
    placeholders.fill("?"_L1, leftIds.size());
    const QString sql = QStringLiteral("SELECT left_id, right_id FROM %1 WHERE left_id IN (%2)")
                            .arg(junctionTableName, placeholders.join(","_L1));

    QSqlQuery query(db);
    if (!query.prepare(sql))
    {
        qCritical() << "Failed to prepare getRightIdsMany query:" << query.lastError().text();
        return result;
    }
    for (int leftId : leftIds)
    {
        query.addBindValue(leftId);
    }

    if (!query.exec())
    {
        qCritical() << "Failed to execute getRightIdsMany query:" << query.lastError().text();
        return result;
    }

    while (query.next())
    {
        int leftId = query.value(0).toInt();
        int rightId = query.value(1).toInt();
        result[leftId].append(rightId);
    }

    return result;
}

QList<int> UnorderedManyToMany::getRightIds(QSqlDatabase &db, int leftId, const QString &junctionTableName)
{
    QList<int> cachedResult;
    if (JunctionCache::instance().getCachedRightIds(junctionTableName, leftId, cachedResult))
    {
        return cachedResult;
    }

    QHash<int, QList<int>> result = getRightIdsMany(db, {leftId}, junctionTableName);
    QList<int> rightIds = result.value(leftId, QList<int>());

    // Cache the result
    JunctionCache::instance().setCachedRightIds(junctionTableName, leftId, rightIds);

    return rightIds;
}

QHash<int, bool> UnorderedManyToMany::removeWithLeftIdsMany(QSqlDatabase &db, const QList<int> &leftIds,
                                                            const QString &junctionTableName)
{
    QHash<int, bool> result;

    if (leftIds.isEmpty())
    {
        return result;
    }

    // Invalidate cache for affected left IDs
    for (int leftId : leftIds)
    {
        JunctionCache::instance().invalidateLeftId(junctionTableName, leftId);
    }

    // Build dynamic IN clause for efficient bulk delete
    QStringList placeholders;
    placeholders.fill("?"_L1, leftIds.size());
    const QString sql =
        QStringLiteral("DELETE FROM %1 WHERE left_id IN (%2)").arg(junctionTableName, placeholders.join(","_L1));

    QSqlQuery query(db);
    if (!query.prepare(sql))
    {
        qCritical() << "Failed to prepare removeWithLeftIdsMany query:" << query.lastError().text();
        for (int leftId : leftIds)
        {
            result[leftId] = false;
        }
        return result;
    }
    for (int leftId : leftIds)
    {
        query.addBindValue(leftId);
    }

    bool success = query.exec();

    if (!success)
    {
        qCritical() << "Failed to execute removeWithLeftIdsMany query:" << query.lastError().text();
    }

    // Initialize all results based on success
    for (int leftId : leftIds)
    {
        result[leftId] = success;
    }

    return result;
}

bool UnorderedManyToMany::removeWithLeftIds(QSqlDatabase &db, int leftId, const QString &junctionTableName)
{
    QHash<int, bool> result = removeWithLeftIdsMany(db, {leftId}, junctionTableName);
    return result.value(leftId, false);
}

QHash<int, bool> UnorderedManyToMany::removeWithRightIdsMany(QSqlDatabase &db, const QList<int> &rightIds,
                                                             const QString &junctionTableName)
{
    QHash<int, bool> result;

    if (rightIds.isEmpty())
    {
        return result;
    }

    // Invalidate entire table cache since we don't know which left IDs are affected
    // This is less efficient but ensures cache consistency
    JunctionCache::instance().invalidateTable(junctionTableName);

    // Build dynamic IN clause for efficient bulk delete
    QStringList placeholders;
    placeholders.fill("?"_L1, rightIds.size());
    const QString sql =
        QStringLiteral("DELETE FROM %1 WHERE right_id IN (%2)").arg(junctionTableName, placeholders.join(","_L1));

    QSqlQuery query(db);
    if (!query.prepare(sql))
    {
        qCritical() << "Failed to prepare removeWithRightIdsMany query:" << query.lastError().text();
        for (int rightId : rightIds)
        {
            result[rightId] = false;
        }
        return result;
    }
    for (int rightId : rightIds)
    {
        query.addBindValue(rightId);
    }

    bool success = query.exec();

    if (!success)
    {
        qCritical() << "Failed to execute removeWithRightIdsMany query:" << query.lastError().text();
    }

    // Initialize all results based on success
    for (int rightId : rightIds)
    {
        result[rightId] = success;
    }

    return result;
}

bool UnorderedManyToMany::removeWithRightIds(QSqlDatabase &db, int rightId, const QString &junctionTableName)
{
    QHash<int, bool> result = removeWithRightIdsMany(db, {rightId}, junctionTableName);
    return result.value(rightId, false);
}

QHash<int, QList<int>> UnorderedManyToMany::upsertRightIdsMany(QSqlDatabase &db,
                                                               const QHash<int, QList<int>> &leftIdToRightIds,
                                                               const QString &junctionTableName)
{
    QHash<int, QList<int>> result;

    if (leftIdToRightIds.isEmpty())
    {
        return result;
    }

    // Invalidate cache for affected left IDs
    QList<int> leftIds = leftIdToRightIds.keys();
    for (int leftId : leftIds)
    {
        JunctionCache::instance().invalidateLeftId(junctionTableName, leftId);
    }

    // First, remove all existing relationships for these leftIds
    removeWithLeftIdsMany(db, leftIds, junctionTableName);

    // Then insert new relationships
    QSqlQuery insertQuery(db);
    if (!insertQuery.prepare(
        QStringLiteral("INSERT OR IGNORE INTO %1 (left_id, right_id) VALUES (?, ?)").arg(junctionTableName)))
    {
        qCritical() << "Failed to prepare upsertRightIdsMany insert query:" << insertQuery.lastError().text();
        return result;
    }

    for (auto it = leftIdToRightIds.begin(); it != leftIdToRightIds.end(); ++it)
    {
        int leftId = it.key();
        const QList<int> &rightIds = it.value();

        for (int rightId : rightIds)
        {
            insertQuery.addBindValue(leftId);
            insertQuery.addBindValue(rightId);
            if (!insertQuery.exec())
            {
                qCritical() << "Failed to execute upsertRightIdsMany insert query:" << insertQuery.lastError().text();
            }
        }

        result[leftId] = rightIds;
    }

    return result;
}

QList<int> UnorderedManyToMany::upsertRightIds(QSqlDatabase &db, int leftId, const QString &junctionTableName,
                                               const QList<int> &rightIds)
{
    QHash<int, QList<int>> input;
    input[leftId] = rightIds;
    QHash<int, QList<int>> result = upsertRightIdsMany(db, input, junctionTableName);
    return result.value(leftId, QList<int>());
}

QList<int> UnorderedManyToMany::upsertRightIds(QSqlDatabase &db, int leftId, const QString &junctionTableName,
                                               const std::optional<QList<int>> &rightIds)
{
    if (!rightIds.has_value())
    {
        removeWithLeftIds(db, leftId, junctionTableName);
        return {};
    }
    return upsertRightIds(db, leftId, junctionTableName, rightIds.value());
}

QMap<int, QList<int>> UnorderedManyToMany::getLeftIdsMany(QSqlDatabase &db, const QString &junctionTableName,
                                                          const QList<int> &rightIds)
{
    QMap<int, QList<int>> result;

    if (rightIds.isEmpty())
    {
        return result;
    }

    // Initialize empty lists for all rightIds
    for (int rightId : rightIds)
    {
        result[rightId] = QList<int>();
    }

    // Build dynamic IN clause
    QStringList placeholders;
    placeholders.fill("?"_L1, rightIds.size());
    const QString sql = QStringLiteral("SELECT right_id, left_id FROM %1 WHERE right_id IN (%2)")
                            .arg(junctionTableName, placeholders.join(","_L1));

    QSqlQuery query(db);
    if (!query.prepare(sql))
    {
        qCritical() << "Failed to prepare getLeftIdsMany query:" << query.lastError().text();
        return result;
    }
    for (int rightId : rightIds)
    {
        query.addBindValue(rightId);
    }

    if (!query.exec())
    {
        qCritical() << "Failed to execute getLeftIdsMany query:" << query.lastError().text();
        return result;
    }

    while (query.next())
    {
        int rightId = query.value(0).toInt();
        int leftId = query.value(1).toInt();
        result[rightId].append(leftId);
    }

    return result;
}

QList<int> UnorderedManyToMany::getLeftIds(QSqlDatabase &db, const QString &junctionTableName, int rightId)
{
    QMap<int, QList<int>> result = getLeftIdsMany(db, junctionTableName, {rightId});
    return result.value(rightId, QList<int>());
}

int UnorderedManyToMany::getRightIdsCount(QSqlDatabase &db, int leftId, const QString &junctionTableName)
{
    int cachedResult;
    if (JunctionCache::instance().getCachedRightIdsCount(junctionTableName, leftId, cachedResult))
    {
        return cachedResult;
    }

    const QString sql = QStringLiteral("SELECT COUNT(right_id) FROM %1 WHERE left_id = ?").arg(junctionTableName);

    QSqlQuery query(db);
    if (!query.prepare(sql))
    {
        qCritical() << "Failed to prepare getRightIdsCount query:" << query.lastError().text();
        return 0;
    }
    query.addBindValue(leftId);

    int count = 0;
    if (!query.exec())
    {
        qCritical() << "Failed to execute getRightIdsCount query:" << query.lastError().text();
        return count;
    }

    if (query.next())
    {
        count = query.value(0).toInt();
    }

    // Cache the result
    JunctionCache::instance().setCachedRightIdsCount(junctionTableName, leftId, count);

    return count;
}

QList<int> UnorderedManyToMany::getRightIdsInRange(QSqlDatabase &db, int leftId, const QString &junctionTableName,
                                                   int offset, int limit)
{
    QList<int> cachedResult;
    if (JunctionCache::instance().getCachedRightIdsInRange(junctionTableName, leftId, offset, limit, cachedResult))
    {
        return cachedResult;
    }

    QList<int> result;

    const QString sql =
        QStringLiteral("SELECT right_id FROM %1 WHERE left_id = ? LIMIT ? OFFSET ?").arg(junctionTableName);

    QSqlQuery query(db);
    if (!query.prepare(sql))
    {
        qCritical() << "Failed to prepare getRightIdsInRange query:" << query.lastError().text();
        return result;
    }
    query.addBindValue(leftId);
    query.addBindValue(limit);
    query.addBindValue(offset);

    if (!query.exec())
    {
        qCritical() << "Failed to execute getRightIdsInRange query:" << query.lastError().text();
        return result;
    }

    while (query.next())
    {
        result.append(query.value(0).toInt());
    }

    // Cache the result
    JunctionCache::instance().setCachedRightIdsInRange(junctionTableName, leftId, offset, limit, result);

    return result;
}
} // namespace {{ s.global.application_pascal_name }}::Common::Database::JunctionTableOps
