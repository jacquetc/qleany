#pragma once

#include <QList>
#include <QSet>
#include <QString>
#include <QVariant>
#include <QVariantMap>
#include <QtSql/QSqlDatabase>
#include <QtSql/QSqlError>
#include <QtSql/QSqlQuery>
#include <QtSql/QSqlRecord>

using namespace Qt::StringLiterals;

namespace {{ s.global.application_pascal_name }}::Common::Database
{

struct TableSnapshot {
    QString tableName;
    QList<QVariantMap> rows; // column_name -> value
};

struct TableLevelSnapshot {
    TableSnapshot entityRows;
    QList<TableSnapshot> forwardJunctions;
    QList<TableSnapshot> backwardJunctions;
};

struct EntityTreeSnapshot {
    TableLevelSnapshot tableData;
    QList<EntityTreeSnapshot> children;
};

class SnapshotUtil
{
  public:
    static TableSnapshot captureRowsByIds(QSqlDatabase &db, const QString &tableName, const QList<int> &ids)
    {
        TableSnapshot snap;
        snap.tableName = tableName;

        if (ids.isEmpty())
            return snap;

        QStringList placeholders;
        placeholders.fill("?"_L1, ids.size());
        const QString sql = "SELECT * FROM %1 WHERE id IN (%2)"_L1
            .arg(tableName, placeholders.join(","_L1));

        QSqlQuery q(db);
        q.prepare(sql);
        for (int id : ids)
            q.addBindValue(id);

        if (q.exec())
        {
            const QSqlRecord rec = q.record();
            while (q.next())
            {
                QVariantMap row;
                for (int i = 0; i < rec.count(); ++i)
                    row.insert(rec.fieldName(i), q.value(i));
                snap.rows.append(std::move(row));
            }
        }
        else
        {
            qCritical() << "SnapshotUtil::captureRowsByIds failed:" << q.lastError().text();
        }
        return snap;
    }

    static TableSnapshot captureJunctionByLeft(QSqlDatabase &db, const QString &tableName, const QList<int> &leftIds,
                                               bool ordered = false)
    {
        TableSnapshot snap;
        snap.tableName = tableName;

        if (leftIds.isEmpty())
            return snap;

        QStringList placeholders;
        placeholders.fill("?"_L1, leftIds.size());
        QString sql = "SELECT * FROM %1 WHERE left_id IN (%2)"_L1
            .arg(tableName, placeholders.join(","_L1));

        if (ordered)
        {
            sql += " ORDER BY order_"_L1;
        }

        QSqlQuery q(db);
        q.prepare(sql);
        for (int id : leftIds)
            q.addBindValue(id);

        if (q.exec())
        {
            const QSqlRecord rec = q.record();
            while (q.next())
            {
                QVariantMap row;
                for (int i = 0; i < rec.count(); ++i)
                    row.insert(rec.fieldName(i), q.value(i));
                snap.rows.append(std::move(row));
            }
        }
        else
        {
            qCritical() << "SnapshotUtil::captureJunctionByLeft failed:" << q.lastError().text();
        }
        return snap;
    }

    static TableSnapshot captureJunctionByRight(QSqlDatabase &db, const QString &tableName, const QList<int> &rightIds,
                                                bool ordered = false)
    {
        TableSnapshot snap;
        snap.tableName = tableName;

        if (rightIds.isEmpty())
            return snap;

        QStringList placeholders;
        placeholders.fill("?"_L1, rightIds.size());
        QString sql = "SELECT * FROM %1 WHERE right_id IN (%2)"_L1
            .arg(tableName, placeholders.join(","_L1));

        if (ordered)
        {
            sql += " ORDER BY order_"_L1;
        }

        QSqlQuery q(db);
        q.prepare(sql);
        for (int id : rightIds)
            q.addBindValue(id);

        if (q.exec())
        {
            const QSqlRecord rec = q.record();
            while (q.next())
            {
                QVariantMap row;
                for (int i = 0; i < rec.count(); ++i)
                    row.insert(rec.fieldName(i), q.value(i));
                snap.rows.append(std::move(row));
            }
        }
        else
        {
            qCritical() << "SnapshotUtil::captureJunctionByRight failed:" << q.lastError().text();
        }
        return snap;
    }

    static void restoreRows(QSqlDatabase &db, const TableSnapshot &snap)
    {
        if (snap.rows.isEmpty())
            return;

        // Discover column names from first row
        const QStringList columns = snap.rows.first().keys();
        if (columns.isEmpty())
            return;

        QStringList placeholders;
        placeholders.reserve(columns.size());
        for (const QString &col : columns)
            placeholders.append(":"_L1 + col);

        const QString sql = "INSERT OR REPLACE INTO %1 (%2) VALUES (%3)"_L1
            .arg(snap.tableName, columns.join(","_L1), placeholders.join(","_L1));

        QSqlQuery q(db);
        for (const QVariantMap &row : snap.rows)
        {
            q.prepare(sql);
            for (const QString &col : columns)
                q.bindValue(":"_L1 + col, row.value(col));

            if (!q.exec())
                qCritical() << "SnapshotUtil::restoreRows failed:" << q.lastError().text();
        }
    }

    // Restore junction rows, deleting stale rows by left_id before inserting snapshotted rows
    static void restoreJunctionRowsByLeft(QSqlDatabase &db, const TableSnapshot &snap)
    {
        if (snap.rows.isEmpty())
            return;

        // Collect unique left_ids from the snapshot
        QSet<int> leftIds;
        for (const QVariantMap &row : snap.rows)
            leftIds.insert(row.value("left_id"_L1).toInt());

        // Delete all existing junction rows for these left_ids
        QStringList placeholders;
        placeholders.fill("?"_L1, leftIds.size());
        const QString deleteSql = "DELETE FROM %1 WHERE left_id IN (%2)"_L1.arg(
            snap.tableName, placeholders.join(","_L1));

        QSqlQuery dq(db);
        dq.prepare(deleteSql);
        for (int id : leftIds)
            dq.addBindValue(id);

        if (!dq.exec())
            qCritical() << "SnapshotUtil::restoreJunctionRowsByLeft DELETE failed:" << dq.lastError().text();

        // Insert snapshotted rows
        restoreRows(db, snap);
    }

    // Restore junction rows, deleting stale rows by right_id before inserting snapshotted rows
    static void restoreJunctionRowsByRight(QSqlDatabase &db, const TableSnapshot &snap)
    {
        if (snap.rows.isEmpty())
            return;

        // Collect unique right_ids from the snapshot
        QSet<int> rightIds;
        for (const QVariantMap &row : snap.rows)
            rightIds.insert(row.value("right_id"_L1).toInt());

        // Delete all existing junction rows for these right_ids
        QStringList placeholders;
        placeholders.fill("?"_L1, rightIds.size());
        const QString deleteSql = "DELETE FROM %1 WHERE right_id IN (%2)"_L1.arg(
            snap.tableName, placeholders.join(","_L1));

        QSqlQuery dq(db);
        dq.prepare(deleteSql);
        for (int id : rightIds)
            dq.addBindValue(id);

        if (!dq.exec())
            qCritical() << "SnapshotUtil::restoreJunctionRowsByRight DELETE failed:" << dq.lastError().text();

        // Insert snapshotted rows
        restoreRows(db, snap);
    }

    static QList<int> extractIds(const TableSnapshot &snap)
    {
        QList<int> ids;
        ids.reserve(snap.rows.size());
        for (const QVariantMap &row : snap.rows)
            ids.append(row.value("id"_L1).toInt());
        return ids;
    }

    static QList<int> extractRightIds(const TableSnapshot &snap)
    {
        QList<int> ids;
        ids.reserve(snap.rows.size());
        for (const QVariantMap &row : snap.rows)
            ids.append(row.value("right_id"_L1).toInt());
        return ids;
    }
};

} // namespace {{ s.global.application_pascal_name }}::Common::Database
