#pragma once

#include <QDebug>
#include <QDir>
#include <QHash>
#include <QMutex>
#include <QPointer>
#include <QReadWriteLock>
#include <QString>
#include <QTemporaryFile>
#include <QWriteLocker>
#include <QtSql/QSqlDatabase>
#include <QtSql/QSqlError>
#include <QtSql/QSqlQuery>

#include "database/db_builder.h"

using namespace Qt::Literals::StringLiterals;

namespace {{ s.global.application_pascal_name }}::Common::Database
{

class DbContext : public QObject
{
    Q_OBJECT
  public:
    DbContext(QObject *parent = nullptr) : QObject(parent)
    {
        m_databaseName = DbBuilder::buildDatabase();
    }

    ~DbContext()
    {
        // Close all connections
        QWriteLocker guard(&m_lock);
        for (const QString &connName : m_connections)
        {
            QSqlDatabase::removeDatabase(connName);
        }
        m_connections.clear();

        // Delete the temporary database file
        if (!m_databaseName.isEmpty() && QFile::exists(m_databaseName))
        {
            if (!QFile::remove(m_databaseName))
            {
                qWarning() << "DbContext: failed to remove temporary database file:" << m_databaseName;
            }
        }
    }

    // Connection pool management
    int createDatabaseConnection()
    {
        QWriteLocker guard(&m_lock);
        const int id = ++m_nextId;
        const QString connName = QStringLiteral("skri_conn_%1").arg(id);
        QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE"_L1, connName);
        db.setDatabaseName(m_databaseName);
        if (!db.open())
        {
            qCritical() << "DbContext: failed to open database:" << db.lastError().text();
            m_connections.insert(id, connName);
            return id;
        }

        // Apply per-connection PRAGMAs (these are NOT persisted to the file)
        {
            QSqlQuery query(db);
            for (const QString &pragma : DbBuilder::perConnectionPragmas())
            {
                if (!query.exec(pragma))
                {
                    qWarning() << "DbContext: PRAGMA failed:" << query.lastError().text();
                }
            }
        }

        m_connections.insert(id, connName);
        return id;
    }

    void closeDatabaseConnection(const int dbId)
    {
        QWriteLocker guard(&m_lock);
        const auto it = m_connections.constFind(dbId);
        if (it == m_connections.cend())
        {
            qCritical() << "DbContext::closeDatabaseConnection - unknown dbId" << dbId;
            return;
        }

        QSqlDatabase::removeDatabase(it.value());
        m_connections.erase(it);
    }

    QSqlDatabase getConnection(const int dbId) const
    {
        QReadLocker guard(&m_lock);
        const auto it = m_connections.constFind(dbId);
        if (it == m_connections.cend())
        {
            qCritical() << "DbContext::getConnection - unknown dbId" << dbId;
            return {};
        }
        return QSqlDatabase::database(it.value());
    }

    QString getDatabaseName() const
    {
        QReadLocker guard(&m_lock);
        return m_databaseName;
    }

    // WAL management methods
    bool performPassiveCheckpoint()
    {
        QReadLocker guard(&m_lock);
        if (m_connections.isEmpty())
            return false;

        // Use first available connection for checkpoint
        auto it = m_connections.cbegin();
        QSqlDatabase db = QSqlDatabase::database(it.value());
        if (!db.isValid())
            return false;

        QSqlQuery query(db);
        return query.exec(QStringLiteral("PRAGMA wal_checkpoint(PASSIVE);"));
    }

    bool performTruncateCheckpoint()
    {
        QReadLocker guard(&m_lock);
        if (m_connections.isEmpty())
            return false;

        // Use first available connection for checkpoint
        auto it = m_connections.cbegin();
        QSqlDatabase db = QSqlDatabase::database(it.value());
        if (!db.isValid())
            return false;

        QSqlQuery query(db);
        return query.exec(QStringLiteral("PRAGMA wal_checkpoint(TRUNCATE);"));
    }

    QPair<int, int> getWalInfo() const
    {
        QReadLocker guard(&m_lock);
        if (m_connections.isEmpty())
            return {-1, -1};

        // Use first available connection to get WAL info
        auto it = m_connections.cbegin();
        QSqlDatabase db = QSqlDatabase::database(it.value());
        if (!db.isValid())
            return {-1, -1};

        QSqlQuery query(db);
        if (query.exec(QStringLiteral("PRAGMA wal_checkpoint;")) && query.next())
        {
            return {query.value(0).toInt(), query.value(1).toInt()};
        }
        return {-1, -1};
    }

    /// Acquire exclusive write access. Blocks until available.
    /// Must be paired with releaseWriteLock().
    void acquireWriteLock()
    {
        m_writeMutex.lock();
    }

    /// Release exclusive write access.
    void releaseWriteLock()
    {
        m_writeMutex.unlock();
    }

  private:
    mutable QReadWriteLock m_lock;          // protects connection pool
    QMutex m_writeMutex;                    // serializes write transactions
    QString m_databaseName;
    int m_nextId = 0;
    // map id -> connectionName
    QHash<int, QString> m_connections;
};

struct DbSubContext
{
    explicit DbSubContext(DbContext &parentDbContext) : m_parentDbContext(parentDbContext)
    {
        // Don't create connection here - defer until needed
    }

    DbSubContext(const DbSubContext &) = delete;
    DbSubContext &operator=(const DbSubContext &) = delete;

    ~DbSubContext()
    {
        // Safety: release write lock if still held (abnormal exit path)
        if (m_holdsWriteLock)
        {
            qWarning() << "DbSubContext destroyed while holding write lock â€” forcing release";
            m_parentDbContext.releaseWriteLock();
            m_holdsWriteLock = false;
        }

        if (m_dbId != -1)
        {
            m_parentDbContext.closeDatabaseConnection(m_dbId);
        }
    }

    /**
     *  Only for very specific use cases where direct access to the database is needed, like saving,
     *  without going through the UnitOfWork API. Use with caution.
     * @return
     */
    [[nodiscard]] QString getDatabaseName() const
    {
        return m_parentDbContext.getDatabaseName();
    }

    [[nodiscard]] QSqlDatabase getConnection() const
    {
        // Lazy initialization - create connection on first use
        if (m_dbId == -1)
        {
            m_dbId = m_parentDbContext.createDatabaseConnection();
        }
        return m_parentDbContext.getConnection(m_dbId);
    }

    [[nodiscard]] int getDbId() const
    {
        // Ensure connection exists before returning ID
        if (m_dbId == -1)
        {
            m_dbId = m_parentDbContext.createDatabaseConnection();
        }
        return m_dbId;
    }

    // Transaction API - all methods need to ensure connection exists

    /// Begin a write transaction. Acquires the write mutex first.
    /// Returns false if the SQL transaction could not be started.
    [[nodiscard]] bool beginTransaction()
    {
        m_parentDbContext.acquireWriteLock();
        m_holdsWriteLock = true;

        QSqlDatabase db = getConnection();
        if (!db.isValid())
        {
            qCritical() << "BEGIN TRANSACTION failed: invalid database connection";
            m_parentDbContext.releaseWriteLock();
            m_holdsWriteLock = false;
            return false;
        }
        if (!db.transaction())
        {
            qCritical() << "BEGIN TRANSACTION failed:" << db.lastError().text();
            m_parentDbContext.releaseWriteLock();
            m_holdsWriteLock = false;
            return false;
        }
        return true;
    }

    [[nodiscard]] bool commit()
    {
        QSqlDatabase db = getConnection();
        bool ok = true;
        if (db.isValid())
        {
            if (!db.commit())
            {
                qCritical() << "COMMIT failed:" << db.lastError().text();
                ok = false;
            }
        }
        if (m_holdsWriteLock)
        {
            m_parentDbContext.releaseWriteLock();
            m_holdsWriteLock = false;
        }
        return ok;
    }

    [[nodiscard]] bool endTransaction()
    {
        return commit();
    }

    bool rollback()
    {
        QSqlDatabase db = getConnection();
        bool ok = true;
        if (db.isValid())
        {
            if (!db.rollback())
            {
                qWarning() << "ROLLBACK failed:" << db.lastError().text();
                ok = false;
            }
        }
        if (m_holdsWriteLock)
        {
            m_parentDbContext.releaseWriteLock();
            m_holdsWriteLock = false;
        }
        return ok;
    }

    void createSavepoint()
    {
        if (!m_savepointName.isEmpty())
        {
            qCritical() << "RootUnitOfWork::createSavepoint - savepoint already exists";
            return;
        }

        QSqlDatabase db = getConnection();
        if (!db.isValid())
            return;
        QSqlQuery q(db);
        const QString name =
            QStringLiteral("sp_%1").arg(QUuid::createUuid().toString(QUuid::WithoutBraces).remove("-"_L1));

        if (!q.exec(QStringLiteral("SAVEPOINT %1").arg(name)))
        {
            qWarning() << "SAVEPOINT failed:" << q.lastError().text();
        }
        m_savepointName = name;
    }

    void rollbackToSavepoint()
    {
        if (m_savepointName.isEmpty())
        {
            qCritical() << "RootUnitOfWork::rollbackToSavepoint - no savepoint";
            return;
        }

        QSqlDatabase db = getConnection();
        if (!db.isValid())
            return;
        QSqlQuery q(db);
        if (!q.exec(QStringLiteral("ROLLBACK TO SAVEPOINT %1").arg(m_savepointName)))
        {
            qWarning() << "ROLLBACK TO SAVEPOINT failed:" << q.lastError().text();
        }
    }

    void releaseSavepoint()
    {
        if (m_savepointName.isEmpty())
        {
            qCritical() << "RootUnitOfWork::releaseSavepoint - no savepoint";
            return;
        }

        QSqlDatabase db = getConnection();
        if (!db.isValid())
            return;
        QSqlQuery q(db);
        if (!q.exec(QStringLiteral("RELEASE SAVEPOINT %1").arg(m_savepointName)))
        {
            qWarning() << "RELEASE SAVEPOINT failed:" << q.lastError().text();
        }
    }

  private:
    DbContext &m_parentDbContext;
    mutable int m_dbId = -1; // Initialize to invalid ID
    bool m_holdsWriteLock = false;
    QString m_savepointName;
};

} // namespace {{ s.global.application_pascal_name }}::Common::Database
