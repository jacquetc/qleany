#pragma once

#include <QHash>
#include <QList>
#include <QMutex>
#include <QString>

using namespace Qt::StringLiterals;

namespace {{ s.global.application_pascal_name }}::Common::Database::JunctionTableOps
{

/**
 * @brief Thread-safe cache for junction table operations
 *
 * This cache stores query results for junction table operations to improve performance.
 * It uses a key-value structure where keys are composed of table name, left ID, and operation type.
 */
class JunctionCache
{
  public:
    struct CacheKey
    {
        QString tableName;
        int leftId;
        QString operation; // "getRightIds", "getRightIdsCount", "getRightIdsInRange"
        int offset = 0;    // for range queries
        int limit = 0;     // for range queries

        bool operator==(const CacheKey &other) const
        {
            return tableName == other.tableName && leftId == other.leftId && operation == other.operation &&
                   offset == other.offset && limit == other.limit;
        }

        friend uint qHash(const CacheKey &key, uint seed = 0)
        {
            return ::qHashMulti(seed, key.tableName, key.leftId, key.operation, key.offset, key.limit);
        }
    };

    struct CacheValue
    {
        QList<int> rightIds;
        int count = 0;
        bool isValid = false;
    };

    static JunctionCache &instance()
    {
        static JunctionCache cache;
        return cache;
    }

    // Get cached right IDs for a left ID
    bool getCachedRightIds(const QString &tableName, int leftId, QList<int> &result)
    {
        QMutexLocker locker(&m_mutex);
        CacheKey key{tableName, leftId, "getRightIds"_L1, 0, 0};

        auto it = m_cache.find(key);
        if (it != m_cache.end() && it->isValid)
        {
            result = it->rightIds;
            return true;
        }
        return false;
    }

    // Cache right IDs for a left ID
    void setCachedRightIds(const QString &tableName, int leftId, const QList<int> &rightIds)
    {
        QMutexLocker locker(&m_mutex);
        CacheKey key{tableName, leftId, "getRightIds"_L1, 0, 0};
        CacheValue value;
        value.rightIds = rightIds;
        value.count = rightIds.size();
        value.isValid = true;
        m_cache[key] = value;
    }

    // Get cached count for a left ID
    bool getCachedRightIdsCount(const QString &tableName, int leftId, int &result)
    {
        QMutexLocker locker(&m_mutex);
        CacheKey key{tableName, leftId, "getRightIdsCount"_L1, 0, 0};

        auto it = m_cache.find(key);
        if (it != m_cache.end() && it->isValid)
        {
            result = it->count;
            return true;
        }
        return false;
    }

    // Cache count for a left ID
    void setCachedRightIdsCount(const QString &tableName, int leftId, int count)
    {
        QMutexLocker locker(&m_mutex);
        CacheKey key{tableName, leftId, "getRightIdsCount"_L1, 0, 0};
        CacheValue value;
        value.count = count;
        value.isValid = true;
        m_cache[key] = value;
    }

    // Get cached range results
    bool getCachedRightIdsInRange(const QString &tableName, int leftId, int offset, int limit, QList<int> &result)
    {
        QMutexLocker locker(&m_mutex);
        CacheKey key{tableName, leftId, "getRightIdsInRange"_L1, offset, limit};

        auto it = m_cache.find(key);
        if (it != m_cache.end() && it->isValid)
        {
            result = it->rightIds;
            return true;
        }
        return false;
    }

    // Cache range results
    void setCachedRightIdsInRange(const QString &tableName, int leftId, int offset, int limit,
                                  const QList<int> &rightIds)
    {
        QMutexLocker locker(&m_mutex);
        CacheKey key{tableName, leftId, "getRightIdsInRange"_L1, offset, limit};
        CacheValue value;
        value.rightIds = rightIds;
        value.isValid = true;
        m_cache[key] = value;
    }

    // Remove all cached data for a specific left ID
    void invalidateLeftId(const QString &tableName, int leftId)
    {
        QMutexLocker locker(&m_mutex);
        // Remove all cache entries for this leftId
        auto it = m_cache.begin();
        while (it != m_cache.end())
        {
            if (it.key().tableName == tableName && it.key().leftId == leftId)
            {
                it = m_cache.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    // Remove all cached data for a specific table
    void invalidateTable(const QString &tableName)
    {
        QMutexLocker locker(&m_mutex);
        auto it = m_cache.begin();
        while (it != m_cache.end())
        {
            if (it.key().tableName == tableName)
            {
                it = m_cache.erase(it);
            }
            else
            {
                ++it;
            }
        }
    }

    // Clear all cached data
    void clear()
    {
        QMutexLocker locker(&m_mutex);
        m_cache.clear();
    }

  private:
    QHash<CacheKey, CacheValue> m_cache;
    QMutex m_mutex;
};

} // namespace {{ s.global.application_pascal_name }}::Common::Database::JunctionTableOps