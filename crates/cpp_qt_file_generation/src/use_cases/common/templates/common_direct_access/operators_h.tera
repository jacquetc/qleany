#pragma once
#include <QList>
#include <QVariant>

namespace {{ s.global.application_pascal_name }}::Common::DirectAccess
{

// For std::optional<int> and QVariant

inline bool operator==(const std::optional<int> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toInt();
}

inline bool operator!=(const std::optional<int> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<int> toOptionalInt(const QVariant &var) {
    return var.isValid() ? std::optional<int>(var.toInt()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<int> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<int> and QList<QVariant>

inline bool operator==(const QList<int> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toInt()) return false;
    }
    return true;
}

inline bool operator!=(const QList<int> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<int> toIntList(const QVariantList &list) {
    QList<int> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toInt());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<int> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

// For std::optional<QString> and QVariant

inline bool operator==(const std::optional<QString> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toString();
}

inline bool operator!=(const std::optional<QString> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<QString> toOptionalString(const QVariant &var) {
    return var.isValid() ? std::optional<QString>(var.toString()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<QString> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<QString> and QList<QVariant>

inline bool operator==(const QList<QString> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toString()) return false;
    }
    return true;
}

inline bool operator!=(const QList<QString> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<QString> toStringList(const QVariantList &list) {
    QList<QString> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toString());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<QString> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

// For std::optional<uint> and QVariant

inline bool operator==(const std::optional<uint> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toUInt();
}

inline bool operator!=(const std::optional<uint> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<uint> toOptionalUInt(const QVariant &var) {
    return var.isValid() ? std::optional<uint>(var.toUInt()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<uint> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<uint> and QList<QVariant>

inline bool operator==(const QList<uint> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toUInt()) return false;
    }
    return true;
}

inline bool operator!=(const QList<uint> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<uint> toUIntList(const QVariantList &list) {
    QList<uint> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toUInt());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<uint> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

// For std::optional<float> and QVariant

inline bool operator==(const std::optional<float> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toFloat();
}

inline bool operator!=(const std::optional<float> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<float> toOptionalFloat(const QVariant &var) {
    return var.isValid() ? std::optional<float>(var.toFloat()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<float> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<float> and QList<QVariant>

inline bool operator==(const QList<float> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toFloat()) return false;
    }
    return true;
}

inline bool operator!=(const QList<float> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<float> toFloatList(const QVariantList &list) {
    QList<float> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toFloat());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<float> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

// For std::optional<bool> and QVariant

inline bool operator==(const std::optional<bool> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toBool();
}

inline bool operator!=(const std::optional<bool> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<bool> toOptionalBool(const QVariant &var) {
    return var.isValid() ? std::optional<bool>(var.toBool()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<bool> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<bool> and QList<QVariant>

inline bool operator==(const QList<bool> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toBool()) return false;
    }
    return true;
}

inline bool operator!=(const QList<bool> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<bool> toBoolList(const QVariantList &list) {
    QList<bool> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toBool());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<bool> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

// For std::optional<QUuid> and QVariant

inline bool operator==(const std::optional<QUuid> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toUuid();
}

inline bool operator!=(const std::optional<QUuid> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<QUuid> toOptionalUuid(const QVariant &var) {
    return var.isValid() ? std::optional<QUuid>(var.toUuid()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<QUuid> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<QUuid> and QList<QVariant>

inline bool operator==(const QList<QUuid> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toUuid()) return false;
    }
    return true;
}

inline bool operator!=(const QList<QUuid> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<QUuid> toUuidList(const QVariantList &list) {
    QList<QUuid> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toUuid());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<QUuid> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

// For std::optional<QDateTime> and QVariant

inline bool operator==(const std::optional<QDateTime> & lhs, const QVariant & rhs) {
    if (lhs.has_value() != rhs.isValid()) {
        return false;
    }
    if (!lhs.has_value()) {
        return true; // Both are null/invalid
    }
    return lhs.value() == rhs.toDateTime();
}

inline bool operator!=(const std::optional<QDateTime> & lhs, const QVariant & rhs) {
    return !(lhs == rhs);
}

inline std::optional<QDateTime> toOptionalDateTime(const QVariant &var) {
    return var.isValid() ? std::optional<QDateTime>(var.toDateTime()) : std::nullopt;
}

inline QVariant toVariant(const std::optional<QDateTime> &opt) {
    return opt.has_value() ? QVariant(opt.value()) : QVariant();
}

// For QList<QDateTime> and QList<QVariant>

inline bool operator==(const QList<QDateTime> & lhs, const QList<QVariant> & rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); ++i) {
        if (lhs[i] != rhs[i].toDateTime()) return false;
    }
    return true;
}

inline bool operator!=(const QList<QDateTime> & lhs, const QList<QVariant> & rhs) {
    return !(lhs == rhs);
}

inline QList<QDateTime> toDateTimeList(const QVariantList &list) {
    QList<QDateTime> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v.toDateTime());
    }
    return result;
}

inline QList<QVariant> toVariantList(const QList<QDateTime> &list) {
    QList<QVariant> result;
    result.reserve(list.size());
    for (const auto &v : list) {
        result.append(v);
    }
    return result;
}

} // namespace {{ s.global.application_pascal_name }}::Common::DirectAccess
