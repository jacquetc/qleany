{%- set e = s.file.inner.entity %}
{%- set ent = s.entities[e] %}
{#- Determine which junction table operation headers are actually needed -#}
{%- set needs_ordered_o2m = false %}
{%- set needs_unordered_o2m = false %}
{%- set needs_unordered_m2m = false %}
{%- set needs_one2one = false %}
{%- set needs_many2one = false %}
{%- for f in ent.fields %}
  {%- if f.inner.field_type == "Entity" %}
    {%- if f.relationship == "OrderedOneToMany" %}{% set_global needs_ordered_o2m = true %}{% endif %}
    {%- if f.relationship == "OneToMany" %}{% set_global needs_unordered_o2m = true %}{% endif %}
    {%- if f.relationship == "ManyToMany" %}{% set_global needs_unordered_m2m = true %}{% endif %}
    {%- if f.relationship == "OneToOne" %}{% set_global needs_one2one = true %}{% endif %}
    {%- if f.relationship == "ManyToOne" %}{% set_global needs_many2one = true %}{% endif %}
  {%- endif %}
{%- endfor %}
{%- for rid, r in ent.backward_relationships %}
  {%- if r.inner.relationship_type == "OrderedOneToMany" %}{% set_global needs_ordered_o2m = true %}{% endif %}
  {%- if r.inner.relationship_type == "OneToMany" %}{% set_global needs_unordered_o2m = true %}{% endif %}
  {%- if r.inner.relationship_type == "ManyToMany" %}{% set_global needs_unordered_m2m = true %}{% endif %}
  {%- if r.inner.relationship_type == "OneToOne" %}{% set_global needs_one2one = true %}{% endif %}
  {%- if r.inner.relationship_type == "ManyToOne" %}{% set_global needs_many2one = true %}{% endif %}
{%- endfor %}
#include "{{ ent.snake_name }}_table.h"
#include "database/db_context.h"
{% if needs_ordered_o2m -%}
#include "database/junction_table_ops/ordered_one_to_many.h"
{% endif -%}
{% if needs_unordered_o2m -%}
#include "database/junction_table_ops/unordered_one_to_many.h"
{% endif -%}
{% if needs_unordered_m2m -%}
#include "database/junction_table_ops/unordered_many_to_many.h"
{% endif -%}
{% if needs_one2one -%}
#include "database/junction_table_ops/one_to_one.h"
{% endif -%}
{% if needs_many2one -%}
#include "database/junction_table_ops/many_to_one.h"
{% endif -%}
#include "database/table_cache.h"
#include "entities/{{ ent.snake_name }}.h"

#include <QDateTime>
#include <QList>
#include <QtSql/QSqlDatabase>
#include <QtSql/QSqlError>
#include <QtSql/QSqlQuery>
#include <algorithm>
#include <iterator>

namespace SCD{{ ent.pascal_name }} = {{ s.global.application_pascal_name }}::Common::DirectAccess::{{ ent.pascal_name }};
using namespace {{ s.global.application_pascal_name }}::Common::Database;
namespace SCE = {{ s.global.application_pascal_name }}::Common::Entities;

// Cache type alias (used across all methods)
using {{ ent.pascal_name }}Cache = TableCache<SCE::{{ ent.pascal_name }}, SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}RelationshipField>;

// Forward relationship junction tables
{% for rid, r in ent.forward_relationships %}
const QString {{ ent.snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE = "{{ ent.camel_name }}_{{ r.field_snake_name }}_to_{{ s.entities[r.inner.right_entity].snake_name }}_junction"_L1;
{%- endfor %}
// Backward relationship junction tables
{% for rid, r in s.entities[e].backward_relationships %}
{%- if r.inner.left_entity == e %}
const QString {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE_BACKWARD = "{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_to_{{ ent.camel_name }}_junction"_L1;
{%- else %}
const QString {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE = "{{ s.entities[r.inner.left_entity].snake_name }}_{{ r.field_snake_name }}_to_{{ ent.camel_name }}_junction"_L1;
{%- endif %}
{%- endfor %}

// Pre-built SQL column lists (compile-time constants, reused across create/update/find)
static const QString COLUMNS_NO_ID = QStringLiteral(
    "{% for f in ent.normal_fields %}{{ f.sql_safe_snake_name }}{% if not loop.last %},{% endif %}{% endfor %}"
);
static const QString COLUMNS_WITH_ID = QStringLiteral("id,") + COLUMNS_NO_ID;

static const QString PLACEHOLDERS_NO_ID = QStringLiteral(
    "{% for f in ent.normal_fields %}:{{ f.snake_name }}{% if not loop.last %},{% endif %}{% endfor %}"
);
static const QString PLACEHOLDERS_WITH_ID = QStringLiteral(":id,") + PLACEHOLDERS_NO_ID;



// Helper: extract IDs from a list of entities
static QList<int> extractIds(const QList<SCE::{{ ent.pascal_name }}> &items)
{
    QList<int> ids;
    ids.reserve(items.size());
    std::ranges::transform(items, std::back_inserter(ids),
        [](const SCE::{{ ent.pascal_name }} &item) { return item.id; });
    return ids;
}

SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::{{ ent.pascal_name }}Table(DbSubContext &dbSubContext) : m_dbSubContext(dbSubContext)
{
}

QList<SCE::{{ ent.pascal_name }}> SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::createMany(const QList<SCE::{{ ent.pascal_name }}> &{{ ent.camel_plural_name }})
{
    QList<SCE::{{ ent.pascal_name }}> created;
    created.reserve({{ ent.camel_plural_name }}.size());

    QSqlDatabase db = m_dbSubContext.getConnection();

    // Pre-build both SQL variants (with/without explicit id)
    const QString sqlWithId = "INSERT INTO {{ ent.snake_name }} (%1) VALUES (%2)"_L1
        .arg(COLUMNS_WITH_ID, PLACEHOLDERS_WITH_ID);
    const QString sqlWithoutId = "INSERT INTO {{ ent.snake_name }} (%1) VALUES (%2)"_L1
        .arg(COLUMNS_NO_ID, PLACEHOLDERS_NO_ID);

    QSqlQuery q(db);

    for (SCE::{{ ent.pascal_name }} r : {{ ent.camel_plural_name }})
    {
        const bool hasExplicitId = r.id > 0;
        q.prepare(hasExplicitId ? sqlWithId : sqlWithoutId);

        // Set timestamps if not provided
        if (r.createdAt.isNull())
            r.createdAt = QDateTime::currentDateTimeUtc();
        if (r.updatedAt.isNull())
            r.updatedAt = r.createdAt;

        if (hasExplicitId)
            q.bindValue(":id"_L1, r.id);
    {%- for f in ent.normal_fields %}
        q.bindValue(":{{ f.snake_name }}"_L1,
        {%- if f.cpp_qt_type == "QDateTime" %}
            r.{{ f.camel_name }}.toString(Qt::ISODate));
        {%- elif f.cpp_qt_type == "QUuid" %}
            r.{{ f.camel_name }}.toString());
        {%- elif f.inner.field_type == "Enum" and f.required == false %}
            r.{{ f.camel_name }}.has_value() ? static_cast<int>(r.{{ f.camel_name }}.value()) : -1);
        {%- elif f.inner.field_type == "Enum" %}
            static_cast<int>(r.{{ f.camel_name }}));
        {%- elif f.required == false %}
            r.{{ f.camel_name }}.has_value() ? QVariant(r.{{ f.camel_name }}.value()) : QVariant());
        {%- else %}
            r.{{ f.camel_name }});
        {%- endif %}
    {%- endfor %}

        if (!q.exec())
        {
            qCritical() << "Failed to insert {{ ent.pascal_name }}:" << q.lastError().text();
            continue;
        }

        // Retrieve the auto-generated id
        if (!hasExplicitId)
            r.id = q.lastInsertId().toInt();

        // Handle junction table relationships
        {%- for f in ent.fields %}
        {%- if f.inner.field_type == "Entity" and f.relationship == "OrderedOneToMany" %}
            JunctionTableOps::OrderedOneToMany::upsertRightIds(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
        {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToMany" %}
            JunctionTableOps::UnorderedOneToMany::upsertRightIds(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
        {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToOne" %}
            JunctionTableOps::OneToOne::upsertRightId(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
        {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToOne" %}
            JunctionTableOps::ManyToOne::upsertRightId(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
        {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToMany" %}
            JunctionTableOps::UnorderedManyToMany::upsertRightIds(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
        {%- endif %}
        {%- endfor %}

        created.append(std::move(r));
    }

    // Invalidate cache for created entities
    if (!created.isEmpty())
        {{ ent.pascal_name }}Cache::instance().invalidateEntities(extractIds(created));

    return created;
}

QList<SCE::{{ ent.pascal_name }}> SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::updateMany(const QList<SCE::{{ ent.pascal_name }}> &{{ ent.camel_plural_name }})
{
    QList<SCE::{{ ent.pascal_name }}> updated;
    updated.reserve({{ ent.camel_plural_name }}.size());

    QSqlDatabase db = m_dbSubContext.getConnection();

    // Build SET clause once
    const QString sqlString = QStringLiteral(
        "UPDATE {{ ent.snake_name }} SET "
        "id = :id"
    {%- for f in ent.normal_fields %}
        ",{{ f.sql_safe_snake_name }} = :{{ f.snake_name }}"
    {%- endfor %}
        " WHERE id = :id"
    );

    QSqlQuery q(db);

    for (const SCE::{{ ent.pascal_name }} &r : {{ ent.camel_plural_name }})
    {
        q.prepare(sqlString);
        q.bindValue(":id"_L1, r.id);
    {%- for f in ent.normal_fields %}
        q.bindValue(":{{ f.snake_name }}"_L1,
        {%- if f.cpp_qt_type == "QDateTime" %}
            r.{{ f.camel_name }}.toString(Qt::ISODate));
        {%- elif f.cpp_qt_type == "QUuid" %}
            r.{{ f.camel_name }}.toString());
        {%- elif f.inner.field_type == "Enum" and f.required == false %}
            r.{{ f.camel_name }}.has_value() ? static_cast<int>(r.{{ f.camel_name }}.value()) : -1);
        {%- elif f.inner.field_type == "Enum" %}
            static_cast<int>(r.{{ f.camel_name }}));
        {%- elif f.required == false %}
            r.{{ f.camel_name }}.has_value() ? QVariant(r.{{ f.camel_name }}.value()) : QVariant());
        {%- else %}
            r.{{ f.camel_name }});
        {%- endif %}
    {%- endfor %}

        if (q.exec() && q.numRowsAffected() > 0)
        {
            // Handle junction table relationships
            {%- for f in ent.fields %}
            {%- if f.inner.field_type == "Entity" and f.relationship == "OrderedOneToMany" %}
                JunctionTableOps::OrderedOneToMany::upsertRightIds(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
            {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToMany" %}
                JunctionTableOps::UnorderedOneToMany::upsertRightIds(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
            {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToOne" %}
                JunctionTableOps::OneToOne::upsertRightId(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
            {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToOne" %}
                JunctionTableOps::ManyToOne::upsertRightId(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
            {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToMany" %}
                JunctionTableOps::UnorderedManyToMany::upsertRightIds(db, r.id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, r.{{ f.camel_name }});
            {%- endif %}
            {%- endfor %}

            updated.append(r);
        }
    }

    // Invalidate cache for updated entities
    if (!updated.isEmpty())
    {
        const auto updatedIds = extractIds(updated);
        {{ ent.pascal_name }}Cache::instance().invalidateEntities(updatedIds);
        {{ ent.pascal_name }}Cache::instance().invalidateRelationships(updatedIds);
    }

    return updated;
}

QList<SCE::{{ ent.pascal_name }}> SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::findMany(const QList<int> &ids) const
{
    QList<SCE::{{ ent.pascal_name }}> result;
    result.reserve(ids.size());

    if (ids.isEmpty())
        return result;

    // Try cache first
    if ({{ ent.pascal_name }}Cache::instance().getCachedEntities(ids, result))
        return result;

    QSqlDatabase db = m_dbSubContext.getConnection();

    // Build a dynamic IN clause
    QStringList inPlaceholders;
    inPlaceholders.fill("?"_L1, ids.size());
    const QString sql = QStringLiteral("SELECT id,%1 FROM {{ ent.snake_name }} WHERE id IN (%2)")
                            .arg(COLUMNS_NO_ID, inPlaceholders.join(","_L1));

    QSqlQuery q(db);
    q.prepare(sql);
    for (int id : ids)
        q.addBindValue(id);

    if (q.exec())
    {
        QList<int> foundIds;
        while (q.next())
        {
            const int rowId = q.value(0).toInt();
            foundIds.append(rowId);

            SCE::{{ ent.pascal_name }} {{ ent.camel_name }};
            {{ ent.camel_name }}.id = rowId;
        {%- for f in ent.normal_fields %}

            {%- if f.cpp_qt_base_type == "QDateTime" and f.required == false %}
            {
                const QString dateTimeStr = q.value({{ loop.index }}).toString();
                {{ ent.camel_name }}.{{ f.camel_name }} = dateTimeStr.isEmpty() ? std::nullopt
                    : std::optional(QDateTime::fromString(dateTimeStr, Qt::ISODate));
            }
            {%- elif f.cpp_qt_type == "QDateTime" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = QDateTime::fromString(q.value({{ loop.index }}).toString(), Qt::ISODate);

            {%- elif f.cpp_qt_base_type == "QUuid" and f.required == false %}
            {
                const QString uuidStr = q.value({{ loop.index }}).toString();
                {{ ent.camel_name }}.{{ f.camel_name }} = uuidStr.isEmpty() ? std::nullopt
                    : std::optional(QUuid::fromString(uuidStr));
            }
            {%- elif f.cpp_qt_type == "QUuid" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = QUuid::fromString(q.value({{ loop.index }}).toString());

            {%- elif f.inner.field_type == "Enum" and f.required == false %}
            {
                const int enumVal = q.value({{ loop.index }}).toInt();
                {{ ent.camel_name }}.{{ f.camel_name }} = (enumVal >= 0)
                    ? std::optional(static_cast<Entities::{{ f.cpp_qt_base_type }}>(enumVal))
                    : std::nullopt;
            }
            {%- elif f.inner.field_type == "Enum" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = static_cast<Entities::{{ f.cpp_qt_type }}>(q.value({{ loop.index }}).toInt());

            {%- elif f.required == false %}
            {
                const auto v = q.value({{ loop.index }});
                {{ ent.camel_name }}.{{ f.camel_name }} = v.isNull() ? std::nullopt : std::optional(v.value<{{ f.cpp_qt_base_type }}>());
            }

            {%- elif f.cpp_qt_type == "QString" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = q.value({{ loop.index }}).toString();

            {%- elif f.cpp_qt_type == "int" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = q.value({{ loop.index }}).toInt();

            {%- elif f.cpp_qt_type == "uint" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = q.value({{ loop.index }}).toUInt();

            {%- elif f.cpp_qt_type == "float" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = q.value({{ loop.index }}).toFloat();

            {%- elif f.cpp_qt_type == "bool" %}
            {{ ent.camel_name }}.{{ f.camel_name }} = q.value({{ loop.index }}).toBool();

            {%- else %}
            // TODO: check this type conversion
            {{ ent.camel_name }}.{{ f.camel_name }} = q.value({{ loop.index }}).value<{{ f.cpp_qt_type }}>();

            {%- endif %}
        {%- endfor %}

            result.append(std::move({{ ent.camel_name }}));
        }

        // Get relationship data for all found IDs in batch
        {% for f in ent.fields %}
        {%- if f.inner.field_type == "Entity" and f.relationship == "OrderedOneToMany" %}
        const auto {{ f.camel_name }}Map = JunctionTableOps::OrderedOneToMany::getRightIdsMany(db, foundIds, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToMany" %}
        const auto {{ f.camel_name }}Map = JunctionTableOps::UnorderedOneToMany::getRightIdsMany(db, foundIds, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToOne" %}
        const auto {{ f.camel_name }}Map = JunctionTableOps::OneToOne::getRightIdMany(db, foundIds, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToOne" %}
        const auto {{ f.camel_name }}Map = JunctionTableOps::ManyToOne::getRightIdMany(db, foundIds, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToMany" %}
        const auto {{ f.camel_name }}Map = JunctionTableOps::UnorderedManyToMany::getRightIdsMany(db, foundIds, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- endif %}
        {%- endfor %}

        // Populate relationships into results
        for (auto &{{ ent.camel_name }} : result)
        {
            {% for f in ent.fields %}
            {%- if f.inner.field_type == "Entity" %}
                {%- if f.relationship == "OneToOne" or f.relationship == "ManyToOne" %}
                    {%- if f.required == false %}
            {{ ent.camel_name }}.{{ f.camel_name }} = {{ f.camel_name }}Map.value({{ ent.camel_name }}.id);
                    {%- else %}
            if (auto it = {{ f.camel_name }}Map.find({{ ent.camel_name }}.id); it != {{ f.camel_name }}Map.end() && it->has_value())
                {{ ent.camel_name }}.{{ f.camel_name }} = it->value();
            else
                qCritical() << "Missing required relationship {{ f.camel_name }} for {{ ent.pascal_name }} with ID" << {{ ent.camel_name }}.id;
                    {%- endif %}
                {%- else %}
            {{ ent.camel_name }}.{{ f.camel_name }} = {{ f.camel_name }}Map.value({{ ent.camel_name }}.id);
                {%- endif %}
            {%- endif %}
            {%- endfor %}
        }

        // Cache the result
        {{ ent.pascal_name }}Cache::instance().setCachedEntities(ids, result);
    }
    return result;
}

QList<int> SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::removeMany(const QList<int> &ids)
{
    if (ids.isEmpty())
        return {};

    QSqlDatabase db = m_dbSubContext.getConnection();

    // Clean up forward junction table relationships first
    {% for f in ent.fields %}
    {%- if f.inner.field_type == "Entity" and f.relationship == "OrderedOneToMany" %}
    JunctionTableOps::OrderedOneToMany::removeWithLeftIdsMany(db, ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
    {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToMany" %}
    JunctionTableOps::UnorderedOneToMany::removeWithLeftIdsMany(db, ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
    {%- elif f.inner.field_type == "Entity" and f.relationship == "OneToOne" %}
    JunctionTableOps::OneToOne::removeWithLeftIdMany(db, ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
    {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToOne" %}
    JunctionTableOps::ManyToOne::removeWithLeftIdMany(db, ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
    {%- elif f.inner.field_type == "Entity" and f.relationship == "ManyToMany" %}
    JunctionTableOps::UnorderedManyToMany::removeWithLeftIdsMany(db, ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
    {%- endif %}
    {%- endfor %}

    // Clean up backward junction table relationships
{% for rid, r in s.entities[e].backward_relationships %}
    {%- if r.inner.left_entity == e and r.inner.relationship_type == "OrderedOneToMany" %}
    JunctionTableOps::OrderedOneToMany::removeWithRightIdsMany(db, ids, {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE{% if r.inner.left_entity == e %}_BACKWARD{% endif %});
    {%- elif r.inner.left_entity == e and r.inner.relationship_type == "OneToMany" %}
    JunctionTableOps::UnorderedOneToMany::removeWithRightIdsMany(db, ids, {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE{% if r.inner.left_entity == e %}_BACKWARD{% endif %});
    {%- elif r.inner.left_entity == e and r.inner.relationship_type == "OneToOne" %}
    JunctionTableOps::OneToOne::removeWithRightIdMany(db, ids, {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE{% if r.inner.left_entity == e %}_BACKWARD{% endif %});
    {%- elif r.inner.left_entity == e and r.inner.relationship_type == "ManyToOne" %}
    JunctionTableOps::ManyToOne::removeWithRightIdsMany(db, ids, {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE{% if r.inner.left_entity == e %}_BACKWARD{% endif %});
    {%- elif r.inner.left_entity == e and r.inner.relationship_type == "ManyToMany" %}
    JunctionTableOps::UnorderedManyToMany::removeWithRightIdsMany(db, ids, {{ s.entities[r.inner.left_entity].snake_name | upper }}_{{ r.field_snake_name | upper }}_JUNCTION_TABLE{% if r.inner.left_entity == e %}_BACKWARD{% endif %});
    {%- endif %}
{%- endfor %}

    // Batch DELETE with IN clause instead of per-row
    QStringList inPlaceholders;
    inPlaceholders.fill("?"_L1, ids.size());
    const QString sql = "DELETE FROM {{ ent.snake_name }} WHERE id IN (%1)"_L1
        .arg(inPlaceholders.join(","_L1));

    QSqlQuery q(db);
    q.prepare(sql);
    for (int id : ids)
        q.addBindValue(id);

    QList<int> removed;
    if (q.exec() && q.numRowsAffected() > 0)
    {
        // If all rows were deleted, return all ids; otherwise fall back to per-id verification
        if (q.numRowsAffected() == ids.size())
        {
            removed = ids;
        }
        else
        {
            // Some ids may not have existed â€” verify which ones were actually removed
            QSet<int> requestedIds(ids.begin(), ids.end());
            auto remaining = findMany(ids);
            QSet<int> remainingIds;
            remainingIds.reserve(remaining.size());
            for (const auto &r : remaining)
                remainingIds.insert(r.id);

            for (int id : ids)
            {
                if (!remainingIds.contains(id))
                    removed.append(id);
            }
        }
    }

    // Invalidate cache for removed entities
    if (!removed.isEmpty())
    {
        {{ ent.pascal_name }}Cache::instance().invalidateEntities(removed);
        {{ ent.pascal_name }}Cache::instance().invalidateRelationships(removed);
    }

    return removed;
}

void SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::setRelationshipIds(int {{ ent.camel_name }}Id, {{ ent.pascal_name }}RelationshipField relationship, QList<int> relatedIds)
{
    QSqlDatabase db = m_dbSubContext.getConnection();

    switch (relationship)
    {
    {% for f in ent.fields %}
    {%- if f.inner.field_type == "Entity" %}
    case {{ ent.pascal_name }}RelationshipField::{{ f.pascal_name }}:
        {%- if f.relationship == "OrderedOneToMany" %}
        JunctionTableOps::OrderedOneToMany::upsertRightIds(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, relatedIds);
        {%- elif f.relationship == "OneToMany" %}
        JunctionTableOps::UnorderedOneToMany::upsertRightIds(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, relatedIds);
        {%- elif f.relationship == "OneToOne" %}
            {%- if f.required %}
        if (relatedIds.isEmpty())
        {
            qCritical() << "Related IDs for required OneToOne relationship cannot be empty";
        }
        {
            int {{ f.camel_name }}RelatedId = relatedIds.first();
            {%- else %}
        {
            std::optional<int> {{ f.camel_name }}RelatedId;
            if (!relatedIds.isEmpty())
                {{ f.camel_name }}RelatedId = relatedIds.first();
            {%- endif %}
            JunctionTableOps::OneToOne::upsertRightId(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, {{ f.camel_name }}RelatedId);
        }
        {%- elif f.relationship == "ManyToOne" %}
            {%- if f.required %}
        if (relatedIds.isEmpty())
        {
            qCritical() << "Related IDs for required ManyToOne relationship cannot be empty";
        }
        {
            int {{ f.camel_name }}RelatedId = relatedIds.first();
            {%- else %}
        {
            std::optional<int> {{ f.camel_name }}RelatedId;
            if (!relatedIds.isEmpty())
                {{ f.camel_name }}RelatedId = relatedIds.first();
            {%- endif %}
            JunctionTableOps::ManyToOne::upsertRightId(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, {{ f.camel_name }}RelatedId);
        }
        {%- elif f.relationship == "ManyToMany" %}
        JunctionTableOps::UnorderedManyToMany::upsertRightIds(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, relatedIds);
        {%- endif %}
        break;
    {%- endif %}
    {%- endfor %}
    }

    // Invalidate cache for relationship changes
    {{ ent.pascal_name }}Cache::instance().invalidateEntity({{ ent.camel_name }}Id);
    {{ ent.pascal_name }}Cache::instance().invalidateRelationships({{ ent.camel_name }}Id);
}

QHash<int, QList<int>> SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::getRelationshipIdsMany(const QList<int> &{{ ent.camel_name }}Ids,
                                                                  {{ ent.pascal_name }}RelationshipField relationship) const
{
    // Try cache first
    QHash<int, QList<int>> result;
    if ({{ ent.pascal_name }}Cache::instance().getCachedRelationshipData({{ ent.camel_name }}Ids, relationship, result))
        return result;

    QSqlDatabase db = m_dbSubContext.getConnection();

    switch (relationship)
    {
    {% for f in ent.fields %}
    {%- if f.inner.field_type == "Entity" %}
    case {{ ent.pascal_name }}RelationshipField::{{ f.pascal_name }}:
        {%- if f.relationship == "OrderedOneToMany" %}
        result = JunctionTableOps::OrderedOneToMany::getRightIdsMany(db, {{ ent.camel_name }}Ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.relationship == "OneToMany" %}
        result = JunctionTableOps::UnorderedOneToMany::getRightIdsMany(db, {{ ent.camel_name }}Ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.relationship == "OneToOne" %}
        {
            const auto temp = JunctionTableOps::OneToOne::getRightIdMany(db, {{ ent.camel_name }}Ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
            for (auto it = temp.cbegin(); it != temp.cend(); ++it)
                result[it.key()] = it->has_value() ? QList<int>{ it->value() } : QList<int>{};
        }
        {%- elif f.relationship == "ManyToOne" %}
        {
            const auto temp = JunctionTableOps::ManyToOne::getRightIdMany(db, {{ ent.camel_name }}Ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
            for (auto it = temp.cbegin(); it != temp.cend(); ++it)
                result[it.key()] = it->has_value() ? QList<int>{ it->value() } : QList<int>{};
        }
        {%- elif f.relationship == "ManyToMany" %}
        result = JunctionTableOps::UnorderedManyToMany::getRightIdsMany(db, {{ ent.camel_name }}Ids, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- endif %}
        break;
    {%- endif %}
    {%- endfor %}

    default:
        throw std::invalid_argument("Unhandled relationship type");
    }

    // Cache the result
    {{ ent.pascal_name }}Cache::instance().setCachedRelationshipData({{ ent.camel_name }}Ids, relationship, result);

    return result;
}

int SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::getRelationshipIdsCount(int {{ ent.camel_name }}Id, {{ ent.pascal_name }}RelationshipField relationship)
{
    QSqlDatabase db = m_dbSubContext.getConnection();

    switch (relationship)
    {
    {% for f in ent.fields %}
    {%- if f.inner.field_type == "Entity" %}
    case {{ ent.pascal_name }}RelationshipField::{{ f.pascal_name }}:
        {%- if f.relationship == "OrderedOneToMany" %}
        return JunctionTableOps::OrderedOneToMany::getRightIdsCount(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.relationship == "OneToMany" %}
        return JunctionTableOps::UnorderedOneToMany::getRightIdsCount(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.relationship == "OneToOne" %}
        return JunctionTableOps::OneToOne::getRightIdCount(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.relationship == "ManyToOne" %}
        return JunctionTableOps::ManyToOne::getRightIdCount(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- elif f.relationship == "ManyToMany" %}
        return JunctionTableOps::UnorderedManyToMany::getRightIdsCount(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE);
        {%- endif %}
    {%- endif %}
    {%- endfor %}

    default:
        throw std::invalid_argument("Unhandled relationship type");
    }
}

QList<int> SCD{{ ent.pascal_name }}::{{ ent.pascal_name }}Table::getRelationshipIdsInRange(int {{ ent.camel_name }}Id, {{ ent.pascal_name }}RelationshipField relationship, int offset,
                                                         int limit)
{
    QSqlDatabase db = m_dbSubContext.getConnection();

    switch (relationship)
    {
    {% for f in ent.fields %}
    {%- if f.inner.field_type == "Entity" %}
    case {{ ent.pascal_name }}RelationshipField::{{ f.pascal_name }}:
        {%- if f.relationship == "OrderedOneToMany" %}
        return JunctionTableOps::OrderedOneToMany::getRightIdsInRange(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, offset, limit);
        {%- elif f.relationship == "OneToMany" %}
        return JunctionTableOps::UnorderedOneToMany::getRightIdsInRange(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, offset, limit);
        {%- elif f.relationship == "OneToOne" %}
        return JunctionTableOps::OneToOne::getRightIdInRange(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, offset, limit);
        {%- elif f.relationship == "ManyToOne" %}
        return JunctionTableOps::ManyToOne::getRightIdInRange(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, offset, limit);
        {%- elif f.relationship == "ManyToMany" %}
        return JunctionTableOps::UnorderedManyToMany::getRightIdsInRange(db, {{ ent.camel_name }}Id, {{ ent.snake_name | upper }}_{{ f.snake_name | upper }}_JUNCTION_TABLE, offset, limit);
        {%- endif %}
    {%- endif %}
    {%- endfor %}

    default:
        throw std::invalid_argument("Unhandled relationship type");
    }
}
