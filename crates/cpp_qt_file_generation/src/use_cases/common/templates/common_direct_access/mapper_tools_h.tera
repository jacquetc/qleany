#pragma once

#include <QJsonArray>
#include <QJsonObject>
#include <QJsonValue>
#include <QMetaObject>
#include <QMetaProperty>
#include <QSequentialIterable>
#include <QVariant>
#include <optional>

namespace {{ s.global.application_pascal_name }}::Common::DirectAccess
{

// ---------------------------------------------------------------------------
// map between optional enum types
// ---------------------------------------------------------------------------

template <typename TargetEnum, typename SourceEnum>
static std::optional<TargetEnum> mapOptionalEnum(const std::optional<SourceEnum> &source)
{
    if (source) {
        return static_cast<TargetEnum>(*source);
    }
    return std::nullopt;
}

// ---------------------------------------------------------------------------
// Register QVariant converters for std::optional<EnumType>.
// Must be called once per optional enum type at startup (e.g. in registerConverters()).
// Without this, QMetaProperty cannot round-trip std::optional<MyEnum> through QVariant.
// ---------------------------------------------------------------------------

template <typename EnumType>
void registerOptionalEnumConverters()
{
    QMetaType::registerConverter<QVariant, std::optional<EnumType>>(
        [](const QVariant &var) -> std::optional<EnumType> {
            return (var.isNull() || !var.isValid())
                       ? std::nullopt
                       : std::optional<EnumType>{static_cast<EnumType>(var.toInt())};
        });
    QMetaType::registerConverter<std::optional<EnumType>, QVariant>(
        [](const std::optional<EnumType> &opt) -> QVariant {
            return opt ? QVariant(static_cast<int>(*opt)) : QVariant();
        });
}

// ---------------------------------------------------------------------------
// Generic Q_GADGET from/to QJsonObject serialization
// ---------------------------------------------------------------------------

namespace detail
{

/// Convert a single QMetaProperty value to a QJsonValue.
inline QJsonValue propertyToJson(const QVariant &var, const QMetaProperty &prop)
{
    // Null/invalid → JSON null (handles std::optional<T> = nullopt via registered converters)
    if (!var.isValid() || var.isNull())
        return QJsonValue::Null;

    const QByteArray typeName = prop.typeName();

    // List types → QJsonArray
    if (typeName.startsWith("QList<"))
    {
        QJsonArray arr;
        const auto seq = var.value<QSequentialIterable>();
        for (auto it = seq.begin(); it != seq.end(); ++it)
        {
            const QVariant item = *it;
            // Enum items inside lists: serialize as int
            if (item.metaType().flags() & QMetaType::IsEnumeration)
                arr.append(item.toInt());
            else
                arr.append(QJsonValue::fromVariant(item));
        }
        return arr;
    }

    // Enum types (non-optional, non-list): serialize as int
    if (prop.isEnumType())
        return var.toInt();

    // Basic types, QUuid, QDateTime, std::optional<basic> (via registered converters)
    return QJsonValue::fromVariant(var);
}

/// Write a QJsonValue into a single QMetaProperty on a gadget.
inline void jsonToProperty(const QJsonValue &val, const QMetaProperty &prop, void *gadget)
{
    // Null / undefined → default-constructed value (nullopt for optionals, 0/empty for others)
    if (val.isNull() || val.isUndefined())
    {
        prop.writeOnGadget(gadget, QVariant(prop.metaType()));
        return;
    }

    const QByteArray typeName = prop.typeName();

    // List types ← QJsonArray
    if (val.isArray() && typeName.startsWith("QList<"))
    {
        const QJsonArray arr = val.toArray();
        QVariantList list;
        list.reserve(arr.size());
        for (const QJsonValue &item : arr)
            list.append(item.toVariant());
        QVariant var = QVariant::fromValue(list);
        if (var.canConvert(prop.metaType()))
            var.convert(prop.metaType());
        prop.writeOnGadget(gadget, var);
        return;
    }

    // Enum types (non-optional): JSON number → int → write via QMetaEnum
    if (prop.isEnumType())
    {
        prop.writeOnGadget(gadget, val.toInt());
        return;
    }

    // General path: convert JSON → QVariant → target property type
    QVariant var = val.toVariant();
    if (var.canConvert(prop.metaType()))
        var.convert(prop.metaType());
    prop.writeOnGadget(gadget, var);
}

} // namespace detail

/// Serialize any Q_GADGET to a QJsonObject using its Q_PROPERTY declarations.
/// Handles: basic types, enums, std::optional<T>, QList<T>.
template <typename T>
QJsonObject gadgetToJson(const T &gadget)
{
    QJsonObject json;
    const QMetaObject *meta = &T::staticMetaObject;
    for (int i = 0; i < meta->propertyCount(); ++i)
    {
        const QMetaProperty prop = meta->property(i);
        json[QLatin1StringView(prop.name())] =
            detail::propertyToJson(prop.readOnGadget(&gadget), prop);
    }
    return json;
}

/// Deserialize a QJsonObject into any Q_GADGET using its Q_PROPERTY declarations.
/// Handles: basic types, enums, std::optional<T>, QList<T>.
template <typename T>
T gadgetFromJson(const QJsonObject &json)
{
    T gadget{};
    const QMetaObject *meta = &T::staticMetaObject;
    for (int i = 0; i < meta->propertyCount(); ++i)
    {
        const QMetaProperty prop = meta->property(i);
        const auto key = QLatin1StringView(prop.name());
        if (json.contains(key))
            detail::jsonToProperty(json.value(key), prop, &gadget);
    }
    return gadget;
}

} // namespace {{ s.global.application_pascal_name }}::Common::DirectAccess
