{%- set e = s.file.inner.entity %}
{%- set ent = s.entities[e] %}
#include "set_relationship_ids_uc.h"

namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
{
namespace SCE = Common::Entities;
namespace SCDatabase = Common::Database;

void SetRelationshipIdsUseCase::execute(int {{ ent.camel_name }}Id, {{ ent.pascal_name }}RelationshipField entityRelationship,
                                        const QList<int> &relatedIds)
{
    if (m_hasExecuted)
    {
        // If already executed, don't execute again
        return;
    }

    // Store parameters for undo/redo
    m_{{ ent.camel_name }}Id = {{ ent.camel_name }}Id;
    m_relationship = entityRelationship;
    m_newRelatedIds = relatedIds;

    const auto commonRel = DtoMapper::toCommonRelationshipField(entityRelationship);

    m_uow->beginTransaction();

    // Get original relationship IDs for undo functionality
    m_originalRelatedIds = m_uow->getRelationship({{ ent.camel_name }}Id, commonRel);

    // Snapshot related children before they may be cascade-removed
    m_displacedChildrenSnapshot = m_uow->snapshotRelated({{ ent.camel_name }}Id, commonRel);

    // Set the new relationship IDs (cascade-removes displaced children)
    m_uow->setRelationship({{ ent.camel_name }}Id, commonRel, relatedIds);

    // Update date
    auto {{ ent.camel_name }} = m_uow->get({ {{ ent.camel_name }}Id}).at(0); // we are sure that it exists
    {{ ent.camel_name }}.updatedAt = QDateTime::currentDateTimeUtc();
    m_uow->update({ {{ ent.camel_name }} });

    m_uow->commit();

    m_hasExecuted = true;
}

SCU::Result<void> SetRelationshipIdsUseCase::undo()
{
    if (!m_hasExecuted)
    {
        return SCU::Result<void>("Cannot undo: no relationship was set"_L1);
    }

    const auto commonRel = DtoMapper::toCommonRelationshipField(m_relationship);

    try
    {
        m_uow->beginTransaction();

        // Snapshot new children before they are cascade-removed (for redo)
        m_newChildrenSnapshot = m_uow->snapshotRelated(m_{{ ent.camel_name }}Id, commonRel);

        // Restore cascade-removed children from snapshot
        m_uow->restoreRelated(commonRel, m_displacedChildrenSnapshot);

        // Restore original relationship IDs (cascade-removes new children)
        m_uow->setRelationship(m_{{ ent.camel_name }}Id, commonRel, m_originalRelatedIds);

        m_uow->commit();

        return SCU::Result<void>();
    }
    catch (const std::exception &e)
    {
        m_uow->rollback();
        return SCU::Result<void>("Undo failed: "_L1 + QString::fromStdString(e.what()));
    }
}

SCU::Result<void> SetRelationshipIdsUseCase::redo()
{
    if (!m_hasExecuted)
    {
        return SCU::Result<void>("Cannot redo: execute() must be called first"_L1);
    }

    const auto commonRel = DtoMapper::toCommonRelationshipField(m_relationship);

    try
    {
        m_uow->beginTransaction();

        // Re-snapshot displaced children (restored by undo) for next undo cycle
        m_displacedChildrenSnapshot = m_uow->snapshotRelated(m_{{ ent.camel_name }}Id, commonRel);

        // Restore new children that were cascade-removed during undo
        m_uow->restoreRelated(commonRel, m_newChildrenSnapshot);

        // Re-apply the new relationship IDs (cascade-removes displaced children)
        m_uow->setRelationship(m_{{ ent.camel_name }}Id, commonRel, m_newRelatedIds);

        m_uow->commit();

        return SCU::Result<void>();
    }
    catch (const std::exception &e)
    {
        m_uow->rollback();
        return SCU::Result<void>("Redo failed: "_L1 + QString::fromStdString(e.what()));
    }
}

} // namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}