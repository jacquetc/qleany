{%- set e = s.file.inner.entity %}
{%- set ent = s.entities[e] %}
#include "update_uc.h"

namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
{
namespace SCE = Common::Entities;

QList<{{ ent.pascal_name }}Dto> Update{{ ent.pascal_name }}UseCase::execute(const QList<{{ ent.pascal_name }}Dto> &{{ ent.camel_plural_name }})
{
    if (m_hasExecuted)
    {
        // If already executed, return cached results
        return m_updated{{ ent.pascal_name }}s;
    }

{%- if ent.inner.undoable %}
    // First, get the original data for undo/redo
    QList<int> {{ ent.camel_name }}Ids;
    for (const auto &{{ ent.camel_name }} : {{ ent.camel_plural_name }})
    {
        {{ ent.camel_name }}Ids.append({{ ent.camel_name }}.id);
    }
{%- endif %}

    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

{%- if ent.inner.undoable %}
        auto originalEntities = m_uow->get({{ ent.camel_name }}Ids);
        m_original{{ ent.pascal_name }}s = DtoMapper::toDtoList(originalEntities);
{%- endif %}

        // Perform the update
        auto mappedEntities = DtoMapper::toEntityList({{ ent.camel_plural_name }});

        // Update the updatedAt timestamp
        QDateTime currentTime = QDateTime::currentDateTimeUtc();
        for (auto &entity : mappedEntities)
            entity.updatedAt = currentTime;

        auto updatedEntities = m_uow->update(mappedEntities);
        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");

        m_updated{{ ent.pascal_name }}s = DtoMapper::toDtoList(updatedEntities);
        m_hasExecuted = true;
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }

    return m_updated{{ ent.pascal_name }}s;
}

{%- if ent.inner.undoable %}

SCU::Result<void> Update{{ ent.pascal_name }}UseCase::undo()
{
    if (!m_hasExecuted || m_original{{ ent.pascal_name }}s.isEmpty())
    {
        return SCU::Result<void>("Cannot undo: no {{ ent.camel_plural_name }} were updated"_L1);
    }

    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        // Restore the original {{ ent.camel_plural_name }}
        auto mappedEntities = DtoMapper::toEntityList(m_original{{ ent.pascal_name }}s);
        m_uow->update(mappedEntities);
        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");

        return {};
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }
}

SCU::Result<void> Update{{ ent.pascal_name }}UseCase::redo()
{
    if (!m_hasExecuted)
    {
        return SCU::Result<void>("Cannot redo: execute() must be called first"_L1);
    }

    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        auto mappedEntities = DtoMapper::toEntityList(m_updated{{ ent.pascal_name }}s);
        m_uow->update(mappedEntities);
        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");

        return {};
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }
}
{%- endif %}

} // namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
