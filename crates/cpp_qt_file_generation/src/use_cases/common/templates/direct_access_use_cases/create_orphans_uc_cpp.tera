{%- set e = s.file.inner.entity %}
{%- set ent = s.entities[e] %}
#include "create_orphans_uc.h"

namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
{
namespace SCE = Common::Entities;
namespace SCDatabase = Common::Database;

QList<{{ ent.pascal_name }}Dto> CreateOrphan{{ ent.pascal_name }}UseCase::execute(const QList<Create{{ ent.pascal_name }}Dto> &{{ ent.camel_plural_name }})
{
    if (m_hasExecuted)
    {
        // If already executed, return cached results
        return m_created{{ ent.pascal_plural_name }};
    }

{%- if ent.inner.undoable %}
    // Store original data for undo/redo
    m_original{{ ent.pascal_plural_name }} = {{ ent.camel_plural_name }};
{%- endif %}

    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        auto mappedEntities = DtoMapper::toEntityList({{ ent.camel_plural_name }});

        // set dates:
        QDateTime currentTime = QDateTime::currentDateTimeUtc();
        for (auto &entity : mappedEntities)
        {
            entity.createdAt = currentTime;
            entity.updatedAt = entity.createdAt;
        }

        auto createdEntities = m_uow->createOrphans(mappedEntities);
        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");

        m_created{{ ent.pascal_plural_name }} = DtoMapper::toDtoList(createdEntities);
        m_hasExecuted = true;
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }

    return m_created{{ ent.pascal_plural_name }};
}

{%- if ent.inner.undoable %}

SCU::Result<void> CreateOrphan{{ ent.pascal_name }}UseCase::undo()
{
    if (!m_hasExecuted || m_created{{ ent.pascal_plural_name }}.isEmpty())
    {
        return SCU::Result<void>("Cannot undo: no {{ ent.camel_plural_name }} were created"_L1);
    }

    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        // Remove the created {{ ent.camel_plural_name }} by their IDs
        QList<int> idsToRemove;
        for (const auto &{{ ent.camel_name }} : m_created{{ ent.pascal_plural_name }})
        {
            idsToRemove.append({{ ent.camel_name }}.id);
        }

        // Snapshot the created entity tree before removing (for redo)
        m_oldTreeSnapshot = m_uow->snapshot(idsToRemove);

        // Use the unit of work to remove the created {{ ent.camel_plural_name }}
        m_uow->remove(idsToRemove);
        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");

        return SCU::Result<void>();
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }
}

SCU::Result<void> CreateOrphan{{ ent.pascal_name }}UseCase::redo()
{
    if (!m_hasExecuted)
    {
        return SCU::Result<void>("Cannot redo: execute() must be called first"_L1);
    }

    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        // Restore the entity tree from the snapshot taken during undo
        m_uow->restore(m_oldTreeSnapshot);
        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");

        return SCU::Result<void>();
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }
}
{%- endif %}

} // namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
