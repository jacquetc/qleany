{%- set e = s.file.inner.entity %}
{%- set ent = s.entities[e] %}
#include "create_uc.h"

namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
{
namespace SCE = Common::Entities;
namespace SCDatabase = Common::Database;

QList<{{ ent.pascal_name }}Dto> Create{{ ent.pascal_name }}UseCase::execute(const QList<Create{{ ent.pascal_name }}Dto> &{{ ent.camel_plural_name }}, int ownerId, int index)
{
    if (m_hasExecuted)
    {
        // If already executed, return cached results
        return m_created{{ ent.pascal_plural_name }};
    }

    // Store original data for undo/redo
    m_original{{ ent.pascal_plural_name }} = {{ ent.camel_plural_name }};
    m_ownerId = ownerId;
    m_index = index;

    if (!m_uow->beginTransaction())
    {
        qCritical() << "Failed to begin transaction";
        return {};
    }
    auto mappedEntities = DtoMapper::toEntityList({{ ent.camel_plural_name }});

    // set dates:
    QDateTime currentTime = QDateTime::currentDateTimeUtc();
    for (auto &entity : mappedEntities)
    {
        entity.createdAt = currentTime;
        entity.updatedAt = entity.createdAt;
    }

{%- if ent.owner_relationship_type == "OneToOne" or ent.owner_relationship_type == "ManyToOne" %}
    // Pre-snapshot existing children that will be cascade-removed by create
    m_existingChildIds = m_uow->getRelationshipsFromOwner(ownerId);
    if (!m_existingChildIds.isEmpty())
        m_displacedChildrenSnapshot = m_uow->snapshot(m_existingChildIds);
{%- else %}
    // Capture owner junction state before create (for undo)
    m_previousOwnerRelationshipIds = m_uow->getRelationshipsFromOwner(ownerId);
{%- endif %}

    auto createdEntities = m_uow->create(mappedEntities, ownerId, index);
    m_uow->commit();

    m_created{{ ent.pascal_plural_name }} = DtoMapper::toDtoList(createdEntities);
    m_hasExecuted = true;

    return m_created{{ ent.pascal_plural_name }};
}

SCU::Result<void> Create{{ ent.pascal_name }}UseCase::undo()
{
    if (!m_hasExecuted || m_created{{ ent.pascal_plural_name }}.isEmpty())
    {
        return SCU::Result<void>("Cannot undo: no {{ ent.camel_plural_name }} were created"_L1);
    }

    try
    {
        if (!m_uow->beginTransaction())
        {
            return SCU::Result<void>("Failed to begin transaction"_L1);
        }

        // Collect IDs of created {{ ent.camel_plural_name }}
        QList<int> idsToRemove;
        for (const auto &{{ ent.camel_name }} : m_created{{ ent.pascal_plural_name }})
        {
            idsToRemove.append({{ ent.camel_name }}.id);
        }

        // Snapshot the created entity tree before removing (for redo)
        m_oldTreeSnapshot = m_uow->snapshot(idsToRemove);

        // Remove the created {{ ent.camel_plural_name }}
        m_uow->remove(idsToRemove);

{%- if ent.owner_relationship_type == "OneToOne" or ent.owner_relationship_type == "ManyToOne" %}
        // Restore displaced children and fix owner junction
        if (!m_displacedChildrenSnapshot.tableData.entityRows.rows.isEmpty())
        {
            m_uow->restore(m_displacedChildrenSnapshot);
            m_uow->setRelationshipsInOwner(m_existingChildIds, m_ownerId);
        }
        else
        {
            m_uow->setRelationshipsInOwner({}, m_ownerId);
        }
{%- else %}
        // Restore owner junction to pre-create state
        m_uow->setRelationshipsInOwner(m_previousOwnerRelationshipIds, m_ownerId);
{%- endif %}

        m_uow->commit();

        return SCU::Result<void>();
    }
    catch (const std::exception &e)
    {
        m_uow->rollback();
        return SCU::Result<void>("Undo failed: "_L1 + QString::fromStdString(e.what()));
    }
}

SCU::Result<void> Create{{ ent.pascal_name }}UseCase::redo()
{
    if (!m_hasExecuted)
    {
        return SCU::Result<void>("Cannot redo: execute() must be called first"_L1);
    }

    try
    {
        if (!m_uow->beginTransaction())
        {
            return SCU::Result<void>("Failed to begin transaction"_L1);
        }

{%- if ent.owner_relationship_type == "OneToOne" or ent.owner_relationship_type == "ManyToOne" %}
        // Re-snapshot displaced children (restored by undo) for next undo cycle
        if (!m_existingChildIds.isEmpty())
        {
            m_displacedChildrenSnapshot = m_uow->snapshot(m_existingChildIds);
            m_uow->remove(m_existingChildIds);
        }

        // Restore the new entity tree
        m_uow->restore(m_oldTreeSnapshot);

        // Fix owner junction to point to the new entities
        const auto newIds = SCDatabase::SnapshotUtil::extractIds(m_oldTreeSnapshot.tableData.entityRows);
        m_uow->setRelationshipsInOwner(newIds, m_ownerId);
{%- else %}
        // Restore the entity tree from the snapshot taken during undo
        m_uow->restore(m_oldTreeSnapshot);

        // Rebuild owner junction: previous IDs + created IDs at the correct index
        auto redoJunction = m_previousOwnerRelationshipIds;
        const auto createdIds = SCDatabase::SnapshotUtil::extractIds(m_oldTreeSnapshot.tableData.entityRows);
        if (m_index >= 0 && m_index < redoJunction.size())
        {
            for (int i = 0; i < createdIds.size(); ++i)
                redoJunction.insert(m_index + i, createdIds.at(i));
        }
        else
        {
            redoJunction.append(createdIds);
        }
        m_uow->setRelationshipsInOwner(redoJunction, m_ownerId);
{%- endif %}

        m_uow->commit();

        return SCU::Result<void>();
    }
    catch (const std::exception &e)
    {
        m_uow->rollback();
        return SCU::Result<void>("Redo failed: "_L1 + QString::fromStdString(e.what()));
    }
}

} // namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
