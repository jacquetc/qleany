{%- set e = s.file.inner.entity %}
{%- set ent = s.entities[e] %}
#pragma once

#include "common/dto_mapper.h"
#include "entities/{{ ent.snake_name }}.h"
#include "i_{{ ent.snake_name }}_unit_of_work.h"
{%- if ent.inner.undoable %}
#include "undo_redo/undo_redo_command.h"
{%- endif %}
#include <memory>

namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}
{
namespace SCE = Common::Entities;
{%- if ent.inner.undoable %}
namespace SCU = Common::UndoRedo;
namespace SCDatabase = Common::Database;
{%- endif %}

class Create{{ ent.pascal_name }}UseCase
{
  public:
    explicit Create{{ ent.pascal_name }}UseCase(std::unique_ptr<I{{ ent.pascal_name }}UnitOfWork> uow) : m_uow(std::move(uow))
    {
    }
    ~Create{{ ent.pascal_name }}UseCase() = default;

    QList<{{ ent.pascal_name }}Dto> execute(const QList<Create{{ ent.pascal_name }}Dto> &{{ ent.camel_plural_name }}, int ownerId, int index);
{%- if ent.inner.undoable %}
    SCU::Result<void> undo();
    SCU::Result<void> redo();
{%- endif %}

  private:
    std::unique_ptr<I{{ ent.pascal_name }}UnitOfWork> m_uow;
{%- if ent.inner.undoable %}
    QList<Create{{ ent.pascal_name }}Dto> m_original{{ ent.pascal_plural_name }};
    QList<{{ ent.pascal_name }}Dto> m_created{{ ent.pascal_plural_name }};
    int m_ownerId = 0;
    int m_index = -1;
    SCDatabase::EntityTreeSnapshot m_oldTreeSnapshot;
{%- if ent.owner_relationship_type == "OneToOne" or ent.owner_relationship_type == "ManyToOne" %}
    QList<int> m_existingChildIds;
    SCDatabase::EntityTreeSnapshot m_displacedChildrenSnapshot;
{%- else %}
    QList<int> m_previousOwnerRelationshipIds;
{%- endif %}
{%- else %}
    QList<{{ ent.pascal_name }}Dto> m_created{{ ent.pascal_plural_name }};
{%- endif %}
    bool m_hasExecuted = false;
};

} // namespace {{ s.global.application_pascal_name }}::DirectAccess::{{ ent.pascal_name }}