{%- set f_id = s.file.inner.feature %}
{%- set feat = s.features[f_id] %}
{%- set uc_id = s.file.inner.use_case %}
{%- set uc = s.use_cases[uc_id] %}


#pragma once
#include "database/db_context.h"
#include "{{ uc.snake_name }}_uc/i_{{ uc.snake_name }}_uow.h"
#include "{{ feat.snake_name }}_dtos.h"
{%- if uc.inner.long_operation %}
#include "long_operation/i_long_operation.h"
{%- endif %}
#include <memory>

namespace {{ s.global.application_pascal_name }}::{{ feat.pascal_name }}
{

{%- if uc.inner.long_operation %}

class {{ uc.pascal_name }}UseCase : public Common::LongOperation::ILongOperation
{
  public:
  {%- if uc.dto_in %}
    {{ uc.pascal_name }}UseCase(std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> uow, const {{ uc.dto_in.pascal_name }} &{{ uc.dto_in.camel_name }});
  {%- else %}
    explicit {{ uc.pascal_name }}UseCase(std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> uow);
  {%- endif %}

    QJsonObject execute(
        std::function<void(Common::LongOperation::OperationProgress)> progressCallback,
        const std::atomic<bool> &cancelFlag) override;

  private:
    std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> m_uow;
  {%- if uc.dto_in %}
    {{ uc.dto_in.pascal_name }} m_{{ uc.dto_in.camel_name }};
  {%- endif %}
};

{%- else %}

class {{ uc.pascal_name }}UseCase
{
  {%- if uc.dto_in %}
       {% set dto_in_arg_str = "const " ~ uc.dto_in.pascal_name ~ "&" ~ uc.dto_in.camel_name %}
  {%- else %}
       {% set dto_in_arg_str = "" %}
  {%- endif %}
  {%- if uc.dto_out %}
       {% set dto_out_str = uc.dto_out.pascal_name %}
  {%- else %}
       {% set dto_out_str = "bool" %}
  {%- endif %}



  public:
    explicit {{ uc.pascal_name }}UseCase(std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> uow);
    {% if uc.dto_out %}[[nodiscard]]{% endif %} {{ dto_out_str }} execute({{ dto_in_arg_str }}) const;

  private:
    std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> m_uow;
};

{%- endif %}

} // {{ s.global.application_pascal_name }}::{{ feat.pascal_name }}
