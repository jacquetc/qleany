{%- set f_id = s.file.inner.feature %}
{%- set feat = s.features[f_id] %}
{%- set uc_id = s.file.inner.use_case %}
{%- set uc = s.use_cases[uc_id] %}


#include "{{ uc.snake_name }}_uc.h"
{%- if uc.inner.long_operation %}
#include "direct_access/mapper_tools.h"
{%- endif %}

namespace {{ s.global.application_pascal_name }}::{{ feat.pascal_name }}
{

{%- if uc.inner.long_operation %}

{%- if uc.dto_in %}
{{ uc.pascal_name }}UseCase::{{ uc.pascal_name }}UseCase(
    std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> uow, const {{ uc.dto_in.pascal_name }} &{{ uc.dto_in.camel_name }})
    : m_uow(std::move(uow)), m_{{ uc.dto_in.camel_name }}({{ uc.dto_in.camel_name }})
{
}
{%- else %}
{{ uc.pascal_name }}UseCase::{{ uc.pascal_name }}UseCase(
    std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> uow)
    : m_uow(std::move(uow))
{
}
{%- endif %}

QJsonObject {{ uc.pascal_name }}UseCase::execute(
    std::function<void(Common::LongOperation::OperationProgress)> progressCallback,
    const std::atomic<bool> &cancelFlag)
{
    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        // TODO: Implement long operation logic.
        // Check cancelFlag.load() periodically and call progressCallback() to report progress.
        // On cancellation, call m_uow->rollback() and return early.
        qCritical("Unimplemented code: {{ feat.pascal_name }}::{{ uc.pascal_name }}UseCase::execute");

        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }

    m_uow->publish{{ uc.pascal_name }}Signal();

{%- if uc.dto_out %}
    // TODO: Populate resultDto with actual results, then return serialized JSON.
    {{ uc.dto_out.pascal_name }} resultDto{};
    return Common::DirectAccess::gadgetToJson(resultDto);
{%- else %}
{% raw %}    return QJsonObject{ {u"success"_s, true} };{% endraw %}
{%- endif %}
}

{%- else %}

{{ uc.pascal_name }}UseCase::{{ uc.pascal_name }}UseCase(
    std::unique_ptr<I{{ uc.pascal_name }}UnitOfWork> uow)
    : m_uow(std::move(uow))
{
}

  {%- if uc.dto_in %}
       {% set dto_in_arg_str = "const " ~ uc.dto_in.pascal_name ~ "&" ~ uc.dto_in.camel_name %}
  {%- else %}
       {% set dto_in_arg_str = "" %}
  {%- endif %}
  {%- if uc.dto_out %}
       {% set dto_out_str = uc.dto_out.pascal_name %}
  {%- else %}
       {% set dto_out_str = "bool" %}
  {%- endif %}


{{ dto_out_str }} {{ uc.pascal_name }}UseCase::execute({{ dto_in_arg_str }}) const
{
    try
    {
        if (!m_uow->beginTransaction())
            throw std::runtime_error("Failed to begin transaction");

        qCritical("Unimplemented code: {{ feat.pascal_name }}::{{ uc.pascal_name }}UseCase::execute");

        if (!m_uow->commit())
            throw std::runtime_error("Failed to commit transaction");
    }
    catch (...)
    {
        m_uow->rollback();
        throw;
    }

    m_uow->publish{{ uc.pascal_name }}Signal();

{%- if uc.dto_out %}
   return {};
  {%- else %}
   return true;
{%- endif %}
}

{%- endif %}

} // namespace {{ s.global.application_pascal_name }}::{{ feat.pascal_name }}
