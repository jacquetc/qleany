// Generated by Qleany. Edit at your own risk! Be careful when regenerating this file
// as changes will be lost.
use crate::ExportToMermaidReturnDto;
use anyhow::{Result, anyhow};
use common::database::QueryUnitOfWork;
use common::entities::{
    Dto, DtoField, Entity, Feature, Field, FieldRelationshipType, FieldType, Global, Relationship,
    Root, UseCase, UserInterface, Workspace,
};
use common::types::EntityId;

pub trait ExportToMermaidUnitOfWorkFactoryTrait {
    fn create(&self) -> Box<dyn ExportToMermaidUnitOfWorkTrait>;
}

#[macros::uow_action(entity = "Dto", action = "GetRO")]
#[macros::uow_action(entity = "Dto", action = "GetMultiRO")]
#[macros::uow_action(entity = "DtoField", action = "GetRO")]
#[macros::uow_action(entity = "DtoField", action = "GetMultiRO")]
#[macros::uow_action(entity = "Global", action = "GetRO")]
#[macros::uow_action(entity = "Global", action = "GetMultiRO")]
#[macros::uow_action(entity = "Relationship", action = "GetRO")]
#[macros::uow_action(entity = "Relationship", action = "GetMultiRO")]
#[macros::uow_action(entity = "UserInterface", action = "GetRO")]
#[macros::uow_action(entity = "UserInterface", action = "GetMultiRO")]
#[macros::uow_action(entity = "Root", action = "GetRO")]
#[macros::uow_action(entity = "Root", action = "GetMultiRO")]
#[macros::uow_action(entity = "Workspace", action = "GetRO")]
#[macros::uow_action(entity = "Workspace", action = "GetMultiRO")]
#[macros::uow_action(entity = "Entity", action = "GetRO")]
#[macros::uow_action(entity = "Entity", action = "GetMultiRO")]
#[macros::uow_action(entity = "Field", action = "GetRO")]
#[macros::uow_action(entity = "Field", action = "GetMultiRO")]
#[macros::uow_action(entity = "Feature", action = "GetRO")]
#[macros::uow_action(entity = "Feature", action = "GetMultiRO")]
#[macros::uow_action(entity = "UseCase", action = "GetRO")]
#[macros::uow_action(entity = "UseCase", action = "GetMultiRO")]
pub trait ExportToMermaidUnitOfWorkTrait: QueryUnitOfWork {}

pub struct ExportToMermaidUseCase {
    uow_factory: Box<dyn ExportToMermaidUnitOfWorkFactoryTrait>,
}

impl ExportToMermaidUseCase {
    pub fn new(uow_factory: Box<dyn ExportToMermaidUnitOfWorkFactoryTrait>) -> Self {
        ExportToMermaidUseCase { uow_factory }
    }

    pub fn execute(&mut self) -> Result<ExportToMermaidReturnDto> {
        let uow = self.uow_factory.create();
        uow.begin_transaction()?;

        // Get root
        let roots = uow.get_root_multi(&[])?;
        if roots.is_empty() {
            return Err(anyhow!("No root found"));
        }
        let root = roots[0].as_ref().ok_or(anyhow!("Root is None"))?;

        // Get workspace
        let workspace = uow
            .get_workspace(&root.workspace.ok_or(anyhow!("Workspace ID is None"))?)?
            .ok_or(anyhow!("Workspace not found"))?;

        // Get all entities
        let entities = uow.get_entity_multi(&workspace.entities)?;
        let entities: Vec<Entity> = entities.into_iter().flatten().collect();

        // Get all fields
        let field_ids: Vec<EntityId> = entities.iter().flat_map(|e| e.fields.clone()).collect();
        let fields = uow.get_field_multi(&field_ids)?;
        let fields: Vec<Field> = fields.into_iter().flatten().collect();

        uow.end_transaction()?;

        // Generate Mermaid diagram
        let mermaid_diagram = self.generate_mermaid(&entities, &fields)?;

        Ok(ExportToMermaidReturnDto { mermaid_diagram })
    }

    fn generate_mermaid(&self, entities: &[Entity], fields: &[Field]) -> Result<String> {
        let mut output = String::from("erDiagram\n");

        // Filter out heritage-only entities (like EntityBase)
        let visible_entities: Vec<&Entity> =
            entities.iter().filter(|e| !e.only_for_heritage).collect();

        for (i, entity) in visible_entities.iter().enumerate() {
            // Entity block
            output.push_str(&format!("{} {{\n", entity.name));

            let mut all_entity_fields: Vec<Field> = vec![];

            // Add fields from inherited Entity
            if let Some(inherited_entity_id) = entity.inherits_from {
                let inherited_entity = entities.iter()
                    .find(|e| e.id == inherited_entity_id)
                    .ok_or(anyhow::anyhow!("Entity does not exist"))?;

                let inherited_fields = inherited_entity.fields.clone();
                let inherited_fields = fields.iter().filter(|f| inherited_fields.contains(&f.id)).cloned().collect::<Vec<Field>>();
                all_entity_fields.extend(inherited_fields);

            }

            // Get fields for this entity
                let entity_fields: Vec<Field> =
                    fields
                .iter()
                .filter(|f| entity.fields.contains(&f.id)).cloned()
                .collect();

            all_entity_fields.extend(entity_fields);

            for field in &all_entity_fields {
                let field_line = self.format_field(field, entities);
                output.push_str(&format!("    {}\n", field_line));
            }

            output.push_str("}\n");

            // Add relationship lines after entity block
            for field in &all_entity_fields {
                if field.field_type == FieldType::Entity {
                    if let Some(rel_line) = self.format_relationship(field, entity, entities) {
                        output.push_str(&rel_line);
                        output.push('\n');
                    }
                }
            }

            // Add blank line between entities (not after the last one)
            if i < visible_entities.len() - 1 {
                output.push('\n');
            }
        }

        Ok(output)
    }

    fn format_field(&self, field: &Field, entities: &[Entity]) -> String {
        let type_str = match field.field_type {
            FieldType::Boolean => "bool".to_string(),
            FieldType::Integer => "int".to_string(),
            FieldType::UInteger => "uint".to_string(),
            FieldType::Float => "float".to_string(),
            FieldType::String => "string".to_string(),
            FieldType::Uuid => "uuid".to_string(),
            FieldType::DateTime => "datetime".to_string(),
            FieldType::Entity => {
                // Get referenced entity name
                field
                    .entity
                    .and_then(|id| entities.iter().find(|e| e.id == id))
                    .map(|e| e.name.clone())
                    .unwrap_or_else(|| "Entity".to_string())
            }
            FieldType::Enum => field
                .enum_name
                .clone()
                .unwrap_or_else(|| "enum".to_string()),
        };

        let optional_marker = if !field.required { " \"optional\"" } else { "" };
        
        // exception for id field
        if field.name == "id" {
            return "EntityId id".to_string();
        }

        format!("{} {}{}", type_str, field.name, optional_marker)
    }

    fn format_relationship(
        &self,
        field: &Field,
        owner_entity: &Entity,
        entities: &[Entity],
    ) -> Option<String> {
        let target_entity = field
            .entity
            .and_then(|id| entities.iter().find(|e| e.id == id))?;

        let label = if field.strong { "owns" } else { "refs" };

        let relationship_line = match field.relationship {
            FieldRelationshipType::OneToOne => {
                let cardinality = if field.required { "||--||" } else { "||--o|" };
                format!(
                    "{} {} {} : {}",
                    owner_entity.name, cardinality, target_entity.name, label
                )
            }
            FieldRelationshipType::OneToMany => {
                format!(
                    "{} ||--o{{ {} : {}",
                    owner_entity.name, target_entity.name, label
                )
            }
            FieldRelationshipType::OrderedOneToMany => {
                format!(
                    "{} ||--o{{ {} : {}\\ ordered",
                    owner_entity.name, target_entity.name, label
                )
            }
            FieldRelationshipType::ManyToMany => {
                // Use dotted line for non-identifying (refs) relationship
                format!(
                    "{} }}o..o{{ {} : {}",
                    owner_entity.name, target_entity.name, label
                )
            }
            FieldRelationshipType::ManyToOne => {
                // Reverse cardinality
                let cardinality = if field.required { "||--||" } else { "||--o|" };
                format!(
                    "{} {} {} : {}",
                    target_entity.name, cardinality, owner_entity.name, label
                )
            }
        };

        Some(relationship_line)
    }
}
